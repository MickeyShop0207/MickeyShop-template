# çµ±ä¸€éŒ¯èª¤è™•ç†ç³»çµ±

## ç¾æœ‰å•é¡Œåˆ†æ

### å„ç³»çµ±éŒ¯èª¤è™•ç†ä¸ä¸€è‡´
- **åœ‹éš›åŒ–ç³»çµ±**: ä½¿ç”¨ `console.warn` + å›é€€åˆ°ç©ºå°è±¡
- **ç‹€æ…‹ç®¡ç†**: å¤šç¨®éŒ¯èª¤è™•ç†æ–¹å¼ï¼Œéƒ¨åˆ†æœ‰æ¢å¾©æ©Ÿåˆ¶
- **PWAç³»çµ±**: ç°¡å–®çš„ `throw new Error`ï¼Œç¼ºå°‘åˆ†é¡
- **å‹•ç•«ç³»çµ±**: åŸºæœ¬ `console.error`ï¼Œç„¡çµ±ä¸€è™•ç†
- **å¿«å–ç³»çµ±**: å„è‡ªçš„éŒ¯èª¤è™•ç†ç­–ç•¥

### ç¼ºå°‘çš„çµ±ä¸€æ©Ÿåˆ¶
- éŒ¯èª¤åˆ†é¡å’Œåš´é‡æ€§åˆ¤å®š
- çµ±ä¸€çš„éŒ¯èª¤æ¢å¾©ç­–ç•¥  
- ç”¨æˆ¶å‹å¥½çš„éŒ¯èª¤æç¤º
- éŒ¯èª¤ä¸Šå ±å’Œç›£æ§
- è·¨ç³»çµ±éŒ¯èª¤å”èª¿

## çµ±ä¸€éŒ¯èª¤è™•ç†æ¶æ§‹

### éŒ¯èª¤åˆ†é¡ç³»çµ±
```js
// utils/error-types.js
export const ERROR_TYPES = {
  // ç¶²è·¯ç›¸é—œéŒ¯èª¤
  NETWORK: 'NETWORK',
  TIMEOUT: 'TIMEOUT', 
  CONNECTION: 'CONNECTION',
  
  // APIç›¸é—œéŒ¯èª¤
  API_ERROR: 'API_ERROR',
  VALIDATION: 'VALIDATION',
  PERMISSION: 'PERMISSION',
  
  // ç³»çµ±éŒ¯èª¤
  CHUNK_LOAD: 'CHUNK_LOAD',
  MEMORY: 'MEMORY',
  STORAGE: 'STORAGE',
  
  // ç”¨æˆ¶æ“ä½œéŒ¯èª¤
  INPUT_ERROR: 'INPUT_ERROR',
  ACTION_FAILED: 'ACTION_FAILED',
  
  // ç¬¬ä¸‰æ–¹éŒ¯èª¤
  PAYMENT: 'PAYMENT',
  AUTH_PROVIDER: 'AUTH_PROVIDER',
  CDN: 'CDN'
}

export const ERROR_SEVERITY = {
  LOW: 'low',       // ä¸å½±éŸ¿æ ¸å¿ƒåŠŸèƒ½
  MEDIUM: 'medium', // å½±éŸ¿éƒ¨åˆ†åŠŸèƒ½
  HIGH: 'high',     // å½±éŸ¿ä¸»è¦åŠŸèƒ½
  CRITICAL: 'critical' // å½±éŸ¿æ•´å€‹æ‡‰ç”¨
}
```

### éŒ¯èª¤åˆ†é¡å™¨
```js
// utils/error-classifier.js
export class ErrorClassifier {
  static classify(error, context = {}) {
    const errorInfo = {
      type: this.getErrorType(error, context),
      severity: this.getSeverity(error, context),
      message: this.getReadableMessage(error),
      stack: error.stack,
      context,
      timestamp: Date.now(),
      id: crypto.randomUUID(),
      recoverable: this.isRecoverable(error, context)
    }
    
    return errorInfo
  }
  
  static getErrorType(error, context) {
    // ç¶²è·¯éŒ¯èª¤
    if (error.name === 'NetworkError' || 
        error.message.includes('fetch') ||
        error.message.includes('network')) {
      return ERROR_TYPES.NETWORK
    }
    
    // APIéŒ¯èª¤
    if (context.apiEndpoint || error.status) {
      return ERROR_TYPES.API_ERROR
    }
    
    // è¼‰å…¥éŒ¯èª¤
    if (error.name === 'ChunkLoadError' || 
        error.message.includes('Loading chunk')) {
      return ERROR_TYPES.CHUNK_LOAD
    }
    
    // é©—è­‰éŒ¯èª¤
    if (error.name === 'ValidationError' || context.validation) {
      return ERROR_TYPES.VALIDATION
    }
    
    // å­˜å„²éŒ¯èª¤
    if (error.name === 'QuotaExceededError' ||
        error.message.includes('storage')) {
      return ERROR_TYPES.STORAGE
    }
    
    // æ¬Šé™éŒ¯èª¤
    if (error.status === 403 || error.status === 401) {
      return ERROR_TYPES.PERMISSION
    }
    
    // è¶…æ™‚éŒ¯èª¤
    if (error.name === 'TimeoutError' || 
        error.message.includes('timeout')) {
      return ERROR_TYPES.TIMEOUT
    }
    
    // é è¨­ç‚ºä¸€èˆ¬éŒ¯èª¤
    return 'UNKNOWN'
  }
  
  static getSeverity(error, context) {
    const errorType = this.getErrorType(error, context)
    
    // é—œéµéŒ¯èª¤
    if (errorType === ERROR_TYPES.CHUNK_LOAD ||
        errorType === ERROR_TYPES.MEMORY ||
        (errorType === ERROR_TYPES.API_ERROR && context.critical)) {
      return ERROR_SEVERITY.CRITICAL
    }
    
    // é«˜åš´é‡æ€§
    if (errorType === ERROR_TYPES.NETWORK ||
        errorType === ERROR_TYPES.STORAGE ||
        errorType === ERROR_TYPES.PAYMENT) {
      return ERROR_SEVERITY.HIGH
    }
    
    // ä¸­ç­‰åš´é‡æ€§
    if (errorType === ERROR_TYPES.API_ERROR ||
        errorType === ERROR_TYPES.TIMEOUT ||
        errorType === ERROR_TYPES.AUTH_PROVIDER) {
      return ERROR_SEVERITY.MEDIUM
    }
    
    // ä½åš´é‡æ€§
    return ERROR_SEVERITY.LOW
  }
  
  static getReadableMessage(error) {
    const messageMap = {
      'ChunkLoadError': 'è¼‰å…¥è³‡æºå¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢',
      'NetworkError': 'ç¶²è·¯é€£æ¥ç•°å¸¸ï¼Œè«‹æª¢æŸ¥ç¶²è·¯è¨­å®š',
      'ValidationError': 'è¼¸å…¥è³‡æ–™æ ¼å¼ä¸æ­£ç¢º',
      'QuotaExceededError': 'å„²å­˜ç©ºé–“ä¸è¶³ï¼Œè«‹æ¸…ç†ç€è¦½å™¨è³‡æ–™',
      'TimeoutError': 'è«‹æ±‚è¶…æ™‚ï¼Œè«‹ç¨å¾Œå†è©¦'
    }
    
    return messageMap[error.name] || 
           messageMap[error.constructor.name] || 
           error.message || 
           'ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤'
  }
  
  static isRecoverable(error, context) {
    const errorType = this.getErrorType(error, context)
    
    const recoverableTypes = [
      ERROR_TYPES.NETWORK,
      ERROR_TYPES.TIMEOUT,
      ERROR_TYPES.API_ERROR,
      ERROR_TYPES.CHUNK_LOAD
    ]
    
    return recoverableTypes.includes(errorType)
  }
}
```

### çµ±ä¸€éŒ¯èª¤è™•ç†ä¸­å¿ƒ
```js
// stores/error-handler.js
import { create } from 'zustand'
import { ErrorClassifier } from '@/utils/error-classifier'
import { ErrorRecovery } from '@/utils/error-recovery'
import { ErrorReporter } from '@/utils/error-reporter'

export const useErrorHandler = create((set, get) => ({
  // éŒ¯èª¤ç‹€æ…‹
  errors: [],
  globalError: null,
  isRecovering: false,
  recoveryAttempts: {},
  
  // éŒ¯èª¤è™•ç†
  handleError: async (error, context = {}) => {
    const errorInfo = ErrorClassifier.classify(error, context)
    const state = get()
    
    // è¨˜éŒ„éŒ¯èª¤
    set({ 
      errors: [...state.errors, errorInfo].slice(-50) // åªä¿ç•™æœ€è¿‘50å€‹éŒ¯èª¤
    })
    
    // ä¸Šå ±éŒ¯èª¤
    ErrorReporter.report(errorInfo)
    
    // åš´é‡éŒ¯èª¤è™•ç†
    if (errorInfo.severity === ERROR_SEVERITY.CRITICAL) {
      set({ globalError: errorInfo })
      await get().handleCriticalError(errorInfo)
      return
    }
    
    // å˜—è©¦æ¢å¾©
    if (errorInfo.recoverable) {
      await get().attemptRecovery(errorInfo)
    }
    
    // ç”¨æˆ¶æç¤º
    get().showUserNotification(errorInfo)
  },
  
  // é—œéµéŒ¯èª¤è™•ç†
  handleCriticalError: async (errorInfo) => {
    set({ isRecovering: true })
    
    try {
      console.error('ğŸš¨ é—œéµéŒ¯èª¤:', errorInfo)
      
      // æš«åœéå¿…è¦åŠŸèƒ½
      window.dispatchEvent(new CustomEvent('critical-error', { 
        detail: errorInfo 
      }))
      
      // å˜—è©¦æ¢å¾©
      const recovered = await ErrorRecovery.handleCritical(errorInfo)
      
      if (recovered) {
        set({ 
          globalError: null, 
          isRecovering: false 
        })
        
        window.dispatchEvent(new CustomEvent('error-recovered', { 
          detail: errorInfo 
        }))
      } else {
        // æ¢å¾©å¤±æ•—ï¼Œé€²å…¥å®‰å…¨æ¨¡å¼
        get().enterSafeMode()
      }
      
    } catch (recoveryError) {
      console.error('âŒ éŒ¯èª¤æ¢å¾©å¤±æ•—:', recoveryError)
      get().enterSafeMode()
    }
  },
  
  // å˜—è©¦éŒ¯èª¤æ¢å¾©
  attemptRecovery: async (errorInfo) => {
    const { recoveryAttempts } = get()
    const attempts = recoveryAttempts[errorInfo.id] || 0
    
    if (attempts >= 3) {
      console.warn('âš ï¸ è¶…éæœ€å¤§é‡è©¦æ¬¡æ•¸:', errorInfo)
      return false
    }
    
    set({
      recoveryAttempts: {
        ...recoveryAttempts,
        [errorInfo.id]: attempts + 1
      }
    })
    
    const recovered = await ErrorRecovery.attempt(errorInfo)
    
    if (recovered) {
      console.log('âœ… éŒ¯èª¤æ¢å¾©æˆåŠŸ:', errorInfo.type)
      // æ¸…ç†æˆåŠŸæ¢å¾©çš„éŒ¯èª¤
      const { recoveryAttempts } = get()
      delete recoveryAttempts[errorInfo.id]
      set({ recoveryAttempts })
    }
    
    return recovered
  },
  
  // ç”¨æˆ¶é€šçŸ¥
  showUserNotification: (errorInfo) => {
    const severity = errorInfo.severity
    const message = errorInfo.message
    
    // æ ¹æ“šåš´é‡æ€§é¸æ“‡é€šçŸ¥é¡å‹
    if (severity === ERROR_SEVERITY.HIGH) {
      // ä½¿ç”¨ Ant Design çš„ notification
      window.dispatchEvent(new CustomEvent('show-error-notification', {
        detail: {
          type: 'error',
          title: 'æ“ä½œå¤±æ•—',
          message,
          duration: 8
        }
      }))
    } else if (severity === ERROR_SEVERITY.MEDIUM) {
      window.dispatchEvent(new CustomEvent('show-error-notification', {
        detail: {
          type: 'warning',
          title: 'è«‹æ³¨æ„',
          message,
          duration: 5
        }
      }))
    }
    // ä½åš´é‡æ€§éŒ¯èª¤ä¸é¡¯ç¤ºç”¨æˆ¶é€šçŸ¥
  },
  
  // é€²å…¥å®‰å…¨æ¨¡å¼
  enterSafeMode: () => {
    console.log('ğŸ›¡ï¸ é€²å…¥å®‰å…¨æ¨¡å¼')
    
    // æ¸…é™¤å¯èƒ½æœ‰å•é¡Œçš„ç‹€æ…‹
    localStorage.clear()
    sessionStorage.clear()
    
    // é€šçŸ¥æ‰€æœ‰ç³»çµ±é€²å…¥å®‰å…¨æ¨¡å¼
    window.dispatchEvent(new CustomEvent('enter-safe-mode'))
    
    // æœ€å¾Œæ‰‹æ®µï¼šé‡æ–°è¼‰å…¥
    setTimeout(() => {
      window.location.reload()
    }, 3000)
  },
  
  // æ¸…ç†éŒ¯èª¤
  clearErrors: () => {
    set({ 
      errors: [], 
      globalError: null,
      recoveryAttempts: {}
    })
  },
  
  // æ‰‹å‹•é‡è©¦
  retryOperation: (errorInfo) => {
    if (errorInfo.context.retryCallback) {
      errorInfo.context.retryCallback()
    }
  }
}))
```

### éŒ¯èª¤æ¢å¾©ç³»çµ±
```js
// utils/error-recovery.js
export class ErrorRecovery {
  static async attempt(errorInfo) {
    const { type, context } = errorInfo
    
    switch (type) {
      case ERROR_TYPES.NETWORK:
        return await this.recoverNetwork(context)
        
      case ERROR_TYPES.CHUNK_LOAD:
        return await this.recoverChunkLoad(context)
        
      case ERROR_TYPES.STORAGE:
        return await this.recoverStorage(context)
        
      case ERROR_TYPES.API_ERROR:
        return await this.recoverAPI(context)
        
      case ERROR_TYPES.TIMEOUT:
        return await this.recoverTimeout(context)
        
      default:
        return false
    }
  }
  
  static async handleCritical(errorInfo) {
    console.log('ğŸ”§ è™•ç†é—œéµéŒ¯èª¤:', errorInfo.type)
    
    // æ¸…ç†å¯èƒ½æå£çš„ç‹€æ…‹
    try {
      // æ¸…é™¤ IndexedDB
      if ('indexedDB' in window) {
        const databases = await indexedDB.databases?.() || []
        for (const db of databases) {
          indexedDB.deleteDatabase(db.name)
        }
      }
      
      // æ¸…é™¤å¿«å–
      if ('caches' in window) {
        const cacheNames = await caches.keys()
        await Promise.all(
          cacheNames.map(name => caches.delete(name))
        )
      }
      
      // é‡ç½®ç‹€æ…‹ç®¡ç†å™¨
      if (window.stateCoordinator) {
        window.stateCoordinator.reset()
      }
      
      return true
      
    } catch (error) {
      console.error('âŒ é—œéµéŒ¯èª¤æ¢å¾©å¤±æ•—:', error)
      return false
    }
  }
  
  static async recoverNetwork(context) {
    // ç­‰å¾…ç¶²è·¯æ¢å¾©
    if (!navigator.onLine) {
      return new Promise((resolve) => {
        const handleOnline = () => {
          window.removeEventListener('online', handleOnline)
          resolve(true)
        }
        window.addEventListener('online', handleOnline)
        
        // 3ç§’è¶…æ™‚
        setTimeout(() => {
          window.removeEventListener('online', handleOnline)
          resolve(false)
        }, 3000)
      })
    }
    
    // å˜—è©¦é‡æ–°ç™¼é€è«‹æ±‚
    if (context.retryCallback) {
      try {
        await context.retryCallback()
        return true
      } catch {
        return false
      }
    }
    
    return false
  }
  
  static async recoverChunkLoad(context) {
    try {
      // æ¸…é™¤æ¨¡çµ„å¿«å–
      if (window.webpackChunkName) {
        delete window[window.webpackChunkName]
      }
      
      // é‡æ–°è¼‰å…¥å¤±æ•—çš„å€å¡Š
      if (context.chunkName && window.__webpack_require__) {
        await window.__webpack_require__(context.chunkName)
        return true
      }
      
      // å›é€€åˆ°é é¢é‡æ–°è¼‰å…¥
      window.location.reload()
      return true
      
    } catch {
      return false
    }
  }
  
  static async recoverStorage(context) {
    try {
      // æ¸…ç† localStorage
      const usage = await navigator.storage?.estimate?.() || {}
      if (usage.quota && usage.usage) {
        const usageRatio = usage.usage / usage.quota
        if (usageRatio > 0.9) {
          // æ¸…ç†èˆŠæ•¸æ“š
          this.cleanupStorage()
        }
      }
      
      return true
      
    } catch {
      return false
    }
  }
  
  static async recoverAPI(context) {
    const { status, endpoint, retryCallback } = context
    
    // æ ¹æ“šç‹€æ…‹ç¢¼æ±ºå®šæ¢å¾©ç­–ç•¥
    if (status === 401) {
      // å˜—è©¦åˆ·æ–° token
      try {
        await window.authStore?.getState?.()?.refreshToken?.()
        if (retryCallback) {
          await retryCallback()
          return true
        }
      } catch {
        // é‡å°å‘åˆ°ç™»å…¥é 
        window.location.href = '/login'
      }
    }
    
    if (status >= 500 && status < 600) {
      // ä¼ºæœå™¨éŒ¯èª¤ï¼Œç­‰å¾…å¾Œé‡è©¦
      await this.delay(1000)
      if (retryCallback) {
        try {
          await retryCallback()
          return true
        } catch {
          return false
        }
      }
    }
    
    return false
  }
  
  static async recoverTimeout(context) {
    // è¶…æ™‚æ¢å¾©ï¼šå¢åŠ timeoutæ™‚é–“å¾Œé‡è©¦
    if (context.retryCallback) {
      try {
        await context.retryCallback()
        return true
      } catch {
        return false
      }
    }
    
    return false
  }
  
  static cleanupStorage() {
    try {
      // æ¸…ç†éæœŸçš„ localStorage é …ç›®
      const now = Date.now()
      const keysToRemove = []
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i)
        if (key?.includes('cache-') || key?.includes('temp-')) {
          try {
            const item = JSON.parse(localStorage.getItem(key))
            if (item.expiry && item.expiry < now) {
              keysToRemove.push(key)
            }
          } catch {
            keysToRemove.push(key)
          }
        }
      }
      
      keysToRemove.forEach(key => localStorage.removeItem(key))
      
    } catch (error) {
      console.warn('âš ï¸ å„²å­˜æ¸…ç†å¤±æ•—:', error)
    }
  }
  
  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}
```

### éŒ¯èª¤ä¸Šå ±ç³»çµ±
```js
// utils/error-reporter.js
export class ErrorReporter {
  static async report(errorInfo) {
    // é–‹ç™¼ç’°å¢ƒåªè¨˜éŒ„åˆ°console
    if (process.env.NODE_ENV === 'development') {
      console.group(`ğŸ› [${errorInfo.severity}] ${errorInfo.type}`)
      console.error('éŒ¯èª¤è¨Šæ¯:', errorInfo.message)
      console.error('éŒ¯èª¤ä¸Šä¸‹æ–‡:', errorInfo.context)
      console.error('éŒ¯èª¤å †ç–Š:', errorInfo.stack)
      console.groupEnd()
      return
    }
    
    // ç”Ÿç”¢ç’°å¢ƒä¸Šå ±åˆ°éŒ¯èª¤ç›£æ§æœå‹™
    try {
      // æ¡æ¨£ç‡æ§åˆ¶ï¼ˆé¿å…éå¤šéŒ¯èª¤ä¸Šå ±ï¼‰
      const shouldReport = this.shouldReport(errorInfo)
      if (!shouldReport) return
      
      const reportData = {
        ...errorInfo,
        userAgent: navigator.userAgent,
        url: window.location.href,
        userId: this.getUserId(),
        sessionId: this.getSessionId(),
        buildVersion: process.env.REACT_APP_VERSION
      }
      
      // ä½¿ç”¨ navigator.sendBeacon ç¢ºä¿éŒ¯èª¤èƒ½å¤ ä¸Šå ±
      if (navigator.sendBeacon) {
        navigator.sendBeacon(
          '/api/errors',
          JSON.stringify(reportData)
        )
      } else {
        // å‚™ç”¨æ–¹æ¡ˆ
        fetch('/api/errors', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(reportData),
          keepalive: true
        }).catch(() => {
          // å¿½ç•¥ä¸Šå ±å¤±æ•—
        })
      }
      
    } catch (error) {
      console.warn('âš ï¸ éŒ¯èª¤ä¸Šå ±å¤±æ•—:', error)
    }
  }
  
  static shouldReport(errorInfo) {
    // é—œéµå’Œé«˜åš´é‡æ€§éŒ¯èª¤ä¸€å®šä¸Šå ±
    if (errorInfo.severity === ERROR_SEVERITY.CRITICAL ||
        errorInfo.severity === ERROR_SEVERITY.HIGH) {
      return true
    }
    
    // ä¸­ç­‰åš´é‡æ€§éŒ¯èª¤50%æ©Ÿç‡ä¸Šå ±
    if (errorInfo.severity === ERROR_SEVERITY.MEDIUM) {
      return Math.random() < 0.5
    }
    
    // ä½åš´é‡æ€§éŒ¯èª¤10%æ©Ÿç‡ä¸Šå ±
    return Math.random() < 0.1
  }
  
  static getUserId() {
    // å¾èªè­‰ç‹€æ…‹ç²å–ç”¨æˆ¶ID
    return window.authStore?.getState?.()?.user?.id || 'anonymous'
  }
  
  static getSessionId() {
    let sessionId = sessionStorage.getItem('session-id')
    if (!sessionId) {
      sessionId = crypto.randomUUID()
      sessionStorage.setItem('session-id', sessionId)
    }
    return sessionId
  }
}
```

## å„ç³»çµ±éŒ¯èª¤è™•ç†æ•´åˆ

### åœ‹éš›åŒ–ç³»çµ±æ•´åˆ
```js
// æ›´æ–° utils/translation-loader.js
async _fetchTranslation(namespace, language) {
  try {
    const response = await fetch(`/locales/${language}/${namespace}.json`)
    if (!response.ok) {
      throw new Error(`Failed to load ${namespace} for ${language}`)
    }
    return await response.json()
  } catch (error) {
    // ä½¿ç”¨çµ±ä¸€éŒ¯èª¤è™•ç†
    useErrorHandler.getState().handleError(error, {
      type: 'translation-load',
      namespace,
      language,
      retryCallback: () => this._fetchTranslation(namespace, language)
    })
    
    // è¿”å›ç©ºå°è±¡ä½œç‚ºå‚™ç”¨
    return {}
  }
}
```

### ç‹€æ…‹ç®¡ç†ç³»çµ±æ•´åˆ
```js
// æ›´æ–°å„å€‹ storeï¼Œçµ±ä¸€éŒ¯èª¤è™•ç†
const useProductStore = create((set, get) => ({
  // ... å…¶ä»–ç‹€æ…‹
  
  loadProducts: async () => {
    try {
      set({ isLoading: true })
      const products = await api.getProducts()
      set({ products, isLoading: false })
    } catch (error) {
      set({ isLoading: false })
      
      // ä½¿ç”¨çµ±ä¸€éŒ¯èª¤è™•ç†
      useErrorHandler.getState().handleError(error, {
        apiEndpoint: '/api/products',
        critical: true, // å•†å“è¼‰å…¥å¤±æ•—æ˜¯é—œéµéŒ¯èª¤
        retryCallback: () => get().loadProducts()
      })
    }
  }
}))
```

### PWAç³»çµ±æ•´åˆ
```js
// æ›´æ–° PWA ç›¸é—œéŒ¯èª¤è™•ç†
async requestPermission() {
  try {
    if (!('Notification' in window)) {
      throw new Error('ç€è¦½å™¨ä¸æ”¯æ´é€šçŸ¥åŠŸèƒ½')
    }
    
    const permission = await Notification.requestPermission()
    if (permission !== 'granted') {
      throw new Error('ç”¨æˆ¶æ‹’çµ•é€šçŸ¥æ¬Šé™')
    }
    
    return permission
  } catch (error) {
    useErrorHandler.getState().handleError(error, {
      type: 'pwa-permission',
      feature: 'notification'
    })
    throw error
  }
}
```

## React éŒ¯èª¤é‚Šç•Œæ•´åˆ

### å…¨åŸŸéŒ¯èª¤é‚Šç•Œçµ„ä»¶
```jsx
// components/ErrorBoundary.jsx
import React from 'react'
import { Result, Button } from 'antd'
import { useErrorHandler } from '@/stores/error-handler'

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false, errorInfo: null }
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true }
  }
  
  componentDidCatch(error, errorInfo) {
    // ä½¿ç”¨çµ±ä¸€éŒ¯èª¤è™•ç†ç³»çµ±
    useErrorHandler.getState().handleError(error, {
      type: 'react-boundary',
      componentStack: errorInfo.componentStack,
      critical: true
    })
    
    this.setState({ errorInfo })
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <Result
          status="500"
          title="é é¢è¼‰å…¥å¤±æ•—"
          subTitle="æŠ±æ­‰ï¼Œé é¢é‡åˆ°äº†å•é¡Œ"
          extra={
            <Button type="primary" onClick={() => window.location.reload()}>
              é‡æ–°è¼‰å…¥
            </Button>
          }
        />
      )
    }
    
    return this.props.children
  }
}

export default ErrorBoundary
```

### HookéŒ¯èª¤è™•ç†
```js
// hooks/useErrorHandler.js
import { useCallback } from 'react'
import { useErrorHandler as useErrorStore } from '@/stores/error-handler'

export const useErrorHandler = () => {
  const { handleError } = useErrorStore()
  
  const handleAsyncError = useCallback(async (asyncFn, context = {}) => {
    try {
      return await asyncFn()
    } catch (error) {
      handleError(error, context)
      throw error // é‡æ–°æ‹‹å‡ºï¼Œè®“èª¿ç”¨è€…æ±ºå®šæ˜¯å¦ç¹¼çºŒè™•ç†
    }
  }, [handleError])
  
  const createErrorHandler = useCallback((context = {}) => {
    return (error) => handleError(error, context)
  }, [handleError])
  
  return {
    handleError,
    handleAsyncError,
    createErrorHandler
  }
}
```

## å…¨åŸŸéŒ¯èª¤ç›£è½å™¨è¨­ç½®

### æ‡‰ç”¨åˆå§‹åŒ–éŒ¯èª¤ç›£è½
```js
// main.jsx æˆ– App.jsx ä¸­è¨­ç½®
import { useErrorHandler } from '@/stores/error-handler'

// å…¨åŸŸéŒ¯èª¤æ•ç²
window.addEventListener('error', (event) => {
  useErrorHandler.getState().handleError(event.error, {
    type: 'global-error',
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  })
})

// æœªè™•ç†çš„ Promise æ‹’çµ•
window.addEventListener('unhandledrejection', (event) => {
  useErrorHandler.getState().handleError(event.reason, {
    type: 'unhandled-promise'
  })
})

// è³‡æºè¼‰å…¥éŒ¯èª¤
window.addEventListener('error', (event) => {
  if (event.target !== window) {
    useErrorHandler.getState().handleError(
      new Error(`è³‡æºè¼‰å…¥å¤±æ•—: ${event.target.src || event.target.href}`),
      {
        type: 'resource-load',
        element: event.target.tagName,
        src: event.target.src || event.target.href
      }
    )
  }
}, true)
```

## éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸

### å„ç³»çµ±çµ±ä¸€è¦ç¯„
1. **æ‰€æœ‰ç³»çµ±å¿…é ˆä½¿ç”¨ `useErrorHandler.getState().handleError()`**
2. **æä¾›æœ‰æ„ç¾©çš„ context ä¿¡æ¯**
3. **ç‚ºå¯é‡è©¦æ“ä½œæä¾› retryCallback**
4. **æ¨™è¨˜é—œéµæ€§æ“ä½œ critical: true**
5. **ä½¿ç”¨é©ç•¶çš„éŒ¯èª¤é¡å‹åˆ†é¡**

### éŒ¯èª¤æ¢å¾©ç­–ç•¥
1. **è‡ªå‹•æ¢å¾©**: ç¶²è·¯éŒ¯èª¤ã€è¶…æ™‚éŒ¯èª¤
2. **ç”¨æˆ¶ç¢ºèªæ¢å¾©**: æ¬Šé™éŒ¯èª¤ã€é©—è­‰éŒ¯èª¤
3. **ç³»çµ±æ¢å¾©**: è³‡æºè¼‰å…¥éŒ¯èª¤ã€å„²å­˜éŒ¯èª¤
4. **å®‰å…¨æ¨¡å¼**: é—œéµç³»çµ±éŒ¯èª¤

### ç”¨æˆ¶é«”é©—è€ƒæ…®
1. **éŒ¯èª¤è¨Šæ¯è¦ç”¨æˆ¶å‹å¥½**
2. **æä¾›æ˜ç¢ºçš„æ¢å¾©æ“ä½œ**
3. **é¿å…é‡è¤‡éŒ¯èª¤æç¤º**
4. **ä¿æŒæ‡‰ç”¨å¯ç”¨æ€§**

## å„ç³»çµ±å¼•ç”¨æŒ‡å—

### å¦‚ä½•åœ¨å„ç³»çµ±ä¸­ä½¿ç”¨çµ±ä¸€éŒ¯èª¤è™•ç†

#### 1. åŸºæœ¬å¼•ç”¨æ–¹å¼
```js
// å‹•æ…‹å¼•ç”¨ï¼ˆæ¨è–¦ï¼‰
const { useErrorHandler } = await import('@/stores/error-handler')
useErrorHandler.getState().handleError(error, context)

// éœæ…‹å¼•ç”¨
import { useErrorHandler } from '@/stores/error-handler'
useErrorHandler.getState().handleError(error, context)
```

#### 2. å„ç³»çµ±å…·é«”æ•´åˆ

**åœ‹éš›åŒ–ç³»çµ±** (02-åœ‹éš›åŒ–å¯¦ç¾ç­–ç•¥.md):
```js
// ç¿»è­¯è¼‰å…¥éŒ¯èª¤
useErrorHandler.getState().handleError(error, {
  type: 'translation-load',
  namespace,
  language,
  retryCallback: () => this._fetchTranslation(namespace, language)
})
```

**ç‹€æ…‹ç®¡ç†ç³»çµ±** (04-ç‹€æ…‹ç®¡ç†æ¶æ§‹.md):
```js
// è¨»å†ŠéŒ¯èª¤è™•ç†ç³»çµ±
stateCoordinator.register('error', useErrorHandler)
```

**å‹•ç•«ç³»çµ±** (09-GSAPå‹•ç•«ç³»çµ±è¨­è¨ˆ.md):
```js
// å‹•ç•«è¼‰å…¥éŒ¯èª¤
useErrorHandler.getState().handleError(error, {
  type: 'animation-load',
  animationName: name,
  retryCallback: () => this.loadAnimation(name)
})
```

**ç¯©é¸ç³»çµ±** (12-å‰å°ç¯©é¸æ¢ä»¶ç³»çµ±.md):
```js
// ç¯©é¸æ‡‰ç”¨éŒ¯èª¤
useErrorHandler.getState().handleError(error, {
  type: 'filter-application',
  filters: filters,
  retryCallback: () => get().applyFilters(filters)
})
```

**PWAç³»çµ±** (08-å¿«å–ç­–ç•¥è¨­è¨ˆ.md):
```js
// PWAåŠŸèƒ½éŒ¯èª¤ï¼ˆä¿æŒåŸæœ‰throw Errorç”¨æ–¼åŠŸèƒ½æª¢æ¸¬ï¼‰
// åƒ…åœ¨éœ€è¦çµ±ä¸€è™•ç†æ™‚ä½¿ç”¨
useErrorHandler.getState().handleError(error, {
  type: 'pwa-feature',
  feature: 'notification'
})
```

#### 3. Contextåƒæ•¸å»ºè­°

**å¿…è¦åƒæ•¸**ï¼š
- `type`: éŒ¯èª¤é¡å‹ï¼ˆè¦‹ERROR_TYPESï¼‰
- `retryCallback`: é‡è©¦å‡½æ•¸ï¼ˆå¯é¸ä½†æ¨è–¦ï¼‰

**å¯é¸åƒæ•¸**ï¼š
- `critical`: æ˜¯å¦é—œéµéŒ¯èª¤
- `apiEndpoint`: APIç«¯é»ï¼ˆAPIéŒ¯èª¤æ™‚ï¼‰
- `componentName`: çµ„ä»¶åç¨±
- `userId`: ç”¨æˆ¶ID
- `feature`: åŠŸèƒ½åç¨±

#### 4. æœ€ä½³å¯¦è¸

1. **ä¿æŒç¨ç«‹æ€§**: éŒ¯èª¤è™•ç†ç³»çµ±ä¿æŒç¨ç«‹ï¼Œå„ç³»çµ±æŒ‰éœ€å¼•ç”¨
2. **å‹•æ…‹å¼•ç”¨**: ä½¿ç”¨`import()`é¿å…å¾ªç’°ä¾è³´
3. **æœ‰æ„ç¾©çš„context**: æä¾›è¶³å¤ çš„éŒ¯èª¤ä¸Šä¸‹æ–‡ä¿¡æ¯
4. **é‡è©¦æ©Ÿåˆ¶**: ç‚ºå¯æ¢å¾©éŒ¯èª¤æä¾›retryCallback
5. **åŠŸèƒ½æ€§éŒ¯èª¤**: åŠŸèƒ½æª¢æ¸¬éŒ¯èª¤å¯ä¿æŒåŸæœ‰è™•ç†æ–¹å¼

é€™å€‹çµ±ä¸€éŒ¯èª¤è™•ç†ç³»çµ±è§£æ±ºäº†å„ç³»çµ±éŒ¯èª¤è™•ç†ä¸ä¸€è‡´çš„å•é¡Œï¼Œæä¾›äº†å®Œæ•´çš„éŒ¯èª¤åˆ†é¡ã€æ¢å¾©ã€ä¸Šå ±æ©Ÿåˆ¶ã€‚