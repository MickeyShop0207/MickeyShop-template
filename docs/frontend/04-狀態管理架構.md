# 狀態管理架構 (完整整合版)

## 技術選型與整合策略

- **狀態管理**: Zustand (客戶端狀態)
- **API狀態**: React Query (TanStack Query) (服務端狀態)
- **系統協調**: 統一狀態協調器 (跨系統同步)
- **整合範圍**: 主題系統、動畫系統、國際化、PWA、錯誤處理、性能監控

## 統一狀態協調器

### 核心協調器設計
```javascript
// stores/coordinator.js - 中央狀態協調系統
class StateCoordinator {
  constructor() {
    this.subscribers = new Map()
    this.eventBus = new EventTarget()
    this.syncQueue = []
    this.isInitialized = false
    this.performanceMetrics = {
      syncCount: 0,
      avgSyncTime: 0,
      errorCount: 0
    }
  }
  
  // 註冊狀態管理器
  register(name, store, config = {}) {
    this.subscribers.set(name, {
      store,
      config: {
        syncOnInit: false,
        syncOnChange: [],
        dependencies: [],
        integrations: [],
        ...config
      },
      lastSync: Date.now()
    })
    
    console.log(`📝 註冊狀態管理器: ${name}`)
  }
  
  // 發布跨系統事件
  publish(eventType, data, source) {
    const event = new CustomEvent(eventType, {
      detail: { data, source, timestamp: Date.now() }
    })
    
    this.eventBus.dispatchEvent(event)
    console.log(`📡 發布事件: ${eventType} (來源: ${source})`)
  }
  
  // 訂閱跨系統事件
  subscribe(eventType, callback) {
    this.eventBus.addEventListener(eventType, callback)
  }
  
  // 批量狀態同步
  async syncAll() {
    const startTime = performance.now()
    console.log('🔄 開始全系統狀態同步...')
    
    try {
      const syncPromises = Array.from(this.subscribers.entries())
        .map(([name, { store, config }]) => this.syncStore(name, store, config))
      
      const results = await Promise.allSettled(syncPromises)
      
      const successful = results.filter(r => r.status === 'fulfilled').length
      const failed = results.filter(r => r.status === 'rejected').length
      
      const duration = performance.now() - startTime
      this.updatePerformanceMetrics(duration, failed)
      
      console.log(`✅ 狀態同步完成: ${successful} 成功, ${failed} 失敗 (${duration.toFixed(2)}ms)`)
      this.publish('sync-completed', { successful, failed, duration }, 'coordinator')
      
    } catch (error) {
      console.error('❌ 狀態同步失敗:', error)
      this.publish('sync-error', error, 'coordinator')
    }
  }
  
  updatePerformanceMetrics(duration, errorCount) {
    this.performanceMetrics.syncCount++
    this.performanceMetrics.avgSyncTime = 
      (this.performanceMetrics.avgSyncTime + duration) / 2
    this.performanceMetrics.errorCount += errorCount
  }
}

export const stateCoordinator = new StateCoordinator()
```

## Zustand Store架構

### 1. 增強主題狀態管理 (整合色彩系統)
```javascript
// stores/theme.js - 與配置驅動色彩系統完整整合
import { themeConfig } from '@/config'
import { stateCoordinator } from './coordinator'

export const useThemeStore = create((set, get) => ({
  // 基本狀態
  theme: themeConfig.defaultTheme,
  isTransitioning: false,
  customColors: null,
  systemTheme: 'light',
  
  // 與配置系統整合的主題設定
  setTheme: (theme) => {
    set({ isTransitioning: true })
    
    // 更新配置驅動的 CSS 變數
    const variables = themeConfig.generateVariables()
    Object.entries(variables).forEach(([key, value]) => {
      document.documentElement.style.setProperty(key, value)
    })
    
    // 設定 data-theme 屬性
    document.documentElement.setAttribute('data-theme', theme)
    
    // 更新狀態
    set({ theme, isTransitioning: false })
    localStorage.setItem('theme-preference', theme)
    
    // 通知其他系統主題變更
    stateCoordinator.publish('theme-changed', { 
      theme, 
      variables, 
      previousTheme: get().theme 
    }, 'theme')
    
    // 通知動畫系統調整
    window.dispatchEvent(new CustomEvent('themeChanged', { detail: theme }))
    
    console.log(`🎨 主題已切換至: ${theme}`)
  },
  
  // 客戶品牌色彩覆蓋
  applyBrandColors: (colors) => {
    const customVariables = Object.entries(colors).reduce((acc, [key, value]) => {
      acc[`--brand-${key}`] = value
      return acc
    }, {})
    
    Object.entries(customVariables).forEach(([key, value]) => {
      document.documentElement.style.setProperty(key, value)
    })
    
    set({ customColors: colors })
    stateCoordinator.publish('brand-colors-updated', colors, 'theme')
    console.log('🎯 品牌色彩已應用')
  },
  
  // 系統主題檢測
  detectSystemTheme: () => {
    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches
    const systemTheme = isDark ? 'dark' : 'light'
    set({ systemTheme })
    return systemTheme
  },
  
  // 完整主題系統初始化
  initThemeSystem: async () => {
    console.log('🎨 初始化主題系統...')
    
    try {
      // 檢測系統主題
      const systemTheme = get().detectSystemTheme()
      
      // 載入保存的偏好或使用系統主題
      const savedTheme = localStorage.getItem('theme-preference') || systemTheme
      
      // 初始化配置驅動的主題變數
      await import('@/utils/themeInitializer').then(({ initializeTheme }) => {
        initializeTheme()
      })
      
      // 設定主題
      get().setTheme(savedTheme)
      
      // 監聽系統主題變化
      window.matchMedia('(prefers-color-scheme: dark)')
        .addEventListener('change', (e) => {
          const newSystemTheme = e.matches ? 'dark' : 'light'
          set({ systemTheme: newSystemTheme })
          
          // 如果用戶沒有手動設定偏好，跟隨系統
          if (!localStorage.getItem('theme-preference')) {
            get().setTheme(newSystemTheme)
          }
          
          stateCoordinator.publish('system-theme-changed', { systemTheme: newSystemTheme }, 'theme')
        })
      
      console.log('✅ 主題系統初始化完成')
      
    } catch (error) {
      console.error('❌ 主題系統初始化失敗:', error)
      // 使用預設主題作為備用
      get().setTheme('light')
    }
  }
}))

// 註冊到協調器
stateCoordinator.register('theme', useThemeStore, {
  syncOnInit: true,
  integrations: ['animation', 'pwa']
})
```

### 2. 增強國際化狀態管理 (整合 react-i18next)
```javascript
// stores/i18n.js - 與 react-i18next 完整整合
import i18n from '@/i18n'
import { stateCoordinator } from './coordinator'
import { queryClient } from '@/config/query-client'

export const useI18nStore = create((set, get) => ({
  // 基本狀態
  locale: 'zh-TW',
  currency: 'TWD',
  region: 'TW',
  isLoading: false,
  loadedNamespaces: new Set(['common']),
  
  // 區域映射配置
  regionMapping: {
    'TW': { locale: 'zh-TW', currency: 'TWD' },
    'HK': { locale: 'zh-HK', currency: 'HKD' },
    'CN': { locale: 'zh-CN', currency: 'CNY' },
    'US': { locale: 'en-US', currency: 'USD' },
    'GB': { locale: 'en-GB', currency: 'GBP' },
    'JP': { locale: 'ja-JP', currency: 'JPY' },
    'KR': { locale: 'ko-KR', currency: 'KRW' }
  },
  
  // 與 react-i18next 整合的語言切換
  setLocale: async (locale) => {
    set({ isLoading: true })
    console.log(`🌐 切換語言至: ${locale}`)
    
    try {
      // 更新 i18next
      await i18n.changeLanguage(locale)
      
      // 更新 HTML lang 屬性
      document.documentElement.lang = locale
      
      // 更新路由 (如果需要)
      const currentPath = window.location.pathname
      const newPath = currentPath.replace(/^\/[a-z]{2}(-[A-Z]{2})?/, `/${locale}`)
      if (newPath !== currentPath && newPath !== `/${locale}`) {
        window.history.replaceState({}, '', newPath)
      }
      
      // 更新狀態
      const previousLocale = get().locale
      set({ locale, isLoading: false })
      localStorage.setItem('locale-preference', locale)
      
      // 通知其他系統語言變更
      stateCoordinator.publish('locale-changed', { 
        locale, 
        previousLocale 
      }, 'i18n')
      
      // 重新載入依賴本地化的資料
      queryClient.invalidateQueries({ 
        predicate: (query) => {
          return query.queryKey.some(key => 
            typeof key === 'string' && key.includes('locale-dependent')
          ) || query.queryKey.includes(previousLocale)
        }
      })
      
      console.log(`✅ 語言切換完成: ${previousLocale} → ${locale}`)
      
    } catch (error) {
      console.error('❌ 語言切換失敗:', error)
      set({ isLoading: false })
      throw error
    }
  },
  
  // 按需載入翻譯命名空間
  loadNamespace: async (namespace) => {
    const { loadedNamespaces } = get()
    
    if (!loadedNamespaces.has(namespace)) {
      try {
        console.log(`📚 載入翻譯命名空間: ${namespace}`)
        await i18n.loadNamespaces(namespace)
        
        const updated = new Set([...loadedNamespaces, namespace])
        set({ loadedNamespaces: updated })
        
        stateCoordinator.publish('namespace-loaded', { namespace }, 'i18n')
        console.log(`✅ 命名空間載入完成: ${namespace}`)
        
      } catch (error) {
        console.error(`❌ 載入翻譯命名空間失敗: ${namespace}`, error)
        throw error
      }
    }
  },
  
  // 貨幣設定
  setCurrency: (currency) => {
    const previousCurrency = get().currency
    set({ currency })
    localStorage.setItem('currency-preference', currency)
    
    stateCoordinator.publish('currency-changed', { 
      currency, 
      previousCurrency 
    }, 'i18n')
    
    console.log(`💰 貨幣已切換: ${previousCurrency} → ${currency}`)
  },
  
  // 區域設定 (同時更新語言和貨幣)
  setRegion: async (region) => {
    const mapping = get().regionMapping[region]
    if (!mapping) {
      console.warn(`⚠️ 未知區域代碼: ${region}`)
      return
    }
    
    const previousRegion = get().region
    console.log(`🗺️ 切換區域: ${previousRegion} → ${region}`)
    
    try {
      // 同時更新語言和貨幣
      await get().setLocale(mapping.locale)
      get().setCurrency(mapping.currency)
      
      set({ region })
      localStorage.setItem('region-preference', region)
      
      stateCoordinator.publish('region-changed', { 
        region, 
        previousRegion, 
        locale: mapping.locale, 
        currency: mapping.currency 
      }, 'i18n')
      
      console.log(`✅ 區域切換完成: ${region}`)
      
    } catch (error) {
      console.error('❌ 區域切換失敗:', error)
      throw error
    }
  },
  
  // 初始化國際化系統
  initI18nSystem: async () => {
    console.log('🌐 初始化國際化系統...')
    
    try {
      // 檢查保存的偏好設定
      const savedLocale = localStorage.getItem('locale-preference')
      const savedCurrency = localStorage.getItem('currency-preference') 
      const savedRegion = localStorage.getItem('region-preference')
      
      if (savedLocale && savedCurrency && savedRegion) {
        // 使用保存的設定
        await get().setLocale(savedLocale)
        get().setCurrency(savedCurrency)
        set({ region: savedRegion })
        
      } else {
        // 使用地理檢測 (Cloudflare)
        const detectedRegion = await detectUserRegion() // 實現地理檢測
        await get().setRegion(detectedRegion)
      }
      
      // 預載入常用命名空間
      const commonNamespaces = ['common', 'products', 'cart', 'auth', 'errors']
      await Promise.all(
        commonNamespaces.map(ns => get().loadNamespace(ns))
      )
      
      console.log('✅ 國際化系統初始化完成')
      
    } catch (error) {
      console.error('❌ 國際化系統初始化失敗:', error)
      // 使用預設設定作為備用
      await get().setLocale('zh-TW')
      get().setCurrency('TWD')
      set({ region: 'TW' })
    }
  }
}))

// 地理檢測函數 (使用 Cloudflare)
async function detectUserRegion() {
  try {
    const response = await fetch('/api/detect-region')
    const data = await response.json()
    return data.region || 'TW'
  } catch (error) {
    console.warn('⚠️ 地理檢測失敗，使用預設區域')
    return 'TW'
  }
}

// 註冊到協調器
stateCoordinator.register('i18n', useI18nStore, {
  syncOnInit: true,
  dependencies: ['theme', 'auth'],
  integrations: ['cart', 'products']
})
```

### 3. 購物車狀態管理
```js
// stores/cart.js
export const useCartStore = create((set, get) => ({
  items: [],
  isOpen: false,
  
  addItem: (product, quantity = 1) => {
    const { items } = get()
    const existingItem = items.find(item => item.id === product.id)
    
    if (existingItem) {
      set({
        items: items.map(item =>
          item.id === product.id 
            ? { ...item, quantity: item.quantity + quantity }
            : item
        )
      })
    } else {
      set({ items: [...items, { ...product, quantity }] })
    }
  },
  
  removeItem: (productId) => {
    set({ items: get().items.filter(item => item.id !== productId) })
  },
  
  updateQuantity: (productId, quantity) => {
    if (quantity <= 0) {
      get().removeItem(productId)
      return
    }
    
    set({
      items: get().items.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    })
  },
  
  clearCart: () => set({ items: [] }),
  
  toggleCart: () => set({ isOpen: !get().isOpen }),
  
  // 計算屬性
  getTotalItems: () => get().items.reduce((sum, item) => sum + item.quantity, 0),
  getTotalPrice: () => get().items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
}))
```

### 4. 用戶狀態管理
```js
// stores/auth.js
export const useAuthStore = create((set, get) => ({
  user: null,
  isAuthenticated: false,
  isLoading: false,
  
  login: async (credentials) => {
    set({ isLoading: true })
    try {
      const user = await authAPI.login(credentials)
      set({ user, isAuthenticated: true, isLoading: false })
      localStorage.setItem('auth-token', user.token)
    } catch (error) {
      set({ isLoading: false })
      throw error
    }
  },
  
  logout: () => {
    set({ user: null, isAuthenticated: false })
    localStorage.removeItem('auth-token')
  },
  
  initAuth: async () => {
    const token = localStorage.getItem('auth-token')
    if (token) {
      try {
        const user = await authAPI.verifyToken(token)
        set({ user, isAuthenticated: true })
      } catch {
        localStorage.removeItem('auth-token')
      }
    }
  }
}))
```

### 5. 節慶管理狀態
```js
// stores/festival.js - 節慶活動狀態管理
export const useFestivalStore = create((set, get) => ({
  // 基本狀態
  activeFestivals: [],
  currentTheme: null,
  priceCache: new Map(),
  banners: {},
  
  // 動畫狀態
  currentAnimation: null,
  backgroundConfig: null,
  
  // 載入狀態
  isLoading: false,
  lastUpdated: null,
  
  // 載入活躍節慶
  loadActiveFestivals: async () => {
    set({ isLoading: true })
    try {
      const festivals = await festivalAPI.getActiveFestivals()
      set({ 
        activeFestivals: festivals,
        lastUpdated: Date.now(),
        isLoading: false
      })
      
      // 通知其他系統節慶資料已更新
      stateCoordinator.publish('festivals-loaded', { count: festivals.length }, 'festival')
      
    } catch (error) {
      set({ isLoading: false })
      console.error('載入節慶活動失敗:', error)
      throw error
    }
  },
  
  // 套用節慶主題
  applyFestivalTheme: async (festivalId) => {
    try {
      const themeConfig = await festivalAPI.getFestivalTheme(festivalId, new Date())
      
      // 更新 CSS 變數
      Object.entries(themeConfig.colors).forEach(([key, value]) => {
        document.documentElement.style.setProperty(`--festival-${key}`, value)
      })
      
      set({ currentTheme: themeConfig })
      stateCoordinator.publish('festival-theme-applied', { festivalId, themeConfig }, 'festival')
      
      console.log(`🎪 節慶主題已套用: ${festivalId}`)
      
    } catch (error) {
      console.error('套用節慶主題失敗:', error)
      throw error
    }
  },
  
  // 重置主題
  resetTheme: () => {
    // 清除節慶 CSS 變數
    const festivalVars = Array.from(document.documentElement.style)
      .filter(prop => prop.startsWith('--festival-'))
    
    festivalVars.forEach(prop => {
      document.documentElement.style.removeProperty(prop)
    })
    
    set({ currentTheme: null, backgroundConfig: null })
    stateCoordinator.publish('festival-theme-reset', {}, 'festival')
  },
  
  // 計算節慶價格
  calculatePrice: async (productId, quantity) => {
    const cacheKey = `${productId}-${quantity}`
    
    // 檢查快取
    if (get().priceCache.has(cacheKey)) {
      return get().priceCache.get(cacheKey)
    }
    
    try {
      const { user } = useAuthStore.getState()
      const priceBreakdown = await festivalAPI.calculatePrice({
        productId,
        quantity,
        userId: user?.id
      })
      
      // 更新快取
      const updatedCache = new Map(get().priceCache)
      updatedCache.set(cacheKey, priceBreakdown)
      set({ priceCache: updatedCache })
      
      return priceBreakdown
      
    } catch (error) {
      console.error('計算節慶價格失敗:', error)
      throw error
    }
  },
  
  // 清除價格快取
  clearPriceCache: () => {
    set({ priceCache: new Map() })
  },
  
  // 播放節慶動畫
  playAnimation: (type, config) => {
    if (window.animationManager) {
      window.animationManager.playFestivalAnimation(type, config)
      set({ currentAnimation: type, backgroundConfig: config })
      
      console.log(`🎭 播放節慶動畫: ${type}`)
    }
  },
  
  // 停止動畫
  stopAnimation: () => {
    if (window.animationManager) {
      window.animationManager.stopAllAnimations()
      set({ currentAnimation: null, backgroundConfig: null })
    }
  },
  
  // 載入橫幅
  loadBanners: async (position) => {
    try {
      const banners = await festivalAPI.getBanners(position)
      set(state => ({
        banners: {
          ...state.banners,
          [position]: banners
        }
      }))
      
      stateCoordinator.publish('banners-loaded', { position, count: banners.length }, 'festival')
      
    } catch (error) {
      console.error(`載入橫幅失敗 (${position}):`, error)
    }
  },
  
  // 獲取當前適用的折扣
  getApplicableDiscounts: async (productId) => {
    const { activeFestivals } = get()
    const applicableDiscounts = []
    
    for (const festival of activeFestivals) {
      try {
        const validation = await festivalAPI.validateDiscountConditions({
          productId,
          festivalId: festival.id,
          userId: useAuthStore.getState().user?.id
        })
        
        if (validation.isValid) {
          applicableDiscounts.push({
            festivalId: festival.id,
            festivalName: festival.name,
            discountRules: festival.discountRules
          })
        }
      } catch (error) {
        console.error(`驗證折扣條件失敗 (${festival.name}):`, error)
      }
    }
    
    return applicableDiscounts
  }
}))

// 註冊到協調器
stateCoordinator.register('festival', useFestivalStore, {
  syncOnInit: true,
  dependencies: ['auth'],
  integrations: ['theme', 'animation', 'cart']
})
```

## React Query配置

### 1. Query Client設定
```js
// config/query-client.js
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5分鐘
      cacheTime: 10 * 60 * 1000, // 10分鐘
      retry: (failureCount, error) => {
        if (error.status === 404) return false
        return failureCount < 3
      }
    },
    mutations: {
      retry: false
    }
  }
})
```

### 2. API Hook範例
```js
// hooks/useProducts.js
export const useProducts = (params) => {
  const { locale, currency } = useI18nStore()
  
  return useQuery({
    queryKey: ['products', params, locale, currency],
    queryFn: () => productAPI.getProducts({ 
      ...params, 
      locale, 
      currency 
    }),
    enabled: !!locale && !!currency
  })
}

export const useProduct = (id) => {
  const { locale, currency } = useI18nStore()
  
  return useQuery({
    queryKey: ['product', id, locale, currency],
    queryFn: () => productAPI.getProduct(id, { locale, currency }),
    enabled: !!id
  })
}
```

### 3. Mutation Hook範例
```js
// hooks/useCart.js
export const useAddToCart = () => {
  const queryClient = useQueryClient()
  const addItem = useCartStore(state => state.addItem)
  
  return useMutation({
    mutationFn: ({ productId, quantity }) => 
      cartAPI.addToCart(productId, quantity),
    onSuccess: (data, variables) => {
      // 樂觀更新本地狀態
      addItem(variables.product, variables.quantity)
      
      // 使相關查詢失效
      queryClient.invalidateQueries(['cart'])
      queryClient.invalidateQueries(['user-profile'])
    },
    onError: (error, variables) => {
      // 錯誤處理和回滾
      console.error('添加到購物車失敗:', error)
    }
  })
}
```

## PWA離線狀態管理

### 1. 網絡狀態檢測
```js
// stores/network.js
export const useNetworkStore = create((set) => ({
  isOnline: navigator.onLine,
  isOfflineMode: false,
  
  setOnline: (status) => set({ isOnline: status }),
  
  toggleOfflineMode: () => set(state => ({ 
    isOfflineMode: !state.isOfflineMode 
  })),
  
  init: () => {
    window.addEventListener('online', () => set({ isOnline: true }))
    window.addEventListener('offline', () => set({ isOnline: false }))
  }
}))
```

### 2. 離線購物車同步
```js
// stores/offline-cart.js
export const useOfflineCartStore = create((set, get) => ({
  pendingActions: [],
  
  addPendingAction: (action) => {
    const { pendingActions } = get()
    const updated = [...pendingActions, { 
      ...action, 
      timestamp: Date.now(),
      id: crypto.randomUUID()
    }]
    set({ pendingActions: updated })
    localStorage.setItem('pending-cart-actions', JSON.stringify(updated))
  },
  
  syncPendingActions: async () => {
    const { pendingActions } = get()
    const synced = []
    
    for (const action of pendingActions) {
      try {
        await cartAPI.syncAction(action)
        synced.push(action.id)
      } catch (error) {
        console.error('同步失敗:', error)
      }
    }
    
    const remaining = pendingActions.filter(
      action => !synced.includes(action.id)
    )
    set({ pendingActions: remaining })
    localStorage.setItem('pending-cart-actions', JSON.stringify(remaining))
  }
}))
```

## 狀態持久化

### 1. 自動持久化配置
```js
// utils/persistence.js
import { subscribeWithSelector } from 'zustand/middleware'

export const createPersistedStore = (config, options = {}) => {
  const { key, storage = localStorage } = options
  
  return create(
    subscribeWithSelector((set, get, api) => {
      const store = config(set, get, api)
      
      // 載入持久化數據
      try {
        const saved = storage.getItem(key)
        if (saved) {
          const parsed = JSON.parse(saved)
          set(parsed)
        }
      } catch (error) {
        console.error('載入持久化狀態失敗:', error)
      }
      
      // 訂閱狀態變化並自動保存
      api.subscribe((state) => {
        try {
          storage.setItem(key, JSON.stringify(state))
        } catch (error) {
          console.error('保存狀態失敗:', error)
        }
      })
      
      return store
    })
  )
}
```

## DevTools整合

### 1. 開發環境偵錯
```js
// stores/index.js
const isDev = process.env.NODE_ENV === 'development'

export const useCartStore = create(
  isDev 
    ? devtools(cartStore, { name: 'cart-store' })
    : cartStore
)
```

## 性能優化

### 1. 選擇器優化
```js
// 避免不必要的重渲染
const cartCount = useCartStore(state => state.getTotalItems())

// 使用淺比較選擇器
const cartItems = useCartStore(
  state => state.items,
  shallow
)
```

### 2. React Query優化
```js
// 預載入關鍵數據
export const prefetchProducts = () => {
  queryClient.prefetchQuery({
    queryKey: ['products', { featured: true }],
    queryFn: () => productAPI.getFeaturedProducts()
  })
}
```

## 新增整合系統

### 動畫狀態整合
```javascript
// stores/animation.js - 與 AnimationManager 協作
export const useAnimationStore = create((set, get) => ({
  // 動畫狀態
  loadedAnimations: new Set(),
  userInteracted: false,
  animationsPaused: false,
  performanceMode: 'normal', // normal, reduced, disabled
  
  // 與 AnimationManager 同步
  syncWithAnimationManager: () => {
    if (window.animationManager) {
      const status = window.animationManager.getLoadingStatus()
      set({
        loadedAnimations: new Set(status.loadedAnimations),
        userInteracted: status.userInteracted
      })
    }
  },
  
  // 動畫載入通知
  setAnimationLoaded: (name) => {
    const { loadedAnimations } = get()
    const updated = new Set([...loadedAnimations, name])
    set({ loadedAnimations: updated })
    
    stateCoordinator.publish('animation-loaded', { name, total: updated.size }, 'animation')
  },
  
  // 性能模式調整
  setPerformanceMode: (mode) => {
    set({ performanceMode: mode })
    
    if (window.animationManager) {
      window.animationManager.setPerformanceMode?.(mode)
    }
    
    stateCoordinator.publish('performance-mode-changed', mode, 'animation')
    console.log(`🎭 動畫性能模式: ${mode}`)
  },
  
  // 監聽動畫事件
  initAnimationListeners: () => {
    // 監聽 AnimationManager 事件
    window.addEventListener('animationManagerInteracted', () => {
      set({ userInteracted: true })
    })
    
    // 監聽減少動畫偏好
    window.matchMedia('(prefers-reduced-motion: reduce)')
      .addEventListener('change', (e) => {
        if (e.matches) {
          get().setPerformanceMode('reduced')
        }
      })
  }
}))

stateCoordinator.register('animation', useAnimationStore, {
  syncOnInit: true,
  integrations: ['theme', 'pwa']
})
```

### PWA 離線狀態整合
```javascript
// stores/pwa.js - 完整 PWA 功能整合
export const usePWAStore = create((set, get) => ({
  // 網路狀態
  isOnline: navigator.onLine,
  connectionType: 'unknown',
  isLowDataMode: false,
  
  // 離線功能
  offlineMode: false,
  syncQueue: [],
  lastSync: null,
  
  // Service Worker 狀態
  swStatus: 'unknown',
  updateAvailable: false,
  
  // 快取狀態
  cachedPages: new Set(),
  cacheSize: 0,
  
  // 網路狀態更新
  updateConnectionStatus: (status) => {
    const previousStatus = get().isOnline
    set({ isOnline: status })
    
    console.log(`📶 網路狀態: ${previousStatus ? '線上' : '離線'} → ${status ? '線上' : '離線'}`)
    
    if (status && !previousStatus) {
      // 重新連線，開始同步
      get().syncOfflineActions()
      stateCoordinator.publish('connection-restored', {}, 'pwa')
    } else if (!status && previousStatus) {
      // 斷線，啟動離線模式
      stateCoordinator.publish('offline-mode-activated', {}, 'pwa')
    }
  },
  
  // 離線動作同步
  syncOfflineActions: async () => {
    const { syncQueue } = get()
    if (syncQueue.length === 0) return
    
    console.log(`🔄 同步離線動作: ${syncQueue.length} 項`)
    
    const successful = []
    const failed = []
    
    for (const action of syncQueue) {
      try {
        await syncOfflineAction(action)
        successful.push(action.id)
      } catch (error) {
        failed.push({ action, error })
      }
    }
    
    const remaining = syncQueue.filter(
      action => !successful.includes(action.id)
    )
    
    set({ 
      syncQueue: remaining,
      lastSync: Date.now()
    })
    
    stateCoordinator.publish('offline-sync-completed', {
      successful: successful.length,
      failed: failed.length,
      remaining: remaining.length
    }, 'pwa')
    
    console.log(`✅ 離線同步完成: ${successful.length} 成功, ${failed.length} 失敗`)
  },
  
  // Service Worker 初始化
  initServiceWorker: async () => {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js')
        
        registration.addEventListener('updatefound', () => {
          set({ swStatus: 'installing' })
          console.log('🔄 Service Worker 更新中...')
        })
        
        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data.type === 'UPDATE_AVAILABLE') {
            set({ updateAvailable: true })
            stateCoordinator.publish('app-update-available', {}, 'pwa')
            console.log('🆕 應用程式更新可用')
          }
        })
        
        set({ swStatus: 'activated' })
        console.log('✅ Service Worker 啟動完成')
        
      } catch (error) {
        console.error('❌ Service Worker 註冊失敗:', error)
      }
    }
  },
  
  // 低流量模式
  setLowDataMode: (enabled) => {
    set({ isLowDataMode: enabled })
    
    stateCoordinator.publish('low-data-mode-changed', { enabled }, 'pwa')
    
    // 調整其他系統
    if (enabled) {
      useAnimationStore.getState().setPerformanceMode('reduced')
    }
    
    console.log(`📱 低流量模式: ${enabled ? '啟用' : '停用'}`)
  }
}))

// 離線動作同步函數
async function syncOfflineAction(action) {
  // 根據動作類型進行同步
  switch (action.type) {
    case 'cart-add':
      return await cartAPI.addToCart(action.productId, action.quantity)
    case 'cart-remove':
      return await cartAPI.removeFromCart(action.productId)
    case 'wishlist-add':
      return await wishlistAPI.add(action.productId)
    default:
      throw new Error(`未知離線動作類型: ${action.type}`)
  }
}

stateCoordinator.register('pwa', usePWAStore, {
  syncOnInit: true,
  integrations: ['animation', 'cart', 'theme']
})
```

### 錯誤處理系統整合
```javascript
// 引用統一錯誤處理系統
import { useErrorHandler } from '@/stores/error-handler'

// 在狀態協調器中註冊錯誤處理
stateCoordinator.register('error', useErrorHandler)

// 注意：統一錯誤處理實現詳見 15-統一錯誤處理系統.md
```

### 統一初始化系統
```javascript
// stores/init.js - 完整系統初始化
export const initializeStateManagement = async () => {
  console.log('🚀 啟動狀態管理系統初始化...')
  
  try {
    // 初始化協調器
    stateCoordinator.publish('init-started', { timestamp: Date.now() }, 'system')
    
    // 按依賴順序初始化各系統
    const initSequence = [
      // 第一階段：基礎系統
      {
        name: '基礎系統',
        tasks: async () => {
          await useThemeStore.getState().initThemeSystem()
          await usePWAStore.getState().initServiceWorker()
          useErrorHandler.getState() // 確保錯誤處理已啟動
        }
      },
      
      // 第二階段：內容與動畫系統
      {
        name: '內容與動畫系統', 
        tasks: async () => {
          await useI18nStore.getState().initI18nSystem()
          useAnimationStore.getState().initAnimationListeners()
          
          // 等待動畫管理器初始化
          if (window.animationManager) {
            useAnimationStore.getState().syncWithAnimationManager()
          }
        }
      },
      
      // 第三階段：用戶相關系統
      {
        name: '用戶相關系統',
        tasks: async () => {
          await useAuthStore.getState().initAuth()
          // 初始化其他用戶相關功能
        }
      },
      
      // 第四階段：監控與優化
      {
        name: '監控與優化',
        tasks: async () => {
          // 設定網路監聽
          window.addEventListener('online', () => {
            usePWAStore.getState().updateConnectionStatus(true)
          })
          window.addEventListener('offline', () => {
            usePWAStore.getState().updateConnectionStatus(false)
          })
          
          // 性能監控
          if (process.env.NODE_ENV === 'development') {
            setInterval(() => {
              console.log('📊 狀態管理性能:', stateCoordinator.performanceMetrics)
            }, 30000)
          }
        }
      }
    ]
    
    // 依序執行初始化階段
    for (const [index, { name, tasks }] of initSequence.entries()) {
      console.log(`📝 執行第 ${index + 1} 階段: ${name}`)
      await tasks()
    }
    
    // 設定跨系統事件監聽
    setupCrossSystemIntegration()
    
    // 執行首次全系統同步
    await stateCoordinator.syncAll()
    
    console.log('🎉 狀態管理系統初始化完成！')
    stateCoordinator.publish('init-completed', { 
      timestamp: Date.now(),
      systems: stateCoordinator.subscribers.size 
    }, 'system')
    
  } catch (error) {
    console.error('💥 狀態管理系統初始化失敗:', error)
    useErrorHandler.getState().handleError(error, { type: 'init-failure' })
    throw error
  }
}

// 跨系統整合邏輯
function setupCrossSystemIntegration() {
  console.log('🔗 設定跨系統整合...')
  
  // 主題變更整合
  stateCoordinator.subscribe('theme-changed', (event) => {
    const { theme } = event.detail.data
    console.log(`🎨 主題變更通知: ${theme}`)
    // 可以在這裡添加其他系統的主題響應邏輯
  })
  
  // 語言變更整合
  stateCoordinator.subscribe('locale-changed', (event) => {
    const { locale, previousLocale } = event.detail.data
    console.log(`🌐 語言變更通知: ${previousLocale} → ${locale}`)
    // 更新頁面 meta 資訊
    document.documentElement.lang = locale
  })
  
  // 離線模式整合
  stateCoordinator.subscribe('offline-mode-activated', () => {
    console.log('📱 進入離線模式')
    // 調整動畫性能以節省資源
    useAnimationStore.getState().setPerformanceMode('reduced')
  })
  
  // 連線恢復整合
  stateCoordinator.subscribe('connection-restored', () => {
    console.log('🌐 網路連線已恢復')
    // 恢復正常動畫性能
    useAnimationStore.getState().setPerformanceMode('normal')
  })
  
  // 嚴重錯誤整合
  stateCoordinator.subscribe('critical-error', (event) => {
    const error = event.detail.data
    console.log('🚨 嚴重錯誤處理中:', error)
    // 暫停所有非必要動畫
    useAnimationStore.getState().setPerformanceMode('disabled')
  })
}
```

## 使用指南

### 在 React App 中初始化
```javascript
// App.jsx
import { initializeStateManagement } from '@/stores/init'
import { useEffect } from 'react'

function App() {
  useEffect(() => {
    // 啟動狀態管理系統
    initializeStateManagement().catch(error => {
      console.error('狀態管理初始化失敗:', error)
    })
  }, [])
  
  return (
    // 應用程式內容
    <div>Your App</div>
  )
}
```

### 在組件中使用整合狀態
```jsx
// 主題與國際化整合使用
const ThemeLanguageToggle = () => {
  const { theme, setTheme } = useThemeStore()
  const { locale, setLocale } = useI18nStore()
  const { loadedAnimations } = useAnimationStore()
  
  return (
    <div>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        切換主題: {theme}
      </button>
      <button onClick={() => setLocale(locale === 'zh-TW' ? 'en-US' : 'zh-TW')}>
        切換語言: {locale}
      </button>
      <p>已載入動畫: {loadedAnimations.size}</p>
    </div>
  )
}
```