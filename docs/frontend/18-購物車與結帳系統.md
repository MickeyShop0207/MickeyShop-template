# 購物車與結帳系統

## 系統概覽

完整的電商購物流程實現，包含智能庫存管理、多設備同步、靈活的結帳流程和訂單狀態追蹤。

## 購物車系統

### 庫存管理機制

#### 購物車預留庫存
```js
// 加入購物車時預留庫存（整合節慶管理）
const addToCart = async (productId, quantity, variants = {}) => {
  try {
    // 1. 檢查庫存（包含節慶預留庫存）
    const stock = await api.checkStock(productId, variants, {
      includeFestivalStock: true,
      activeFestivalIds: useFestivalStore.getState().activeFestivals.map(f => f.id)
    })
    
    if (stock.available < quantity) {
      throw new Error('庫存不足')
    }
    
    // 2. 計算節慶價格
    const { user } = useAuthStore.getState()
    const priceBreakdown = await api.calculateFestivalPrice({
      productId,
      quantity,
      variants,
      userId: user?.id
    })
    
    // 3. 預留庫存 (從商品庫存扣除，加入購物車庫存)
    await api.reserveStock(productId, quantity, variants, {
      festivalIds: priceBreakdown.appliedDiscounts.map(d => d.festivalId)
    })
    
    // 4. 處理贈品（檢查節慶贈品規則）
    if (stock.gifts || priceBreakdown.festivalGifts) {
      const allGifts = [...(stock.gifts || []), ...(priceBreakdown.festivalGifts || [])]
      await Promise.all(
        allGifts.map(gift => 
          api.reserveStock(gift.productId, gift.quantity, gift.variants)
        )
      )
    }
    
    // 5. 加入購物車
    const cartItem = {
      productId,
      quantity,
      variants,
      reservedAt: new Date(),
      expiresAt: new Date(Date.now() + getCartExpiryHours() * 60 * 60 * 1000),
      
      // 節慶相關資訊
      originalPrice: priceBreakdown.originalPrice,
      finalPrice: priceBreakdown.finalPrice,
      appliedDiscounts: priceBreakdown.appliedDiscounts,
      festivalGifts: priceBreakdown.festivalGifts || [],
      savings: priceBreakdown.savings
    }
    
    await api.addToCart(cartItem)
    
    // 6. 觸發節慶相關動畫效果
    if (priceBreakdown.appliedDiscounts.length > 0) {
      triggerFestivalCartAnimation(priceBreakdown.appliedDiscounts[0].festivalType)
    }
    
  } catch (error) {
    // 預留失敗時的錯誤處理
    handleStockReservationError(error)
  }
}
```

#### 自動庫存回收
```js
// 購物車過期檢查與庫存回收
const checkExpiredCartItems = async () => {
  const expiredItems = await api.getExpiredCartItems()
  
  for (const item of expiredItems) {
    // 1. 釋放預留庫存
    await api.releaseReservedStock(
      item.productId, 
      item.quantity, 
      item.variants
    )
    
    // 2. 釋放贈品庫存
    if (item.gifts) {
      await Promise.all(
        item.gifts.map(gift => 
          api.releaseReservedStock(gift.productId, gift.quantity, gift.variants)
        )
      )
    }
  }
}

// 定時任務 - 每小時執行一次
setInterval(checkExpiredCartItems, 60 * 60 * 1000)
```

#### 管理員可配置過期時間
```js
// 後台設定購物車過期時間 (以小時為單位)
const getCartExpiryHours = () => {
  return config.cartExpiryHours || 72 // 預設 3 天
}

// 後台管理介面
const CartSettings = () => {
  const [expiryHours, setExpiryHours] = useState(72)
  
  const updateSetting = async () => {
    await api.updateConfig('cartExpiryHours', expiryHours)
  }
  
  return (
    <Form.Item label="購物車過期時間 (小時)">
      <InputNumber
        min={1}
        max={168} // 最多 7 天
        value={expiryHours}
        onChange={setExpiryHours}
      />
      <Button onClick={updateSetting}>更新設定</Button>
    </Form.Item>
  )
}
```

### 購物車狀態檢查

#### 進入購物車頁面時的檢查
```js
// 購物車頁面載入時執行
const validateCartItems = async () => {
  const cartItems = await api.getCartItems()
  const validatedItems = []
  
  for (const item of cartItems) {
    // 1. 檢查商品是否下架
    const product = await api.getProduct(item.productId)
    if (!product.active) {
      item.status = 'discontinued' // 商品反白顯示
      item.disabled = true
      validatedItems.push(item)
      continue
    }
    
    // 2. 檢查庫存
    const stock = await api.checkStock(item.productId, item.variants)
    if (stock.available === 0) {
      item.status = 'out_of_stock' // 無法結帳
      item.disabled = true
    } else if (stock.available < item.quantity) {
      item.status = 'insufficient_stock' // 數量不足
      item.maxQuantity = stock.available
    } else {
      item.status = 'available'
      item.disabled = false
    }
    
    validatedItems.push(item)
  }
  
  return validatedItems
}
```

### 購物車操作

#### 數量調整 (加減按鈕)
```jsx
const QuantityAdjuster = ({ item, onUpdate }) => {
  const [quantity, setQuantity] = useState(item.quantity)
  const [loading, setLoading] = useState(false)
  
  const updateQuantity = async (newQuantity) => {
    if (newQuantity < 1 || newQuantity === quantity) return
    
    setLoading(true)
    try {
      // 檢查庫存
      const stock = await api.checkStock(item.productId, item.variants)
      if (newQuantity > stock.available) {
        message.warning('庫存不足')
        return
      }
      
      // 更新庫存預留
      const difference = newQuantity - quantity
      if (difference > 0) {
        await api.reserveStock(item.productId, difference, item.variants)
      } else {
        await api.releaseReservedStock(item.productId, Math.abs(difference), item.variants)
      }
      
      // 更新購物車
      await api.updateCartQuantity(item.id, newQuantity)
      setQuantity(newQuantity)
      onUpdate()
      
    } catch (error) {
      message.error('更新失敗')
    } finally {
      setLoading(false)
    }
  }
  
  return (
    <div className="quantity-adjuster">
      <Button 
        size="small" 
        disabled={quantity <= 1 || loading}
        onClick={() => updateQuantity(quantity - 1)}
      >
        -
      </Button>
      <span className="quantity-display">{quantity}</span>
      <Button 
        size="small"
        disabled={loading || (item.maxQuantity && quantity >= item.maxQuantity)}
        onClick={() => updateQuantity(quantity + 1)}
      >
        +
      </Button>
    </div>
  )
}
```

#### 商品移除 (確認對話框)
```jsx
const RemoveItemButton = ({ item, onRemove }) => {
  const showConfirm = () => {
    Modal.confirm({
      title: '確認移除商品',
      content: `確定要從購物車中移除「${item.productName}」嗎？`,
      okText: '確定移除',
      okType: 'danger',
      cancelText: '取消',
      onOk: async () => {
        try {
          // 釋放預留庫存
          await api.releaseReservedStock(
            item.productId, 
            item.quantity, 
            item.variants
          )
          
          // 從購物車移除
          await api.removeFromCart(item.id)
          onRemove(item.id)
          message.success('已移除商品')
          
        } catch (error) {
          message.error('移除失敗')
        }
      }
    })
  }
  
  return (
    <Button 
      type="text" 
      danger 
      icon={<DeleteOutlined />}
      onClick={showConfirm}
    >
      移除
    </Button>
  )
}
```

### 批量操作功能

#### 選擇性結帳系統
```jsx
const CartPage = () => {
  const [cartItems, setCartItems] = useState([])
  const [selectedItems, setSelectedItems] = useState([])
  const [selectAll, setSelectAll] = useState(false)
  
  // 全選/取消全選
  const handleSelectAll = (checked) => {
    setSelectAll(checked)
    if (checked) {
      const availableItems = cartItems.filter(item => !item.disabled)
      setSelectedItems(availableItems.map(item => item.id))
    } else {
      setSelectedItems([])
    }
  }
  
  // 個別選擇
  const handleSelectItem = (itemId, checked) => {
    if (checked) {
      setSelectedItems([...selectedItems, itemId])
    } else {
      setSelectedItems(selectedItems.filter(id => id !== itemId))
    }
  }
  
  // 批量刪除
  const handleBatchDelete = () => {
    if (selectedItems.length === 0) {
      message.warning('請先選擇要刪除的商品')
      return
    }
    
    Modal.confirm({
      title: '確認批量刪除',
      content: `確定要刪除 ${selectedItems.length} 個商品嗎？`,
      okText: '確定刪除',
      okType: 'danger',
      onOk: async () => {
        try {
          await api.batchDeleteCartItems(selectedItems)
          // 更新購物車列表
          loadCartItems()
          setSelectedItems([])
          message.success('批量刪除成功')
        } catch (error) {
          message.error('批量刪除失敗')
        }
      }
    })
  }
  
  // 移至願望清單
  const moveToWishlist = async () => {
    if (selectedItems.length === 0) {
      message.warning('請先選擇商品')
      return
    }
    
    try {
      await api.moveToWishlist(selectedItems)
      loadCartItems()
      setSelectedItems([])
      message.success('已移至願望清單')
    } catch (error) {
      message.error('移動失敗')
    }
  }
  
  // 選擇性結帳
  const proceedToCheckout = () => {
    if (selectedItems.length === 0) {
      message.warning('請選擇要結帳的商品')
      return
    }
    
    // 將選中的商品帶入結帳流程
    navigate('/checkout', { 
      state: { selectedItems }
    })
  }
  
  return (
    <div className="cart-page">
      <div className="cart-header">
        <Checkbox 
          checked={selectAll}
          onChange={(e) => handleSelectAll(e.target.checked)}
        >
          全選
        </Checkbox>
        
        <Space>
          <Button onClick={handleBatchDelete} disabled={selectedItems.length === 0}>
            批量刪除
          </Button>
          <Button onClick={moveToWishlist} disabled={selectedItems.length === 0}>
            移至願望清單
          </Button>
        </Space>
      </div>
      
      <div className="cart-items">
        {cartItems.map(item => (
          <CartItemRow 
            key={item.id}
            item={item}
            selected={selectedItems.includes(item.id)}
            onSelect={(checked) => handleSelectItem(item.id, checked)}
          />
        ))}
      </div>
      
      <div className="cart-footer">
        <div className="selected-summary">
          已選擇 {selectedItems.length} 件商品
        </div>
        <Button 
          type="primary" 
          size="large"
          disabled={selectedItems.length === 0}
          onClick={proceedToCheckout}
        >
          結帳選中商品
        </Button>
      </div>
    </div>
  )
}
```

### 多設備同步

#### 購物車同步機制
```js
// WebSocket 即時同步
const CartSyncManager = {
  init() {
    this.ws = new WebSocket(`${config.wsUrl}/cart-sync`)
    this.ws.onmessage = this.handleSyncMessage.bind(this)
    this.ws.onopen = () => this.authenticateWS()
  },
  
  // WebSocket 認證
  authenticateWS() {
    const token = getAuthToken()
    this.ws.send(JSON.stringify({
      type: 'authenticate',
      token
    }))
  },
  
  // 處理同步消息
  handleSyncMessage(event) {
    const message = JSON.parse(event.data)
    
    switch (message.type) {
      case 'cart_updated':
        // 其他設備更新了購物車
        this.syncLocalCart(message.data)
        break
      case 'item_added':
        // 其他設備加入了商品
        this.addItemToLocal(message.data)
        break
      case 'item_removed':
        // 其他設備移除了商品
        this.removeItemFromLocal(message.data)
        break
    }
  },
  
  // 廣播購物車更新
  broadcastUpdate(type, data) {
    if (this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        type: 'broadcast',
        event: type,
        data
      }))
    }
  },
  
  // 同步本地購物車
  syncLocalCart(remoteCart) {
    const localCart = getLocalCart()
    
    // 合併邏輯：以最新時間戳為準
    const mergedCart = this.mergeCartItems(localCart, remoteCart)
    
    // 更新本地狀態
    updateCartStore(mergedCart)
    
    // 顯示同步通知
    notification.info({
      message: '購物車已同步',
      description: '已同步其他設備的購物車變更',
      duration: 3
    })
  }
}

// 購物車操作時觸發同步
const addToCartWithSync = async (product, quantity) => {
  // 本地更新
  await addToCart(product, quantity)
  
  // 廣播更新
  CartSyncManager.broadcastUpdate('item_added', {
    productId: product.id,
    quantity,
    timestamp: Date.now()
  })
}
```

## 結帳系統

### 收件資訊管理

#### 預設地址系統
```js
// 用戶地址管理
const AddressManager = {
  // 獲取用戶所有地址
  async getUserAddresses() {
    return await api.get('/user/addresses')
  },
  
  // 設置預設地址
  async setDefaultAddress(addressId) {
    await api.patch(`/user/addresses/${addressId}`, {
      isDefault: true
    })
  },
  
  // 新增地址
  async addAddress(addressData) {
    return await api.post('/user/addresses', {
      ...addressData,
      isDefault: addressData.setAsDefault || false
    })
  }
}

// 結帳頁面地址選擇
const CheckoutAddressForm = () => {
  const [addresses, setAddresses] = useState([])
  const [selectedAddress, setSelectedAddress] = useState(null)
  const [showAddForm, setShowAddForm] = useState(false)
  
  useEffect(() => {
    loadAddresses()
  }, [])
  
  const loadAddresses = async () => {
    const userAddresses = await AddressManager.getUserAddresses()
    setAddresses(userAddresses)
    
    // 自動選擇預設地址
    const defaultAddr = userAddresses.find(addr => addr.isDefault)
    if (defaultAddr) {
      setSelectedAddress(defaultAddr.id)
    }
  }
  
  return (
    <div className="checkout-address">
      <h3>收件資訊</h3>
      
      {addresses.length > 0 ? (
        <Radio.Group 
          value={selectedAddress}
          onChange={(e) => setSelectedAddress(e.target.value)}
        >
          {addresses.map(address => (
            <Radio key={address.id} value={address.id}>
              <AddressCard address={address} />
            </Radio>
          ))}
        </Radio.Group>
      ) : null}
      
      <Button 
        type="dashed" 
        block
        onClick={() => setShowAddForm(true)}
      >
        + 新增收件地址
      </Button>
      
      {showAddForm && (
        <AddressForm 
          onSubmit={(newAddress) => {
            setAddresses([...addresses, newAddress])
            setSelectedAddress(newAddress.id)
            setShowAddForm(false)
          }}
          onCancel={() => setShowAddForm(false)}
        />
      )}
    </div>
  )
}
```

#### 台灣地址驗證
```js
// 台灣地址驗證系統
const TaiwanAddressValidator = {
  // 縣市資料
  cities: [
    { code: 'TPE', name: '臺北市', zipRange: [100, 116] },
    { code: 'NTP', name: '新北市', zipRange: [200, 253] },
    { code: 'TYC', name: '桃園市', zipRange: [300, 338] },
    // ... 其他縣市
  ],
  
  // 驗證郵遞區號
  validateZipCode(city, district, zipCode) {
    const cityData = this.cities.find(c => c.name === city)
    if (!cityData) return false
    
    const [min, max] = cityData.zipRange
    const zip = parseInt(zipCode)
    return zip >= min && zip <= max
  },
  
  // 地址格式驗證
  validateAddress(address) {
    const errors = []
    
    // 必填檢查
    if (!address.city) errors.push('請選擇縣市')
    if (!address.district) errors.push('請選擇區域')
    if (!address.street) errors.push('請輸入街道地址')
    if (!address.zipCode) errors.push('請輸入郵遞區號')
    
    // 郵遞區號檢查
    if (address.city && address.district && address.zipCode) {
      if (!this.validateZipCode(address.city, address.district, address.zipCode)) {
        errors.push('郵遞區號與所選地區不符')
      }
    }
    
    // 手機號碼格式檢查
    if (address.phone && !/^09\d{8}$/.test(address.phone)) {
      errors.push('手機號碼格式錯誤')
    }
    
    return {
      isValid: errors.length === 0,
      errors
    }
  }
}

// 地址表單組件
const AddressForm = ({ onSubmit, onCancel, initialData = {} }) => {
  const [form] = Form.useForm()
  const [districts, setDistricts] = useState([])
  
  // 縣市改變時載入區域選項
  const handleCityChange = (city) => {
    const cityDistricts = getDistrictsByCity(city)
    setDistricts(cityDistricts)
    form.setFieldsValue({ district: '', zipCode: '' })
  }
  
  // 區域改變時自動填入郵遞區號
  const handleDistrictChange = (district, city) => {
    const zipCode = getZipCodeByDistrict(city, district)
    form.setFieldsValue({ zipCode })
  }
  
  const handleSubmit = async (values) => {
    // 地址驗證
    const validation = TaiwanAddressValidator.validateAddress(values)
    if (!validation.isValid) {
      validation.errors.forEach(error => message.error(error))
      return
    }
    
    try {
      const newAddress = await AddressManager.addAddress(values)
      onSubmit(newAddress)
      message.success('地址新增成功')
    } catch (error) {
      message.error('新增失敗')
    }
  }
  
  return (
    <Form form={form} onFinish={handleSubmit} initialValues={initialData}>
      <Form.Item name="name" label="收件人姓名" rules={[{ required: true }]}>
        <Input />
      </Form.Item>
      
      <Form.Item name="phone" label="聯絡電話" rules={[{ required: true }]}>
        <Input placeholder="0912345678" />
      </Form.Item>
      
      <Form.Item name="city" label="縣市" rules={[{ required: true }]}>
        <Select placeholder="請選擇縣市" onChange={handleCityChange}>
          {TaiwanAddressValidator.cities.map(city => (
            <Option key={city.code} value={city.name}>{city.name}</Option>
          ))}
        </Select>
      </Form.Item>
      
      <Form.Item name="district" label="區域" rules={[{ required: true }]}>
        <Select 
          placeholder="請選擇區域" 
          onChange={(district) => handleDistrictChange(district, form.getFieldValue('city'))}
        >
          {districts.map(district => (
            <Option key={district} value={district}>{district}</Option>
          ))}
        </Select>
      </Form.Item>
      
      <Form.Item name="zipCode" label="郵遞區號" rules={[{ required: true }]}>
        <Input />
      </Form.Item>
      
      <Form.Item name="street" label="街道地址" rules={[{ required: true }]}>
        <Input.TextArea rows={2} placeholder="請輸入詳細地址" />
      </Form.Item>
      
      <Form.Item name="setAsDefault" valuePropName="checked">
        <Checkbox>設為預設地址</Checkbox>
      </Form.Item>
      
      <Form.Item>
        <Space>
          <Button type="primary" htmlType="submit">確認新增</Button>
          <Button onClick={onCancel}>取消</Button>
        </Space>
      </Form.Item>
    </Form>
  )
}
```

### 付款方式整合

#### LINE Pay 整合
```js
// LINE Pay API 整合
const LinePayService = {
  // 建立付款請求
  async createPaymentRequest(order) {
    const paymentData = {
      amount: order.total,
      currency: 'TWD',
      orderId: order.id,
      packages: [{
        id: order.id,
        amount: order.total,
        products: order.items.map(item => ({
          name: item.productName,
          quantity: item.quantity,
          price: item.price
        }))
      }],
      redirectUrls: {
        confirmUrl: `${config.baseUrl}/payment/linepay/confirm`,
        cancelUrl: `${config.baseUrl}/cart`
      }
    }
    
    const response = await api.post('/payment/linepay/request', paymentData)
    return response.data
  },
  
  // 確認付款
  async confirmPayment(transactionId, orderId) {
    return await api.post('/payment/linepay/confirm', {
      transactionId,
      orderId
    })
  }
}
```

#### 綠界金流整合
```js
// 綠界金流 ECPay 整合
const ECPayService = {
  // 建立付款表單
  createPaymentForm(order) {
    const paymentData = {
      MerchantID: config.ecpay.merchantId,
      MerchantTradeNo: order.id,
      MerchantTradeDate: moment().format('YYYY/MM/DD HH:mm:ss'),
      PaymentType: 'aio',
      TotalAmount: order.total,
      TradeDesc: '美容保養品購買',
      ItemName: order.items.map(item => item.productName).join('#'),
      ReturnURL: `${config.baseUrl}/payment/ecpay/callback`,
      ChoosePayment: 'ALL',
      ClientBackURL: `${config.baseUrl}/order/success`,
      // 檢查碼計算
      CheckMacValue: this.generateCheckMacValue(paymentData)
    }
    
    return paymentData
  },
  
  // 產生檢查碼
  generateCheckMacValue(data) {
    // ECPay 檢查碼生成邏輯
    const sortedKeys = Object.keys(data).sort()
    const queryString = sortedKeys
      .map(key => `${key}=${data[key]}`)
      .join('&')
    
    return crypto
      .createHash('sha256')
      .update(`HashKey=${config.ecpay.hashKey}&${queryString}&HashIV=${config.ecpay.hashIV}`)
      .digest('hex')
      .toUpperCase()
  }
}
```

#### 付款方式選擇組件
```jsx
const PaymentMethodSelector = ({ onSelect, selectedMethod }) => {
  const paymentMethods = [
    {
      id: 'linepay',
      name: 'LINE Pay',
      icon: '/icons/linepay.png',
      description: '使用 LINE Pay 快速付款',
      enabled: config.payments.linepay.enabled
    },
    {
      id: 'ecpay',
      name: '綠界金流',
      icon: '/icons/ecpay.png',
      description: '支援信用卡、ATM、超商付款',
      enabled: config.payments.ecpay.enabled
    }
  ]
  
  return (
    <div className="payment-methods">
      <h3>選擇付款方式</h3>
      
      <Radio.Group 
        value={selectedMethod}
        onChange={(e) => onSelect(e.target.value)}
      >
        {paymentMethods
          .filter(method => method.enabled)
          .map(method => (
            <Radio key={method.id} value={method.id}>
              <div className="payment-method-option">
                <img src={method.icon} alt={method.name} className="payment-icon" />
                <div className="payment-info">
                  <div className="payment-name">{method.name}</div>
                  <div className="payment-description">{method.description}</div>
                </div>
              </div>
            </Radio>
          ))
        }
      </Radio.Group>
    </div>
  )
}
```

## 訂單狀態追蹤

### 訂單狀態定義
```js
const OrderStatus = {
  CREATED: { 
    code: 'created', 
    name: '訂單建立', 
    description: '訂單已成功建立',
    color: 'blue'
  },
  PAID: { 
    code: 'paid', 
    name: '付款確認', 
    description: '付款已確認，準備處理訂單',
    color: 'green'
  },
  PREPARING: { 
    code: 'preparing', 
    name: '備貨中', 
    description: '商品備貨準備中',
    color: 'orange'
  },
  SHIPPED: { 
    code: 'shipped', 
    name: '已出貨', 
    description: '商品已出貨，請留意配送通知',
    color: 'purple'
  },
  DELIVERED: { 
    code: 'delivered', 
    name: '已送達', 
    description: '商品已送達指定地址',
    color: 'cyan'
  },
  COMPLETED: { 
    code: 'completed', 
    name: '完成', 
    description: '訂單已完成',
    color: 'success'
  }
}
```

### Timeline 組件實現
```jsx
const OrderTimeline = ({ order }) => {
  const timelineItems = [
    {
      status: 'created',
      timestamp: order.createdAt,
      title: '訂單建立',
      description: `訂單編號：${order.orderNumber}`
    },
    {
      status: 'paid',
      timestamp: order.paidAt,
      title: '付款確認',
      description: order.paidAt ? `付款方式：${order.paymentMethod}` : null
    },
    {
      status: 'preparing',
      timestamp: order.preparingAt,
      title: '備貨中',
      description: order.preparingAt ? '商品準備中，預計 1-2 個工作天出貨' : null
    },
    {
      status: 'shipped',
      timestamp: order.shippedAt,
      title: '已出貨',
      description: order.trackingNumber ? `物流單號：${order.trackingNumber}` : null
    },
    {
      status: 'delivered',
      timestamp: order.deliveredAt,
      title: '已送達',
      description: order.deliveredAt ? '商品已成功送達' : null
    },
    {
      status: 'completed',
      timestamp: order.completedAt,
      title: '訂單完成',
      description: order.completedAt ? '感謝您的購買，歡迎再次光臨' : null
    }
  ]
  
  // 根據當前狀態確定顯示的項目
  const currentStatusIndex = timelineItems.findIndex(
    item => item.status === order.status
  )
  
  return (
    <div className="order-timeline">
      <h3>訂單狀態追蹤</h3>
      
      <Timeline>
        {timelineItems.map((item, index) => {
          const isCompleted = index <= currentStatusIndex
          const isCurrent = index === currentStatusIndex
          const isPending = index > currentStatusIndex
          
          let color = 'gray'
          if (isCompleted) color = 'green'
          if (isCurrent) color = 'blue'
          
          return (
            <Timeline.Item 
              key={item.status}
              color={color}
              dot={isCurrent ? <ClockCircleOutlined /> : null}
            >
              <div className={`timeline-content ${isCompleted ? 'completed' : isPending ? 'pending' : 'current'}`}>
                <div className="timeline-title">{item.title}</div>
                {item.timestamp && (
                  <div className="timeline-time">
                    {moment(item.timestamp).format('YYYY/MM/DD HH:mm')}
                  </div>
                )}
                {item.description && (
                  <div className="timeline-description">{item.description}</div>
                )}
              </div>
            </Timeline.Item>
          )
        })}
      </Timeline>
    </div>
  )
}
```

### 訂單詳情頁面
```jsx
const OrderDetailPage = () => {
  const { orderId } = useParams()
  const [order, setOrder] = useState(null)
  const [loading, setLoading] = useState(true)
  
  useEffect(() => {
    loadOrderDetail()
  }, [orderId])
  
  const loadOrderDetail = async () => {
    try {
      const orderData = await api.getOrder(orderId)
      setOrder(orderData)
    } catch (error) {
      message.error('載入訂單失敗')
    } finally {
      setLoading(false)
    }
  }
  
  if (loading) return <Spin size="large" />
  if (!order) return <Result status="404" title="訂單不存在" />
  
  return (
    <div className="order-detail-page">
      <div className="order-header">
        <h2>訂單詳情</h2>
        <Tag color={OrderStatus[order.status.toUpperCase()].color}>
          {OrderStatus[order.status.toUpperCase()].name}
        </Tag>
      </div>
      
      {/* 訂單狀態時間線 */}
      <Card title="配送進度" className="timeline-card">
        <OrderTimeline order={order} />
      </Card>
      
      {/* 訂單商品 */}
      <Card title="訂單商品" className="items-card">
        {order.items.map(item => (
          <OrderItemRow key={item.id} item={item} />
        ))}
      </Card>
      
      {/* 收件資訊 */}
      <Card title="收件資訊" className="address-card">
        <AddressDisplay address={order.shippingAddress} />
      </Card>
      
      {/* 付款資訊 */}
      <Card title="付款資訊" className="payment-card">
        <Descriptions column={1}>
          <Descriptions.Item label="付款方式">
            {order.paymentMethod}
          </Descriptions.Item>
          <Descriptions.Item label="付款狀態">
            <Tag color={order.paidAt ? 'success' : 'warning'}>
              {order.paidAt ? '已付款' : '待付款'}
            </Tag>
          </Descriptions.Item>
          <Descriptions.Item label="訂單金額">
            NT$ {order.total.toLocaleString()}
          </Descriptions.Item>
        </Descriptions>
      </Card>
    </div>
  )
}
```

## 結帳完成後的處理

### 購物車清理
```js
// 結帳成功後清理購物車中已結帳的商品
const handleCheckoutSuccess = async (orderData) => {
  try {
    // 1. 從購物車移除已結帳的商品
    const checkedOutItemIds = orderData.items.map(item => item.cartItemId)
    await api.removeCartItems(checkedOutItemIds)
    
    // 2. 更新本地購物車狀態
    const remainingItems = cartItems.filter(
      item => !checkedOutItemIds.includes(item.id)
    )
    updateCartItems(remainingItems)
    
    // 3. 同步到其他設備
    CartSyncManager.broadcastUpdate('items_checked_out', {
      removedItemIds: checkedOutItemIds
    })
    
    // 4. 導向成功頁面
    navigate(`/order/success/${orderData.id}`)
    
  } catch (error) {
    console.error('購物車清理失敗:', error)
    // 即使清理失敗也要導向成功頁面
    navigate(`/order/success/${orderData.id}`)
  }
}
```

這個系統涵蓋了你所有的需求，包括智能庫存管理、多設備同步、靈活的結帳流程和完整的訂單追蹤。所有功能都與統一錯誤處理系統和 GSAP 動畫系統整合。