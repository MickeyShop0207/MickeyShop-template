# å‰å°ç¯©é¸æ¢ä»¶ç³»çµ±

## ç³»çµ±æ¦‚è¦½

### ç¯©é¸ç³»çµ±ç‰¹æ€§
- **å¤šç¶­åº¦ç¯©é¸ï¼š** æ”¯æ´å•†å“å±¬æ€§ã€ç¾å®¹å°ˆå±¬ã€ç”¨æˆ¶é«”é©—ç­‰å¤šç¨®ç¯©é¸æ¢ä»¶
- **æ™ºæ…§ç¯©é¸ï¼š** æ ¹æ“šå·²é¸æ¢ä»¶å‹•æ…‹èª¿æ•´å¯é¸é …ï¼Œé¿å…ç„¡æ•ˆçµ„åˆ
- **æ€§èƒ½å„ªåŒ–ï¼š** çµåˆå‰ç«¯å¿«å–å’Œå¾Œç«¯å„ªåŒ–ï¼Œç¢ºä¿æµæš¢é«”é©—
- **å‹•ç•«æ•´åˆï¼š** èˆ‡ GSAP å‹•ç•«ç³»çµ±æ·±åº¦æ•´åˆï¼Œæä¾›è±å¯Œçš„äº’å‹•åé¥‹

## ç¯©é¸æ¢ä»¶åˆ†é¡

### 1. å•†å“åŸºç¤å±¬æ€§ç¯©é¸

#### å“ç‰Œç¯©é¸ (Brand)
```javascript
const brandFilter = {
  type: 'checkbox',
  multiple: true,
  logic: 'OR', // å¤šå“ç‰Œé¸æ“‡ç‚ºORé‚è¼¯
  options: [
    { id: 'brand_1', name: 'L\'OrÃ©al', count: 156 },
    { id: 'brand_2', name: 'Maybelline', count: 89 },
    { id: 'brand_3', name: 'EstÃ©e Lauder', count: 234 },
    // å‹•æ…‹å¾å¾Œç«¯è¼‰å…¥
  ],
  search: true, // æ”¯æ´å“ç‰Œæœå°‹
  showCount: true // é¡¯ç¤ºå•†å“æ•¸é‡
}
```

#### åƒ¹æ ¼å€é–“ç¯©é¸ (Price Range)
```javascript
const priceFilter = {
  type: 'range-slider',
  min: 0,
  max: 5000,
  step: 50,
  defaultValue: [0, 5000],
  currency: 'NT$',
  presets: [
    { label: '100ä»¥ä¸‹', range: [0, 100] },
    { label: '100-500', range: [100, 500] },
    { label: '500-1000', range: [500, 1000] },
    { label: '1000-2000', range: [1000, 2000] },
    { label: '2000ä»¥ä¸Š', range: [2000, 5000] }
  ]
}
```

#### å•†å“åˆ†é¡ç¯©é¸ (Category)
```javascript
const categoryFilter = {
  type: 'tree-select',
  multiple: true,
  hierarchy: [
    {
      id: 'skincare',
      name: 'ä¿é¤Šå“',
      children: [
        { id: 'cleansing', name: 'æ¸…æ½”', count: 89 },
        { id: 'moisturizing', name: 'ä¿æ¿•', count: 156 },
        { id: 'anti-aging', name: 'æŠ—è€', count: 67 },
        { id: 'whitening', name: 'ç¾ç™½', count: 94 }
      ]
    },
    {
      id: 'makeup',
      name: 'ç¾å®¹ç”¨å“',
      children: [
        { id: 'foundation', name: 'åº•å¦', count: 78 },
        { id: 'lipstick', name: 'å”‡å½©', count: 123 },
        { id: 'eyeshadow', name: 'çœ¼å½±', count: 156 }
      ]
    },
    {
      id: 'haircare',
      name: 'ç¾é«®ç”¨å“',
      children: [
        { id: 'shampoo', name: 'æ´—é«®', count: 45 },
        { id: 'treatment', name: 'è­·é«®', count: 67 },
        { id: 'styling', name: 'é€ å‹', count: 89 }
      ]
    }
  ]
}
```

### 2. ç¾å®¹å°ˆå±¬ç¯©é¸æ¢ä»¶

#### è†šè³ªé¡å‹ç¯©é¸ (Skin Type)
```javascript
const skinTypeFilter = {
  type: 'radio-group',
  multiple: false,
  logic: 'AND',
  options: [
    { id: 'all_skin', name: 'æ‰€æœ‰è†šè³ª', isDefault: true },
    { id: 'dry', name: 'ä¹¾æ€§è‚Œè†š', icon: 'ğŸœï¸' },
    { id: 'oily', name: 'æ²¹æ€§è‚Œè†š', icon: 'ğŸ’§' },
    { id: 'combination', name: 'æ··åˆæ€§è‚Œè†š', icon: 'âš–ï¸' },
    { id: 'sensitive', name: 'æ•æ„Ÿæ€§è‚Œè†š', icon: 'ğŸŒ¸' },
    { id: 'mature', name: 'æˆç†Ÿè‚Œè†š', icon: 'ğŸ•°ï¸' }
  ]
}
```

#### å•†å“åŠŸæ•ˆç¯©é¸ (Benefits)
```javascript
const benefitsFilter = {
  type: 'tag-select',
  multiple: true,
  logic: 'AND',
  maxSelection: 3, // æœ€å¤šé¸æ“‡3å€‹åŠŸæ•ˆ
  options: [
    { id: 'hydrating', name: 'ä¿æ¿•', color: '#4FC3F7' },
    { id: 'whitening', name: 'ç¾ç™½', color: '#FFE082' },
    { id: 'anti-aging', name: 'æŠ—è€', color: '#A5D6A7' },
    { id: 'oil-control', name: 'æ§æ²¹', color: '#FFAB91' },
    { id: 'acne-fighting', name: 'æŠ—ç—˜', color: '#F8BBD9' },
    { id: 'firming', name: 'ç·Šç·»', color: '#C5CAE9' },
    { id: 'brightening', name: 'äº®æ¾¤', color: '#FFF59D' },
    { id: 'soothing', name: 'èˆ’ç·©', color: '#DCEDC8' }
  ]
}
```

#### æˆåˆ†é¡å‹ç¯©é¸ (Ingredients)
```javascript
const ingredientsFilter = {
  type: 'checkbox-group',
  multiple: true,
  logic: 'OR',
  categories: [
    {
      name: 'å¤©ç„¶æˆåˆ†',
      items: [
        { id: 'natural', name: 'å¤©ç„¶', badge: 'ğŸŒ¿' },
        { id: 'organic', name: 'æœ‰æ©Ÿèªè­‰', badge: 'ğŸŒ±' },
        { id: 'vegan', name: 'ç´”ç´ ', badge: 'ğŸ¥•' }
      ]
    },
    {
      name: 'ç„¡æ·»åŠ ',
      items: [
        { id: 'paraben-free', name: 'ç„¡é˜²è…åŠ‘', badge: 'ğŸš«' },
        { id: 'fragrance-free', name: 'ç„¡é¦™ç²¾', badge: 'ğŸš«' },
        { id: 'alcohol-free', name: 'ç„¡é…’ç²¾', badge: 'ğŸš«' }
      ]
    }
  ]
}
```

### 3. ç”¨æˆ¶é«”é©—ç¯©é¸

#### è©•åˆ†ç¯©é¸ (Rating)
```javascript
const ratingFilter = {
  type: 'star-rating',
  minRating: 1,
  maxRating: 5,
  step: 0.5,
  defaultValue: 0, // 0è¡¨ç¤ºä¸ç¯©é¸
  showCount: true,
  options: [
    { stars: 5, label: '5æ˜Ÿ', count: 234 },
    { stars: 4, label: '4æ˜Ÿä»¥ä¸Š', count: 456 },
    { stars: 3, label: '3æ˜Ÿä»¥ä¸Š', count: 678 },
    { stars: 2, label: '2æ˜Ÿä»¥ä¸Š', count: 789 },
    { stars: 1, label: '1æ˜Ÿä»¥ä¸Š', count: 890 }
  ]
}
```

#### å•†å“ç‹€æ…‹ç¯©é¸ (Product Status)
```javascript
const statusFilter = {
  type: 'badge-select',
  multiple: true,
  logic: 'OR',
  options: [
    { id: 'new', name: 'æ–°å“', badge: 'NEW', color: '#FF5722' },
    { id: 'hot', name: 'ç†±è³£', badge: 'HOT', color: '#F44336' },
    { id: 'sale', name: 'ç‰¹åƒ¹', badge: 'SALE', color: '#4CAF50' },
    { id: 'limited', name: 'é™é‡', badge: 'LIMITED', color: '#9C27B0' },
    { id: 'preorder', name: 'é è³¼', badge: 'PRE-ORDER', color: '#FF9800' }
  ]
}
```

## ç¯©é¸å™¨ä»‹é¢è¨­è¨ˆ

### æ¡Œé¢ç‰ˆå´é‚Šæ¬„ç¯©é¸å™¨
```scss
// FilterSidebar.module.scss
.filterSidebar {
  width: 280px;
  background: var(--bg-component);
  border-radius: 16px;
  padding: 24px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  
  .filterHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
    
    .title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    
    .clearAll {
      color: var(--color-primary);
      cursor: pointer;
      font-size: 0.875rem;
      
      &:hover {
        text-decoration: underline;
      }
    }
  }
  
  .filterSection {
    margin-bottom: 32px;
    
    &:last-child {
      margin-bottom: 0;
    }
    
    .sectionTitle {
      font-size: 1rem;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      
      .toggleIcon {
        transform: rotate(0deg);
        transition: transform 0.3s ease;
        
        &.collapsed {
          transform: rotate(-90deg);
        }
      }
    }
    
    .sectionContent {
      opacity: 1;
      max-height: 500px;
      overflow: hidden;
      transition: all 0.3s ease;
      
      &.collapsed {
        opacity: 0;
        max-height: 0;
      }
    }
  }
}
```

### ç§»å‹•ç‰ˆåº•éƒ¨å½ˆå‡ºç¯©é¸å™¨
```scss
// FilterBottomSheet.module.scss
.filterBottomSheet {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--bg-component);
  border-radius: 16px 16px 0 0;
  max-height: 80vh;
  overflow-y: auto;
  z-index: 1000;
  
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  
  &.open {
    transform: translateY(0);
  }
  
  .dragHandle {
    width: 40px;
    height: 4px;
    background: var(--text-tertiary);
    border-radius: 2px;
    margin: 12px auto;
  }
  
  .filterContent {
    padding: 0 24px 24px;
  }
  
  .filterActions {
    position: sticky;
    bottom: 0;
    background: var(--bg-component);
    padding: 16px 24px;
    border-top: 1px solid var(--border-color);
    display: flex;
    gap: 12px;
    
    .clearButton,
    .applyButton {
      flex: 1;
      height: 44px;
      border-radius: 8px;
      font-weight: 500;
    }
    
    .clearButton {
      background: var(--bg-hover);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }
    
    .applyButton {
      background: var(--color-primary);
      color: white;
      border: none;
    }
  }
}
```

## ç¯©é¸é‚è¼¯èˆ‡ç‹€æ…‹ç®¡ç†

### Zustand ç¯©é¸ç‹€æ…‹ç®¡ç†
```javascript
// stores/filterStore.js
import { create } from 'zustand'
import { subscribeWithSelector } from 'zustand/middleware'

const useFilterStore = create(
  subscribeWithSelector((set, get) => ({
    // ç¯©é¸æ¢ä»¶ç‹€æ…‹
    filters: {
      brands: [],
      priceRange: [0, 5000],
      categories: [],
      skinType: null,
      benefits: [],
      ingredients: [],
      rating: 0,
      status: []
    },
    
    // ç¯©é¸çµæœ
    filteredProducts: [],
    totalCount: 0,
    isLoading: false,
    
    // ç¯©é¸é¸é …
    filterOptions: {},
    
    // å‹•ä½œ
    setFilter: (filterType, value) => {
      set((state) => ({
        filters: {
          ...state.filters,
          [filterType]: value
        }
      }))
    },
    
    clearFilter: (filterType) => {
      const defaultValues = {
        brands: [],
        priceRange: [0, 5000],
        categories: [],
        skinType: null,
        benefits: [],
        ingredients: [],
        rating: 0,
        status: []
      }
      
      set((state) => ({
        filters: {
          ...state.filters,
          [filterType]: defaultValues[filterType]
        }
      }))
    },
    
    clearAllFilters: () => {
      set({
        filters: {
          brands: [],
          priceRange: [0, 5000],
          categories: [],
          skinType: null,
          benefits: [],
          ingredients: [],
          rating: 0,
          status: []
        }
      })
    },
    
    applyFilters: async () => {
      set({ isLoading: true })
      
      try {
        const { filters } = get()
        const response = await filterProducts(filters)
        
        set({
          filteredProducts: response.products,
          totalCount: response.total,
          isLoading: false
        })
      } catch (error) {
        set({ isLoading: false })
        // ä½¿ç”¨çµ±ä¸€éŒ¯èª¤è™•ç†ç³»çµ±
        const { useErrorHandler } = await import('@/stores/error-handler')
        useErrorHandler.getState().handleError(error, {
          type: 'filter-application',
          filters: filters,
          retryCallback: () => get().applyFilters(filters)
        })
      }
    },
    
    loadFilterOptions: async () => {
      try {
        const options = await getFilterOptions()
        set({ filterOptions: options })
      } catch (error) {
        // ä½¿ç”¨çµ±ä¸€éŒ¯èª¤è™•ç†ç³»çµ±
        const { useErrorHandler } = await import('@/stores/error-handler')
        useErrorHandler.getState().handleError(error, {
          type: 'filter-options-load',
          retryCallback: () => get().loadFilterOptions()
        })
      }
    }
  }))
)

export default useFilterStore
```

### æ™ºæ…§ç¯©é¸é‚è¼¯
```javascript
// utils/smartFiltering.js
export const updateAvailableOptions = (currentFilters, allOptions) => {
  // æ ¹æ“šç•¶å‰å·²é¸æ“‡çš„ç¯©é¸æ¢ä»¶ï¼Œå‹•æ…‹æ›´æ–°å¯ç”¨é¸é …
  const { brands, categories, skinType, benefits } = currentFilters
  
  // å¦‚æœå·²é¸æ“‡åˆ†é¡ï¼Œå‰‡åªé¡¯ç¤ºè©²åˆ†é¡ä¸‹çš„å“ç‰Œ
  let availableBrands = allOptions.brands
  if (categories.length > 0) {
    availableBrands = allOptions.brands.filter(brand => 
      brand.categories.some(cat => categories.includes(cat))
    )
  }
  
  // å¦‚æœå·²é¸æ“‡è†šè³ªï¼Œå‰‡åªé¡¯ç¤ºé©åˆçš„åŠŸæ•ˆ
  let availableBenefits = allOptions.benefits
  if (skinType) {
    availableBenefits = allOptions.benefits.filter(benefit =>
      benefit.suitableFor.includes(skinType) || benefit.suitableFor.includes('all')
    )
  }
  
  return {
    ...allOptions,
    brands: availableBrands,
    benefits: availableBenefits
  }
}

// ç¯©é¸é‚è¼¯çµ„åˆ
export const combineFilters = (filters) => {
  const conditions = []
  
  // å“ç‰Œç¯©é¸ (ORé‚è¼¯)
  if (filters.brands.length > 0) {
    conditions.push({
      field: 'brand',
      operator: 'in',
      value: filters.brands
    })
  }
  
  // åƒ¹æ ¼å€é–“ç¯©é¸
  if (filters.priceRange[0] > 0 || filters.priceRange[1] < 5000) {
    conditions.push({
      field: 'price',
      operator: 'between',
      value: filters.priceRange
    })
  }
  
  // åˆ†é¡ç¯©é¸ (ORé‚è¼¯)
  if (filters.categories.length > 0) {
    conditions.push({
      field: 'category',
      operator: 'in',
      value: filters.categories
    })
  }
  
  // è†šè³ªç¯©é¸
  if (filters.skinType) {
    conditions.push({
      field: 'skinTypes',
      operator: 'contains',
      value: filters.skinType
    })
  }
  
  // åŠŸæ•ˆç¯©é¸ (ANDé‚è¼¯ - å¿…é ˆåŒ…å«æ‰€æœ‰é¸ä¸­çš„åŠŸæ•ˆ)
  if (filters.benefits.length > 0) {
    conditions.push({
      field: 'benefits',
      operator: 'containsAll',
      value: filters.benefits
    })
  }
  
  // æˆåˆ†ç¯©é¸ (ORé‚è¼¯)
  if (filters.ingredients.length > 0) {
    conditions.push({
      field: 'ingredients',
      operator: 'containsAny',
      value: filters.ingredients
    })
  }
  
  // è©•åˆ†ç¯©é¸
  if (filters.rating > 0) {
    conditions.push({
      field: 'rating',
      operator: 'gte',
      value: filters.rating
    })
  }
  
  // å•†å“ç‹€æ…‹ç¯©é¸ (ORé‚è¼¯)
  if (filters.status.length > 0) {
    conditions.push({
      field: 'status',
      operator: 'in',
      value: filters.status
    })
  }
  
  return {
    conditions,
    logic: 'AND' // ä¸åŒç¯©é¸é¡å‹ä¹‹é–“ä½¿ç”¨ANDé‚è¼¯
  }
}
```

## å‹•ç•«æ•´åˆ

### ç¯©é¸çµæœæ›´æ–°å‹•ç•«
```javascript
// animations/filterAnimations.js
export const filterResultAnimations = {
  // å•†å“åˆ—è¡¨æ›´æ–°å‹•ç•«
  updateProductList: async (container, newProducts) => {
    const timeline = gsap.timeline()
    
    // 1. èˆŠå•†å“æ·¡å‡º
    timeline
      .to('.product-card', {
        opacity: 0,
        y: 20,
        duration: 0.3,
        stagger: 0.05,
        ease: 'power2.in'
      })
      
    // 2. æ›´æ–°å•†å“å…§å®¹
    timeline
      .call(() => {
        renderNewProducts(newProducts)
      })
      
    // 3. æ–°å•†å“æ·¡å…¥
    timeline
      .from('.product-card', {
        opacity: 0,
        y: -20,
        duration: 0.4,
        stagger: 0.08,
        ease: 'power2.out'
      })
      
    return timeline
  },
  
  // ç¯©é¸å™¨å±•é–‹å‹•ç•«
  expandFilterSection: (sectionElement) => {
    const content = sectionElement.querySelector('.sectionContent')
    const icon = sectionElement.querySelector('.toggleIcon')
    
    const timeline = gsap.timeline()
    
    timeline
      .to(icon, {
        rotation: 0,
        duration: 0.3,
        ease: 'power2.out'
      })
      .to(content, {
        opacity: 1,
        maxHeight: 500,
        duration: 0.3,
        ease: 'power2.out'
      }, '<')
      
    return timeline
  },
  
  // ç¯©é¸å™¨æ”¶åˆå‹•ç•«
  collapseFilterSection: (sectionElement) => {
    const content = sectionElement.querySelector('.sectionContent')
    const icon = sectionElement.querySelector('.toggleIcon')
    
    const timeline = gsap.timeline()
    
    timeline
      .to(icon, {
        rotation: -90,
        duration: 0.3,
        ease: 'power2.out'
      })
      .to(content, {
        opacity: 0,
        maxHeight: 0,
        duration: 0.3,
        ease: 'power2.out'
      }, '<')
      
    return timeline
  },
  
  // è¼‰å…¥ç‹€æ…‹å‹•ç•«
  showLoading: (container) => {
    return gsap.fromTo('.filter-loading', 
      { opacity: 0, scale: 0.8 },
      { opacity: 1, scale: 1, duration: 0.3, ease: 'back.out(1.7)' }
    )
  },
  
  // ç„¡çµæœç‹€æ…‹å‹•ç•«
  showNoResults: (container) => {
    return gsap.fromTo('.no-results', 
      { opacity: 0, y: 30 },
      { opacity: 1, y: 0, duration: 0.5, ease: 'power2.out' }
    )
  }
}
```

## æ€§èƒ½å„ªåŒ–ç­–ç•¥

### å‰ç«¯å¿«å–ç­–ç•¥
```javascript
// utils/filterCache.js
class FilterCache {
  constructor() {
    this.cache = new Map()
    this.maxCacheSize = 50
    this.cacheTTL = 5 * 60 * 1000 // 5åˆ†é˜
  }
  
  generateCacheKey(filters) {
    return JSON.stringify(filters)
  }
  
  get(filters) {
    const key = this.generateCacheKey(filters)
    const cached = this.cache.get(key)
    
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return cached.data
    }
    
    return null
  }
  
  set(filters, data) {
    const key = this.generateCacheKey(filters)
    
    // LRU æ¸…ç†ç­–ç•¥
    if (this.cache.size >= this.maxCacheSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    })
  }
  
  clear() {
    this.cache.clear()
  }
}

export const filterCache = new FilterCache()
```

### é˜²æŠ–è™•ç†
```javascript
// hooks/useFilterDebounce.js
import { useCallback, useRef } from 'react'
import { debounce } from 'lodash-es'

export const useFilterDebounce = (callback, delay = 300) => {
  const callbackRef = useRef(callback)
  callbackRef.current = callback
  
  return useCallback(
    debounce((...args) => {
      callbackRef.current(...args)
    }, delay),
    [delay]
  )
}
```

## API è¨­è¨ˆ

### ç¯©é¸APIç«¯é»
```javascript
// api/filter.js
export const filterAPI = {
  // ç²å–ç¯©é¸é¸é …
  getFilterOptions: async () => {
    const response = await fetch('/api/filters/options')
    return response.json()
  },
  
  // ç¯©é¸å•†å“
  filterProducts: async (filters, pagination = { page: 1, limit: 20 }) => {
    const response = await fetch('/api/products/filter', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        filters: combineFilters(filters),
        pagination
      })
    })
    return response.json()
  },
  
  // ç²å–ç¯©é¸çµ±è¨ˆ
  getFilterStats: async (filters) => {
    const response = await fetch('/api/filters/stats', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ filters })
    })
    return response.json()
  }
}
```

## ä½¿ç”¨è€…é«”é©—å„ªåŒ–

### ç¯©é¸ç‹€æ…‹æŒä¹…åŒ–
```javascript
// utils/filterPersistence.js
export const filterPersistence = {
  // ä¿å­˜ç¯©é¸ç‹€æ…‹åˆ° URL
  saveToURL: (filters) => {
    const searchParams = new URLSearchParams()
    
    Object.entries(filters).forEach(([key, value]) => {
      if (Array.isArray(value) && value.length > 0) {
        searchParams.set(key, value.join(','))
      } else if (value && typeof value === 'object') {
        searchParams.set(key, JSON.stringify(value))
      } else if (value) {
        searchParams.set(key, value.toString())
      }
    })
    
    const newURL = `${window.location.pathname}?${searchParams.toString()}`
    window.history.replaceState({}, '', newURL)
  },
  
  // å¾ URL è¼‰å…¥ç¯©é¸ç‹€æ…‹
  loadFromURL: () => {
    const searchParams = new URLSearchParams(window.location.search)
    const filters = {}
    
    searchParams.forEach((value, key) => {
      if (key === 'priceRange') {
        filters[key] = JSON.parse(value)
      } else if (['brands', 'categories', 'benefits', 'ingredients', 'status'].includes(key)) {
        filters[key] = value.split(',').filter(Boolean)
      } else if (key === 'rating') {
        filters[key] = parseFloat(value)
      } else {
        filters[key] = value
      }
    })
    
    return filters
  }
}
```

### ç¯©é¸å»ºè­°åŠŸèƒ½
```javascript
// components/FilterSuggestions.jsx
const FilterSuggestions = () => {
  const [suggestions, setSuggestions] = useState([])
  
  useEffect(() => {
    // æ ¹æ“šç”¨æˆ¶è¡Œç‚ºå’Œç†±é–€ç¯©é¸æ¢ä»¶ç”Ÿæˆå»ºè­°
    const generateSuggestions = async () => {
      const popular = await getPopularFilters()
      const userHistory = await getUserFilterHistory()
      const seasonal = await getSeasonalSuggestions()
      
      setSuggestions([...popular, ...userHistory, ...seasonal])
    }
    
    generateSuggestions()
  }, [])
  
  return (
    <div className={styles.suggestions}>
      <h3>æ¨è–¦ç¯©é¸</h3>
      <div className={styles.suggestionTags}>
        {suggestions.map(suggestion => (
          <button
            key={suggestion.id}
            className={styles.suggestionTag}
            onClick={() => applySuggestion(suggestion.filters)}
          >
            {suggestion.label}
          </button>
        ))}
      </div>
    </div>
  )
}
```