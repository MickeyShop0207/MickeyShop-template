# 快取策略設計 & PWA離線功能

## Cloudflare KV + Service Worker 架構

### 快取層級設計

#### 1. Cloudflare KV (邊緣快取)
```js
// 適用內容
- 商品詳情頁面HTML
- 商品圖片和媒體文件
- 翻譯文件 (i18n資源)
- 熱門搜索結果
- 靜態API響應
```

#### 2. Service Worker (客戶端快取)
```js
// 適用內容
- 動態內容和用戶相關數據
- API請求響應
- 頁面模板和組件
- 字體和CSS文件
```

#### 3. IndexedDB (本地存儲)
```js
// 適用內容
- 離線購物車數據
- 用戶偏好設定
- 瀏覽歷史記錄
- 下載的商品目錄
```

### 快取策略實現

#### Cloudflare KV配置
```js
// 商品頁面快取
const cacheProduct = async (productId, html) => {
  await KV.put(`product:${productId}`, html, {
    expirationTtl: 86400 // 24小時
  })
}

// 商品列表快取  
const cacheProductList = async (category, html) => {
  await KV.put(`products:${category}`, html, {
    expirationTtl: 3600 // 1小時
  })
}

// 搜索結果快取
const cacheSearchResults = async (query, results) => {
  await KV.put(`search:${encodeURIComponent(query)}`, results, {
    expirationTtl: 1800 // 30分鐘
  })
}
```

#### Service Worker快取規則
```js
// 快取策略配置
const cacheStrategies = {
  // 靜態資源 - 快取優先
  '\\.(js|css|woff2|png|jpg|svg)$': 'CacheFirst',
  
  // 商品API - 網路優先，快取備用
  '/api/products': 'NetworkFirst',
  
  // 用戶相關 - 僅網路
  '/api/user': 'NetworkOnly',
  
  // 搜索API - 快取優先，過期後網路更新
  '/api/search': 'StaleWhileRevalidate'
}
```

### 快取失效機制

#### 商品數據更新
```js
// 商品更新時的快取清理
const invalidateProductCache = async (productId, category) => {
  await Promise.all([
    // 清除商品詳情快取
    KV.delete(`product:${productId}`),
    
    // 清除相關商品列表快取
    KV.delete(`products:${category}`),
    KV.delete(`products:featured`),
    
    // 清除搜索結果快取
    KV.delete(`search:${productName}`),
    
    // 通知Service Worker更新
    broadcastCacheInvalidation('product', productId)
  ])
}
```

#### 價格/庫存更新
```js
// 即時性要求高的數據
const updateProductStock = async (productId, stock) => {
  // 更新資料庫
  await updateDatabase(productId, { stock })
  
  // 立即清除快取，強制下次請求從API獲取
  await KV.delete(`product:${productId}`)
  
  // 推送即時更新給已開啟的頁面
  await broadcastStockUpdate(productId, stock)
}
```

## 性能優化策略

### 預載入機制
```js
// 首頁預載入關鍵商品
const preloadCriticalProducts = async () => {
  const featuredProducts = await getFeaturedProducts()
  
  // 預載入熱門商品頁面到KV
  featuredProducts.forEach(product => {
    preloadProductPage(product.id)
  })
}
```

### 智能快取預測
```js
// 基於用戶行為預載入
const predictiveCache = {
  // 用戶瀏覽分類時，預載入該分類的熱門商品
  onCategoryView: (category) => {
    preloadTopProductsInCategory(category)
  },
  
  // 用戶搜索時，預載入相關商品
  onSearch: (query) => {
    preloadSearchResults(query)
  }
}
```

### 快取容量管理
```js
// Service Worker快取限制
const cacheConfig = {
  maxEntries: 100, // 最多快取100個API響應
  maxAgeSeconds: 3600, // 1小時後過期
  purgeOnQuotaError: true // 空間不足時自動清理
}

// IndexedDB容量管理
const offlineStorageConfig = {
  maxProducts: 1000, // 最多離線存儲1000個商品
  maxImages: 500, // 最多快取500張商品圖片
  autoCleanup: true // 自動清理舊數據
}
```

## 離線處理策略

### 離線動畫頁面
```js
// 網路狀態檢測
const networkStatus = {
  isOnline: () => navigator.onLine,
  
  // 監聽網路狀態變化
  setupNetworkListener: () => {
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
  },
  
  // 離線時顯示動畫頁面
  handleOffline: () => {
    // 重導向到離線動畫頁面
    if (!window.location.pathname.includes('/offline')) {
      window.location.href = '/offline.html'
    }
  },
  
  // 上線時回到正常功能
  handleOnline: () => {
    if (window.location.pathname.includes('/offline')) {
      window.location.href = '/'
    }
  }
}

// 初始化網路監聽
networkStatus.setupNetworkListener()
```

### 離線動畫頁面實現
```html
<!-- public/offline.html -->
<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MickeyShop Beauty - 未連接至網路</title>
  <link rel="stylesheet" href="/offline-styles.css">
</head>
<body>
  <div class="offline-container">
    <div class="brand-logo">
      <img src="/logo-offline.svg" alt="MickeyShop Beauty" />
    </div>
    
    <div class="offline-animation">
      <div class="connection-icon">
        <div class="wifi-symbol">
          <div class="wifi-circle"></div>
          <div class="wifi-line wifi-line-1"></div>
          <div class="wifi-line wifi-line-2"></div>
          <div class="wifi-line wifi-line-3"></div>
        </div>
        <div class="disconnect-indicator"></div>
      </div>
    </div>
    
    <div class="offline-message">
      <h1>未連接至網路</h1>
      <p>MickeyShop Beauty 期待與您下次相遇</p>
      <div class="retry-indicator">
        <span>正在重新連接...</span>
        <div class="loading-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    </div>
  </div>
  
  <script src="/offline-animation.js"></script>
</body>
</html>
```

## PWA應用功能實現

### Vite PWA Plugin配置（網絡優先）
```js
// vite.config.js
import { VitePWA } from 'vite-plugin-pwa'

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'safari-pinned-tab.svg'],
      manifest: {
        name: 'MickeyShop Beauty',
        short_name: 'MickeyShop',
        description: '美容用品、保養品、美髮用品電商平台',
        theme_color: '#A66556',
        background_color: '#F2E8DF',
        display: 'standalone',
        orientation: 'portrait-primary',
        scope: '/',
        start_url: '/',
        categories: ['shopping', 'beauty', 'lifestyle'],
        lang: 'zh-TW',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable'
          }
        ],
        shortcuts: [
          {
            name: '瀏覽商品',
            short_name: '商品',
            description: '瀏覽所有美容商品',
            url: '/zh-TW/products',
            icons: [{ src: 'shortcut-products.png', sizes: '96x96' }]
          },
          {
            name: '購物車',
            short_name: '購物車',
            description: '查看購物車內容',
            url: '/zh-TW/cart',
            icons: [{ src: 'shortcut-cart.png', sizes: '96x96' }]
          },
          {
            name: '會員中心',
            short_name: '會員',
            description: '管理個人資料和訂單',
            url: '/zh-TW/profile',
            icons: [{ src: 'shortcut-profile.png', sizes: '96x96' }]
          }
        ]
      },
      workbox: {
        // 僅快取靜態資源，不快取API或頁面內容
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        runtimeCaching: [
          {
            // 僅快取靜態圖片資源（Logo、圖標等）
            urlPattern: /^https:\/\/cdn\.mickeyshop\.com\/(icons|logos|static)\/.*$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'static-images-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 60 * 60 * 24 * 7 // 7天
              }
            }
          }
        ],
        // 不快取導航請求，確保離線時顯示離線頁面
        navigateFallback: '/offline.html',
        skipWaiting: true,
        clientsClaim: true
      }
    })
  ]
})
```

### 推送通知系統
```js
// utils/push-notifications.js
class PushNotificationManager {
  constructor() {
    this.vapidPublicKey = 'YOUR_VAPID_PUBLIC_KEY'
  }
  
  async requestPermission() {
    if (!('Notification' in window)) {
      throw new Error('瀏覽器不支援通知功能')
    }
    
    const permission = await Notification.requestPermission()
    if (permission !== 'granted') {
      throw new Error('用戶拒絕通知權限')
    }
    
    return permission
  }
  
  async subscribeToPush() {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
      throw new Error('瀏覽器不支援推送通知')
    }
    
    const registration = await navigator.serviceWorker.ready
    
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: this.urlBase64ToUint8Array(this.vapidPublicKey)
    })
    
    // 發送訂閱信息到服務器
    await fetch('/api/push/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        subscription,
        userPreferences: {
          promotions: true,
          newProducts: true,
          priceAlerts: true
        }
      })
    })
    
    return subscription
  }
}

export const pushNotificationManager = new PushNotificationManager()
```

### Service Worker推送處理
```js
// public/sw-push.js
self.addEventListener('push', event => {
  const options = {
    body: 'MickeyShop有新的優惠活動！',
    icon: '/pwa-192x192.png',
    badge: '/badge-72x72.png',
    tag: 'promotion',
    requireInteraction: true,
    actions: [
      {
        action: 'view',
        title: '查看詳情',
        icon: '/action-view.png'
      },
      {
        action: 'dismiss',
        title: '關閉',
        icon: '/action-dismiss.png'
      }
    ],
    data: {
      url: '/zh-TW/promotions',
      timestamp: Date.now()
    }
  }
  
  if (event.data) {
    const payload = event.data.json()
    Object.assign(options, payload)
  }
  
  event.waitUntil(
    self.registration.showNotification('MickeyShop Beauty', options)
  )
})

self.addEventListener('notificationclick', event => {
  event.notification.close()
  
  const { action, data } = event
  const { url } = data || { url: '/' }
  
  if (action === 'view') {
    event.waitUntil(
      clients.openWindow(url)
    )
  }
})
```

### 離線動畫樣式
```css
/* public/offline-styles.css */
.offline-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #F2E8DF 0%, #E8D5C3 100%);
  padding: 2rem;
  text-align: center;
  font-family: 'Noto Sans TC', sans-serif;
}

.brand-logo img {
  width: 150px;
  height: auto;
  margin-bottom: 3rem;
  opacity: 0.8;
}

.offline-animation {
  margin: 2rem 0;
}

.connection-icon {
  position: relative;
  display: inline-block;
  animation: pulse 2s infinite;
}

.wifi-symbol {
  position: relative;
  width: 60px;
  height: 60px;
}

.wifi-circle {
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 8px;
  height: 8px;
  background: #A66556;
  border-radius: 50%;
  opacity: 0.5;
}

.wifi-line {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  border: 2px solid #A66556;
  border-bottom: none;
  border-radius: 20px 20px 0 0;
  opacity: 0.3;
}

.wifi-line-1 {
  width: 20px;
  height: 10px;
  animation: wifiPulse 1.5s infinite 0s;
}

.wifi-line-2 {
  width: 35px;
  height: 17px;
  animation: wifiPulse 1.5s infinite 0.3s;
}

.wifi-line-3 {
  width: 50px;
  height: 25px;
  animation: wifiPulse 1.5s infinite 0.6s;
}

.disconnect-indicator {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 20px;
  height: 20px;
  background: #D4615A;
  border-radius: 50%;
  animation: blink 1s infinite;
}

.disconnect-indicator::before {
  content: '×';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 14px;
  font-weight: bold;
}

.offline-message h1 {
  color: #A66556;
  font-size: 2.5rem;
  margin-bottom: 1rem;
  font-weight: 300;
}

.offline-message p {
  color: #8B4B3C;
  font-size: 1.2rem;
  margin-bottom: 2rem;
  font-weight: 400;
}

.retry-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  color: #A66556;
  font-size: 1rem;
}

.loading-dots {
  display: flex;
  gap: 4px;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #A66556;
  animation: loadingDots 1.4s infinite;
}

.loading-dots span:nth-child(2) {
  animation-delay: 0.2s;
}

.loading-dots span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes wifiPulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.3; }
}

@keyframes loadingDots {
  0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
  40% { transform: scale(1.2); opacity: 1; }
}

/* 響應式設計 */
@media (max-width: 768px) {
  .offline-message h1 {
    font-size: 2rem;
  }
  
  .offline-message p {
    font-size: 1rem;
  }
  
  .brand-logo img {
    width: 120px;
  }
}
```

### 離線動畫邏輯
```js
// public/offline-animation.js
class OfflineAnimationManager {
  constructor() {
    this.checkInterval = 5000 // 每5秒檢查一次網路狀態
    this.retryAttempts = 0
    this.maxRetryAttempts = 3
  }
  
  init() {
    this.startNetworkMonitoring()
    this.updateRetryMessage()
  }
  
  startNetworkMonitoring() {
    // 定期檢查網路狀態
    setInterval(() => {
      this.checkNetworkStatus()
    }, this.checkInterval)
    
    // 監聽網路事件
    window.addEventListener('online', this.handleOnline.bind(this))
    window.addEventListener('offline', this.handleOffline.bind(this))
  }
  
  async checkNetworkStatus() {
    if (navigator.onLine) {
      try {
        // 嘗試連接服務器確認真實網路狀態
        const response = await fetch('/?ping=true', {
          method: 'HEAD',
          cache: 'no-cache',
          timeout: 3000
        })
        
        if (response.ok) {
          this.handleOnline()
        }
      } catch (error) {
        this.retryAttempts++
        this.updateRetryMessage()
      }
    }
  }
  
  handleOnline() {
    // 網路恢復，重導向回主頁
    window.location.href = '/'
  }
  
  handleOffline() {
    this.retryAttempts = 0
    this.updateRetryMessage()
  }
  
  updateRetryMessage() {
    const retryElement = document.querySelector('.retry-indicator span')
    
    if (this.retryAttempts === 0) {
      retryElement.textContent = '正在重新連接...'
    } else if (this.retryAttempts < this.maxRetryAttempts) {
      retryElement.textContent = `重新連接中... (${this.retryAttempts}/${this.maxRetryAttempts})`
    } else {
      retryElement.textContent = '請檢查網路連接後重新整理頁面'
      // 隱藏載入動畫
      document.querySelector('.loading-dots').style.display = 'none'
    }
  }
}

// 初始化離線動畫管理器
const offlineManager = new OfflineAnimationManager()
offlineManager.init()
```

### PWA安裝提示組件
```jsx
// components/PWAInstallPrompt.jsx
import { useState, useEffect } from 'react'
import { Button, Modal } from 'antd'

const PWAInstallPrompt = () => {
  const [deferredPrompt, setDeferredPrompt] = useState(null)
  const [showInstallModal, setShowInstallModal] = useState(false)
  
  useEffect(() => {
    const handleBeforeInstallPrompt = (e) => {
      e.preventDefault()
      setDeferredPrompt(e)
      setShowInstallModal(true)
    }
    
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt)
    
    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt)
    }
  }, [])
  
  const handleInstall = async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt()
      const { outcome } = await deferredPrompt.userChoice
      
      if (outcome === 'accepted') {
        setDeferredPrompt(null)
        setShowInstallModal(false)
      }
    }
  }
  
  return (
    <Modal
      title="安裝 MickeyShop App"
      open={showInstallModal}
      onCancel={() => setShowInstallModal(false)}
      footer={[
        <Button key="cancel" onClick={() => setShowInstallModal(false)}>
          稍後再說
        </Button>,
        <Button key="install" type="primary" onClick={handleInstall}>
          立即安裝
        </Button>
      ]}
    >
      <p>安裝 MickeyShop App 到您的設備上，享受：</p>
      <ul>
        <li>即時優惠通知</li>
        <li>更快的載入速度</li>
        <li>類似原生App的體驗</li>
        <li>快捷桌面訪問</li>
      </ul>
    </Modal>
  )
}

export default PWAInstallPrompt
```

## 監控與分析

### 快取命中率監控
```js
// 快取效能監控
const cacheMetrics = {
  trackHitRate: (cacheType, hit) => {
    analytics.track('cache_performance', {
      type: cacheType,
      hit: hit,
      timestamp: Date.now()
    })
  },
  
  // 定期報告快取效能
  generateReport: () => {
    return {
      kvHitRate: calculateHitRate('kv'),
      swHitRate: calculateHitRate('service_worker'),
      avgResponseTime: calculateAvgResponseTime()
    }
  }
}
```

### PWA功能監控
```js
// PWA功能使用監控
const pwaMetrics = {
  trackInstallation: () => {
    analytics.track('pwa_installed', {
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    })
  },
  
  trackOfflinePageView: () => {
    analytics.track('offline_page_viewed', {
      timestamp: Date.now(),
      duration: Date.now() - window.offlineStartTime
    })
  },
  
  trackNetworkReconnection: () => {
    analytics.track('network_reconnected', {
      timestamp: Date.now(),
      offlineDuration: Date.now() - window.offlineStartTime
    })
  },
  
  trackPushNotification: (action) => {
    analytics.track('push_notification', {
      action: action, // 'received', 'clicked', 'dismissed'
      timestamp: Date.now()
    })
  }
}
```