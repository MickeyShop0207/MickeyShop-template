# 表單驗證系統

## 系統概覽

統一的表單驗證系統，涵蓋註冊/登入、用戶個人資料、訂單管理、評價表單等所有前端表單驗證需求，提供一致的驗證規則、錯誤處理和用戶體驗。

## 核心驗證框架

### 1. 驗證引擎架構
```javascript
// utils/validation/ValidationEngine.js
class ValidationEngine {
  constructor() {
    this.rules = new Map()
    this.errorMessages = new Map()
    this.asyncValidators = new Map()
  }
  
  // 註冊驗證規則
  registerRule(name, validator, errorMessage) {
    this.rules.set(name, validator)
    this.errorMessages.set(name, errorMessage)
  }
  
  // 註冊異步驗證器
  registerAsyncValidator(name, validator, errorMessage) {
    this.asyncValidators.set(name, validator)
    this.errorMessages.set(name, errorMessage)
  }
  
  // 同步驗證
  validate(value, rules, fieldName) {
    const errors = []
    
    for (const rule of rules) {
      if (typeof rule === 'string') {
        // 預定義規則
        const validator = this.rules.get(rule)
        if (validator && !validator(value)) {
          errors.push({
            field: fieldName,
            rule,
            message: this.errorMessages.get(rule)
          })
        }
      } else if (typeof rule === 'object') {
        // 自定義規則
        const { name, params, message } = rule
        const validator = this.rules.get(name)
        if (validator && !validator(value, params)) {
          errors.push({
            field: fieldName,
            rule: name,
            message: message || this.errorMessages.get(name)
          })
        }
      }
    }
    
    return errors
  }
  
  // 異步驗證
  async validateAsync(value, asyncRules, fieldName) {
    const errors = []
    
    for (const rule of asyncRules) {
      const validator = this.asyncValidators.get(rule)
      if (validator) {
        try {
          const isValid = await validator(value)
          if (!isValid) {
            errors.push({
              field: fieldName,
              rule,
              message: this.errorMessages.get(rule)
            })
          }
        } catch (error) {
          errors.push({
            field: fieldName,
            rule,
            message: '驗證過程發生錯誤'
          })
        }
      }
    }
    
    return errors
  }
}

export const validationEngine = new ValidationEngine()
```

### 2. 預定義驗證規則
```javascript
// utils/validation/rules.js
import { validationEngine } from './ValidationEngine'

// 基本規則
validationEngine.registerRule('required', (value) => {
  return value !== null && value !== undefined && value !== ''
}, '此欄位為必填')

validationEngine.registerRule('email', (value) => {
  if (!value) return true // 非必填時允許空值
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(value)
}, '請輸入有效的電子郵件格式')

validationEngine.registerRule('taiwanese_mobile', (value) => {
  if (!value) return true
  const mobileRegex = /^09\d{8}$/
  return mobileRegex.test(value)
}, '請輸入有效的台灣手機號碼格式 (09xxxxxxxx)')

validationEngine.registerRule('taiwanese_phone', (value) => {
  if (!value) return true
  // 支援市話和手機
  const phoneRegex = /^(0\d{1,3}-?\d{6,8}|09\d{8})$/
  return phoneRegex.test(value)
}, '請輸入有效的台灣電話號碼格式')

validationEngine.registerRule('taiwanese_postal_code', (value) => {
  if (!value) return true
  const postalRegex = /^\d{3}(\d{2})?$/
  return postalRegex.test(value)
}, '請輸入有效的郵遞區號格式')

// 密碼規則 - 最少8個字元，需要包含大小寫英文和數字，不需要特殊符號
validationEngine.registerRule('password_strength', (value) => {
  if (!value) return true
  
  // 最少8個字元
  if (value.length < 8) return false
  
  // 包含大寫字母
  if (!/[A-Z]/.test(value)) return false
  
  // 包含小寫字母
  if (!/[a-z]/.test(value)) return false
  
  // 包含數字
  if (!/\d/.test(value)) return false
  
  return true
}, '密碼需至少8個字元，包含大小寫英文字母和數字')

validationEngine.registerRule('password_confirm', (value, params) => {
  const { password } = params
  return value === password
}, '確認密碼與新密碼不一致')

// 長度限制規則
validationEngine.registerRule('min_length', (value, params) => {
  if (!value) return true
  const { min } = params
  return value.length >= min
}, (params) => `最少需要 ${params.min} 個字元`)

validationEngine.registerRule('max_length', (value, params) => {
  if (!value) return true
  const { max } = params
  return value.length <= max
}, (params) => `最多只能 ${params.max} 個字元`)

// 年齡限制規則 (後台可設定最小年齡)
validationEngine.registerRule('min_age', (value, params) => {
  if (!value) return true
  const { minAge } = params
  const birthDate = new Date(value)
  const today = new Date()
  const age = today.getFullYear() - birthDate.getFullYear()
  const monthDiff = today.getMonth() - birthDate.getMonth()
  
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--
  }
  
  return age >= minAge
}, (params) => `年齡需滿 ${params.minAge} 歲`)

// 敏感詞彙過濾
validationEngine.registerRule('profanity_filter', async (value) => {
  if (!value) return true
  try {
    const response = await api.checkProfanity(value)
    return !response.containsProfanity
  } catch (error) {
    console.error('敏感詞彙檢查失敗:', error)
    return true // 檢查失敗時允許通過
  }
}, '內容包含不適當的詞彙，請修改後重新提交')

// 異步驗證規則
validationEngine.registerAsyncValidator('email_availability', async (email) => {
  try {
    const response = await api.checkEmailAvailability(email)
    return response.isAvailable
  } catch (error) {
    return true // API 錯誤時允許通過
  }
}, '此電子郵件已被註冊')

validationEngine.registerAsyncValidator('purchase_verification', async (productId) => {
  try {
    const response = await api.checkPurchaseHistory(productId)
    return response.hasPurchased
  } catch (error) {
    return false
  }
}, '只有購買過的用戶才能評價此商品')
```

### 3. 表單驗證 Hook
```javascript
// hooks/useFormValidation.js
import { useState, useCallback, useRef } from 'react'
import { validationEngine } from '@/utils/validation/ValidationEngine'
import { useI18nStore } from '@/stores/i18n'

export const useFormValidation = (validationConfig) => {
  const [errors, setErrors] = useState({})
  const [isValidating, setIsValidating] = useState({})
  const validationTimeouts = useRef({})
  const { locale } = useI18nStore()
  
  // 清除驗證超時
  const clearValidationTimeout = (fieldName) => {
    if (validationTimeouts.current[fieldName]) {
      clearTimeout(validationTimeouts.current[fieldName])
      delete validationTimeouts.current[fieldName]
    }
  }
  
  // 單一欄位驗證
  const validateField = useCallback(async (fieldName, value, immediate = false) => {
    const fieldConfig = validationConfig[fieldName]
    if (!fieldConfig) return true
    
    // 清除之前的錯誤
    setErrors(prev => ({
      ...prev,
      [fieldName]: null
    }))
    
    // 如果不是立即驗證，設定延遲
    if (!immediate) {
      clearValidationTimeout(fieldName)
      return new Promise((resolve) => {
        validationTimeouts.current[fieldName] = setTimeout(async () => {
          const result = await validateField(fieldName, value, true)
          resolve(result)
        }, 300) // 300ms 延遲
      })
    }
    
    setIsValidating(prev => ({ ...prev, [fieldName]: true }))
    
    try {
      const { rules = [], asyncRules = [] } = fieldConfig
      
      // 同步驗證
      const syncErrors = validationEngine.validate(value, rules, fieldName)
      if (syncErrors.length > 0) {
        setErrors(prev => ({
          ...prev,
          [fieldName]: syncErrors[0].message
        }))
        return false
      }
      
      // 異步驗證
      if (asyncRules.length > 0) {
        const asyncErrors = await validationEngine.validateAsync(value, asyncRules, fieldName)
        if (asyncErrors.length > 0) {
          setErrors(prev => ({
            ...prev,
            [fieldName]: asyncErrors[0].message
          }))
          return false
        }
      }
      
      return true
      
    } catch (error) {
      setErrors(prev => ({
        ...prev,
        [fieldName]: '驗證過程發生錯誤'
      }))
      return false
    } finally {
      setIsValidating(prev => ({ ...prev, [fieldName]: false }))
    }
  }, [validationConfig])
  
  // 驗證整個表單
  const validateForm = useCallback(async (formData) => {
    setIsValidating({})
    setErrors({})
    
    const validationPromises = Object.keys(validationConfig).map(
      fieldName => validateField(fieldName, formData[fieldName], true)
    )
    
    const results = await Promise.all(validationPromises)
    const isValid = results.every(Boolean)
    
    return isValid
  }, [validationConfig, validateField])
  
  // 清除錯誤
  const clearError = useCallback((fieldName) => {
    setErrors(prev => ({
      ...prev,
      [fieldName]: null
    }))
  }, [])
  
  // 清除所有錯誤
  const clearAllErrors = useCallback(() => {
    setErrors({})
    Object.values(validationTimeouts.current).forEach(clearTimeout)
    validationTimeouts.current = {}
  }, [])
  
  return {
    errors,
    isValidating,
    validateField,
    validateForm,
    clearError,
    clearAllErrors
  }
}
```

## 註冊/登入表單驗證

### 1. 註冊表單配置
```javascript
// forms/auth/RegisterForm.jsx
import { useFormValidation } from '@/hooks/useFormValidation'

const registerValidationConfig = {
  email: {
    rules: ['required', 'email'],
    asyncRules: ['email_availability']
  },
  password: {
    rules: ['required', 'password_strength']
  },
  confirmPassword: {
    rules: ['required', { name: 'password_confirm', params: { password: 'password' } }]
  },
  phone: {
    rules: ['required', 'taiwanese_mobile']
  },
  name: {
    rules: ['required']
  },
  birthDate: {
    rules: ['required', { name: 'min_age', params: { minAge: 13 } }] // 後台可設定年齡
  },
  gender: {
    rules: ['required']
  },
  agreeToTerms: {
    rules: ['required']
  },
  agreeToPrivacy: {
    rules: ['required']
  },
  agreeToMarketing: {
    rules: [] // 非必填
  }
}

const RegisterForm = () => {
  const [form] = Form.useForm()
  const [formData, setFormData] = useState({})
  const [isSubmitting, setIsSubmitting] = useState(false)
  const { errors, isValidating, validateField, validateForm } = useFormValidation(registerValidationConfig)
  
  // 處理表單欄位變化
  const handleFieldChange = (fieldName, value) => {
    const newFormData = { ...formData, [fieldName]: value }
    setFormData(newFormData)
    
    // 特殊處理確認密碼
    if (fieldName === 'password' && formData.confirmPassword) {
      const updatedConfig = {
        ...registerValidationConfig,
        confirmPassword: {
          rules: ['required', { name: 'password_confirm', params: { password: value } }]
        }
      }
      validateField('confirmPassword', formData.confirmPassword)
    }
    
    // 離開欄位時驗證
    validateField(fieldName, value)
  }
  
  const handleSubmit = async () => {
    const isValid = await validateForm(formData)
    if (!isValid) return
    
    setIsSubmitting(true)
    try {
      await api.register(formData)
      notification.success({
        message: '註冊成功',
        description: '歡迎加入 MickeyShop Beauty！'
      })
      // 跳轉或處理成功邏輯
    } catch (error) {
      notification.error({
        message: '註冊失敗',
        description: error.message
      })
    } finally {
      setIsSubmitting(false)
    }
  }
  
  return (
    <Form form={form} layout="vertical" className={styles.registerForm}>
      {/* 電子郵件 */}
      <Form.Item 
        label="電子郵件"
        validateStatus={errors.email ? 'error' : ''}
        help={errors.email}
      >
        <Input
          type="email"
          placeholder="請輸入電子郵件"
          value={formData.email || ''}
          onChange={(e) => handleFieldChange('email', e.target.value)}
          onBlur={(e) => validateField('email', e.target.value)}
          suffix={isValidating.email ? <LoadingOutlined /> : null}
        />
      </Form.Item>
      
      {/* 密碼 */}
      <Form.Item 
        label="密碼"
        validateStatus={errors.password ? 'error' : ''}
        help={errors.password}
      >
        <Input.Password
          placeholder="請輸入密碼"
          value={formData.password || ''}
          onChange={(e) => handleFieldChange('password', e.target.value)}
          onBlur={(e) => validateField('password', e.target.value)}
        />
      </Form.Item>
      
      {/* 確認密碼 */}
      <Form.Item 
        label="確認密碼"
        validateStatus={errors.confirmPassword ? 'error' : ''}
        help={errors.confirmPassword}
      >
        <Input.Password
          placeholder="請再次輸入密碼"
          value={formData.confirmPassword || ''}
          onChange={(e) => handleFieldChange('confirmPassword', e.target.value)}
          onBlur={(e) => validateField('confirmPassword', e.target.value)}
        />
      </Form.Item>
      
      {/* 手機號碼 */}
      <Form.Item 
        label="手機號碼"
        validateStatus={errors.phone ? 'error' : ''}
        help={errors.phone}
      >
        <Input
          placeholder="09xxxxxxxx"
          value={formData.phone || ''}
          onChange={(e) => handleFieldChange('phone', e.target.value)}
          onBlur={(e) => validateField('phone', e.target.value)}
        />
      </Form.Item>
      
      {/* 姓名 */}
      <Form.Item 
        label="姓名"
        validateStatus={errors.name ? 'error' : ''}
        help={errors.name}
      >
        <Input
          placeholder="請輸入姓名"
          value={formData.name || ''}
          onChange={(e) => handleFieldChange('name', e.target.value)}
          onBlur={(e) => validateField('name', e.target.value)}
        />
      </Form.Item>
      
      {/* 生日 */}
      <Form.Item 
        label="生日"
        validateStatus={errors.birthDate ? 'error' : ''}
        help={errors.birthDate}
      >
        <DatePicker
          placeholder="請選擇生日"
          value={formData.birthDate ? dayjs(formData.birthDate) : null}
          onChange={(date) => handleFieldChange('birthDate', date?.format('YYYY-MM-DD'))}
          onBlur={() => validateField('birthDate', formData.birthDate)}
          style={{ width: '100%' }}
        />
      </Form.Item>
      
      {/* 性別 */}
      <Form.Item 
        label="性別"
        validateStatus={errors.gender ? 'error' : ''}
        help={errors.gender}
      >
        <Radio.Group
          value={formData.gender}
          onChange={(e) => handleFieldChange('gender', e.target.value)}
        >
          <Radio value="male">男性</Radio>
          <Radio value="female">女性</Radio>
          <Radio value="other">其他</Radio>
        </Radio.Group>
      </Form.Item>
      
      {/* 同意條款 */}
      <Form.Item 
        validateStatus={errors.agreeToTerms ? 'error' : ''}
        help={errors.agreeToTerms}
      >
        <Checkbox
          checked={formData.agreeToTerms || false}
          onChange={(e) => handleFieldChange('agreeToTerms', e.target.checked)}
        >
          我同意 <a href="/terms" target="_blank">服務條款</a>
        </Checkbox>
      </Form.Item>
      
      <Form.Item 
        validateStatus={errors.agreeToPrivacy ? 'error' : ''}
        help={errors.agreeToPrivacy}
      >
        <Checkbox
          checked={formData.agreeToPrivacy || false}
          onChange={(e) => handleFieldChange('agreeToPrivacy', e.target.checked)}
        >
          我同意 <a href="/privacy" target="_blank">隱私政策</a>
        </Checkbox>
      </Form.Item>
      
      <Form.Item>
        <Checkbox
          checked={formData.agreeToMarketing || false}
          onChange={(e) => handleFieldChange('agreeToMarketing', e.target.checked)}
        >
          我同意接收行銷資訊
        </Checkbox>
      </Form.Item>
      
      {/* 提交按鈕 */}
      <Form.Item>
        <Button 
          type="primary" 
          size="large" 
          block
          loading={isSubmitting}
          onClick={handleSubmit}
        >
          註冊帳號
        </Button>
      </Form.Item>
      
      {/* 第三方登入 */}
      <Divider>或使用以下方式註冊</Divider>
      
      <Space direction="vertical" style={{ width: '100%' }}>
        <Button 
          icon={<LineOutlined />}
          size="large"
          block
          onClick={handleLineLogin}
        >
          使用 LINE 註冊
        </Button>
        
        {/* Google 登入 - 功能保留，後台可開啟關閉 */}
        {systemConfig.googleLoginEnabled && (
          <Button 
            icon={<GoogleOutlined />}
            size="large"
            block
            onClick={handleGoogleLogin}
          >
            使用 Google 註冊
          </Button>
        )}
      </Space>
    </Form>
  )
}
```

### 2. 登入表單配置
```javascript
// forms/auth/LoginForm.jsx
const loginValidationConfig = {
  identifier: {
    rules: ['required']
  },
  password: {
    rules: ['required']
  }
}

const LoginForm = () => {
  const [formData, setFormData] = useState({})
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [rememberMe, setRememberMe] = useState(false)
  const { errors, validateField, validateForm } = useFormValidation(loginValidationConfig)
  
  const handleSubmit = async () => {
    const isValid = await validateForm(formData)
    if (!isValid) return
    
    setIsSubmitting(true)
    try {
      await api.login({
        ...formData,
        rememberMe
      })
      notification.success({
        message: '登入成功',
        description: '歡迎回來！'
      })
    } catch (error) {
      notification.error({
        message: '登入失敗',
        description: error.message
      })
    } finally {
      setIsSubmitting(false)
    }
  }
  
  return (
    <Form layout="vertical" className={styles.loginForm}>
      {/* 電子郵件或手機號碼 */}
      <Form.Item 
        label="電子郵件或手機號碼"
        validateStatus={errors.identifier ? 'error' : ''}
        help={errors.identifier}
      >
        <Input
          placeholder="請輸入電子郵件或手機號碼"
          value={formData.identifier || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, identifier: value }))
            validateField('identifier', value)
          }}
        />
      </Form.Item>
      
      {/* 密碼 */}
      <Form.Item 
        label="密碼"
        validateStatus={errors.password ? 'error' : ''}
        help={errors.password}
      >
        <Input.Password
          placeholder="請輸入密碼"
          value={formData.password || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, password: value }))
            validateField('password', value)
          }}
        />
      </Form.Item>
      
      {/* 記住我和忘記密碼 */}
      <Form.Item>
        <div className={styles.loginOptions}>
          <Checkbox 
            checked={rememberMe}
            onChange={(e) => setRememberMe(e.target.checked)}
          >
            記住我
          </Checkbox>
          <a href="/forgot-password">忘記密碼？</a>
        </div>
      </Form.Item>
      
      {/* 登入按鈕 */}
      <Form.Item>
        <Button 
          type="primary" 
          size="large" 
          block
          loading={isSubmitting}
          onClick={handleSubmit}
        >
          登入
        </Button>
      </Form.Item>
      
      {/* 第三方登入 */}
      <Divider>或使用以下方式登入</Divider>
      
      <Space direction="vertical" style={{ width: '100%' }}>
        <Button 
          icon={<LineOutlined />}
          size="large"
          block
          onClick={handleLineLogin}
        >
          使用 LINE 登入
        </Button>
        
        {systemConfig.googleLoginEnabled && (
          <Button 
            icon={<GoogleOutlined />}
            size="large"
            block
            onClick={handleGoogleLogin}
          >
            使用 Google 登入
          </Button>
        )}
      </Space>
    </Form>
  )
}
```

## 用戶個人資料表單驗證

### 1. 個人資料表單
```javascript
// forms/profile/ProfileForm.jsx
const profileValidationConfig = {
  name: {
    rules: [] // 不需要驗證姓名長度，不限制中文英文
  },
  email: {
    rules: ['required', 'email'],
    asyncRules: ['email_availability'] // 修改時需要驗證是否已被使用
  },
  phone: {
    rules: ['taiwanese_mobile']
  },
  birthDate: {
    rules: [{ name: 'min_age', params: { minAge: getSystemConfig('minAge') } }]
  },
  gender: {
    rules: []
  }
}

const ProfileForm = () => {
  const { user, updateProfile } = useAuthStore()
  const [formData, setFormData] = useState(user)
  const { errors, validateField, validateForm } = useFormValidation(profileValidationConfig)
  
  const handleFieldChange = (fieldName, value) => {
    setFormData(prev => ({ ...prev, [fieldName]: value }))
    validateField(fieldName, value)
    
    // 手機號碼修改提示
    if (fieldName === 'phone') {
      notification.info({
        message: '提醒',
        description: '此手機號碼將用於訂單配送聯絡',
        duration: 3
      })
    }
  }
  
  return (
    <Form layout="vertical">
      {/* 所有個人資料欄位都可以修改 */}
      
      {/* 頭像上傳 */}
      <Form.Item label="頭像">
        <AvatarUpload
          currentAvatar={formData.avatar}
          onUploadSuccess={(avatarUrl) => handleFieldChange('avatar', avatarUrl)}
        />
      </Form.Item>
      
      {/* 其他欄位... */}
    </Form>
  )
}
```

### 2. 密碼變更表單
```javascript
// forms/profile/PasswordChangeForm.jsx
const passwordChangeConfig = {
  currentPassword: {
    rules: ['required'],
    asyncRules: ['current_password_verification']
  },
  newPassword: {
    rules: ['required', 'password_strength']
  },
  confirmNewPassword: {
    rules: ['required', { name: 'password_confirm', params: { password: 'newPassword' } }]
  }
}

const PasswordChangeForm = () => {
  const [formData, setFormData] = useState({})
  const { errors, validateField, validateForm } = useFormValidation(passwordChangeConfig)
  
  const handleSubmit = async () => {
    const isValid = await validateForm(formData)
    if (!isValid) return
    
    try {
      await api.changePassword(formData)
      notification.success({
        message: '密碼變更成功',
        description: '請使用新密碼登入'
      })
      setFormData({}) // 清空表單
    } catch (error) {
      notification.error({
        message: '密碼變更失敗',
        description: error.message
      })
    }
  }
  
  return (
    <Form layout="vertical">
      {/* 需要輸入目前密碼確認 */}
      <Form.Item 
        label="目前密碼"
        validateStatus={errors.currentPassword ? 'error' : ''}
        help={errors.currentPassword}
      >
        <Input.Password
          placeholder="請輸入目前密碼"
          value={formData.currentPassword || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, currentPassword: value }))
            validateField('currentPassword', value)
          }}
        />
      </Form.Item>
      
      {/* 新密碼規則和註冊時一樣 */}
      <Form.Item 
        label="新密碼"
        validateStatus={errors.newPassword ? 'error' : ''}
        help={errors.newPassword}
      >
        <Input.Password
          placeholder="請輸入新密碼"
          value={formData.newPassword || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, newPassword: value }))
            validateField('newPassword', value)
          }}
        />
      </Form.Item>
      
      {/* 確認新密碼 */}
      <Form.Item 
        label="確認新密碼"
        validateStatus={errors.confirmNewPassword ? 'error' : ''}
        help={errors.confirmNewPassword}
      >
        <Input.Password
          placeholder="請再次輸入新密碼"
          value={formData.confirmNewPassword || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, confirmNewPassword: value }))
            validateField('confirmNewPassword', value)
          }}
        />
      </Form.Item>
      
      <Form.Item>
        <Button type="primary" onClick={handleSubmit}>
          變更密碼
        </Button>
      </Form.Item>
    </Form>
  )
}
```

### 3. 收件地址表單
```javascript
// forms/profile/AddressForm.jsx
const addressValidationConfig = {
  recipientName: {
    rules: ['required']
  },
  recipientPhone: {
    rules: ['required', 'taiwanese_mobile'] // 只驗證手機格式
  },
  postalCode: {
    rules: ['required', 'taiwanese_postal_code']
  },
  city: {
    rules: ['required']
  },
  district: {
    rules: ['required']
  },
  address: {
    rules: ['required']
  }
}

const AddressForm = ({ address, onSave, onCancel }) => {
  const [formData, setFormData] = useState(address || {})
  const { user } = useAuthStore()
  const { errors, validateField, validateForm } = useFormValidation(addressValidationConfig)
  
  // 與會員資料相同的快速填入
  const fillFromProfile = () => {
    setFormData({
      recipientName: user.name,
      recipientPhone: user.phone,
      // 如果用戶有預設地址，也可以填入
      ...user.defaultAddress
    })
  }
  
  return (
    <Form layout="vertical">
      <Form.Item>
        <Button type="link" onClick={fillFromProfile}>
          與會員資料相同
        </Button>
      </Form.Item>
      
      {/* 收件人姓名 */}
      <Form.Item 
        label="收件人姓名"
        validateStatus={errors.recipientName ? 'error' : ''}
        help={errors.recipientName}
      >
        <Input
          value={formData.recipientName || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, recipientName: value }))
            validateField('recipientName', value)
          }}
        />
      </Form.Item>
      
      {/* 收件人電話 - 只需手機格式 */}
      <Form.Item 
        label="收件人手機"
        validateStatus={errors.recipientPhone ? 'error' : ''}
        help={errors.recipientPhone}
      >
        <Input
          placeholder="09xxxxxxxx"
          value={formData.recipientPhone || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, recipientPhone: value }))
            validateField('recipientPhone', value)
          }}
        />
      </Form.Item>
      
      {/* 郵遞區號 */}
      <Form.Item 
        label="郵遞區號"
        validateStatus={errors.postalCode ? 'error' : ''}
        help={errors.postalCode}
      >
        <Input
          value={formData.postalCode || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, postalCode: value }))
            validateField('postalCode', value)
          }}
        />
      </Form.Item>
      
      {/* 縣市 - 搜尋式下拉式選單 */}
      <Form.Item 
        label="縣市"
        validateStatus={errors.city ? 'error' : ''}
        help={errors.city}
      >
        <Select
          showSearch
          placeholder="請選擇縣市"
          value={formData.city}
          onChange={(value) => {
            setFormData(prev => ({ ...prev, city: value, district: '' }))
            validateField('city', value)
          }}
          options={cityOptions}
        />
      </Form.Item>
      
      {/* 區域 - 搜尋式下拉式選單 */}
      <Form.Item 
        label="區域"
        validateStatus={errors.district ? 'error' : ''}
        help={errors.district}
      >
        <Select
          showSearch
          placeholder="請選擇區域"
          value={formData.district}
          onChange={(value) => {
            setFormData(prev => ({ ...prev, district: value }))
            validateField('district', value)
          }}
          options={getDistrictOptions(formData.city)}
        />
      </Form.Item>
      
      {/* 詳細地址 */}
      <Form.Item 
        label="詳細地址"
        validateStatus={errors.address ? 'error' : ''}
        help={errors.address}
      >
        <TextArea
          rows={3}
          value={formData.address || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, address: value }))
            validateField('address', value)
          }}
        />
      </Form.Item>
      
      {/* 設為預設地址 */}
      <Form.Item>
        <Checkbox
          checked={formData.isDefault || false}
          onChange={(e) => setFormData(prev => ({ ...prev, isDefault: e.target.checked }))}
        >
          設為預設地址
        </Checkbox>
      </Form.Item>
      
      <Form.Item>
        <Space>
          <Button onClick={onCancel}>取消</Button>
          <Button type="primary" onClick={async () => {
            const isValid = await validateForm(formData)
            if (isValid) {
              onSave(formData)
            }
          }}>
            保存地址
          </Button>
        </Space>
      </Form.Item>
    </Form>
  )
}
```

## 訂單管理表單驗證

### 1. 結帳表單
```javascript
// forms/checkout/CheckoutForm.jsx
const checkoutValidationConfig = {
  // 收件資訊與地址表單相同
  recipientName: {
    rules: [] // 收件人姓名不需要驗證
  },
  recipientPhone: {
    rules: ['required', 'taiwanese_mobile']
  },
  // 地址欄位...
  shippingMethod: {
    rules: ['required']
  },
  paymentMethod: {
    rules: ['required']
  }
}

const CheckoutForm = () => {
  const [formData, setFormData] = useState({})
  const [savedAddresses, setSavedAddresses] = useState([])
  const { user } = useAuthStore()
  const { errors, validateField, validateForm } = useFormValidation(checkoutValidationConfig)
  
  // 從用戶儲存的收件地址選擇
  const handleAddressSelect = (address) => {
    setFormData(prev => ({
      ...prev,
      ...address
    }))
  }
  
  return (
    <div className={styles.checkoutForm}>
      {/* 收件地址選擇 */}
      <div className={styles.addressSelection}>
        <h4>選擇收件地址</h4>
        {savedAddresses.map(address => (
          <div key={address.id} className={styles.addressCard}>
            <Radio
              checked={formData.selectedAddressId === address.id}
              onChange={() => handleAddressSelect(address)}
            >
              {address.recipientName} - {address.recipientPhone}
              <br />
              {address.city}{address.district}{address.address}
            </Radio>
          </div>
        ))}
        
        <Button type="dashed" onClick={() => setShowNewAddressForm(true)}>
          新增收件地址
        </Button>
      </div>
      
      {/* 配送方式選擇 - 綠界物流 */}
      <Form.Item 
        label="配送方式"
        validateStatus={errors.shippingMethod ? 'error' : ''}
        help={errors.shippingMethod}
      >
        <Radio.Group
          value={formData.shippingMethod}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, shippingMethod: value }))
            validateField('shippingMethod', value)
          }}
        >
          <Radio value="home_delivery">宅配到府</Radio>
          <Radio value="convenience_store">超商取貨</Radio>
          <Radio value="post_office">郵局取貨</Radio>
        </Radio.Group>
      </Form.Item>
      
      {/* 發票設定 - 電子發票（功能保留） */}
      {systemConfig.invoiceEnabled && (
        <Form.Item label="發票設定">
          <Radio.Group
            value={formData.invoiceType}
            onChange={(e) => setFormData(prev => ({ ...prev, invoiceType: e.target.value }))}
          >
            <Radio value="electronic">電子發票</Radio>
          </Radio.Group>
        </Form.Item>
      )}
      
      {/* 付款方式選擇 */}
      <Form.Item 
        label="付款方式"
        validateStatus={errors.paymentMethod ? 'error' : ''}
        help={errors.paymentMethod}
      >
        <Radio.Group
          value={formData.paymentMethod}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, paymentMethod: value }))
            validateField('paymentMethod', value)
          }}
        >
          <Radio value="line_pay">LINE Pay</Radio>
          <Radio value="ecpay">ECPay (綠界)</Radio>
        </Radio.Group>
      </Form.Item>
    </div>
  )
}
```

### 2. 退換貨申請表單
```javascript
// forms/order/RefundForm.jsx
const refundValidationConfig = {
  reason: {
    rules: ['required']
  },
  description: {
    rules: ['required']
  },
  images: {
    rules: [] // 照片選填，無格式大小限制
  }
}

const RefundForm = ({ order, onSubmit }) => {
  const [formData, setFormData] = useState({})
  const [uploadedImages, setUploadedImages] = useState([])
  const { errors, validateField, validateForm } = useFormValidation(refundValidationConfig)
  
  const handleSubmit = async () => {
    const isValid = await validateForm(formData)
    if (!isValid) return
    
    const refundData = {
      ...formData,
      orderId: order.id,
      images: uploadedImages
    }
    
    await onSubmit(refundData)
  }
  
  return (
    <Form layout="vertical">
      {/* 退換貨原因 */}
      <Form.Item 
        label="退換貨原因"
        validateStatus={errors.reason ? 'error' : ''}
        help={errors.reason}
      >
        <Select
          placeholder="請選擇退換貨原因"
          value={formData.reason}
          onChange={(value) => {
            setFormData(prev => ({ ...prev, reason: value }))
            validateField('reason', value)
          }}
          options={[
            { value: 'defective', label: '商品瑕疵' },
            { value: 'wrong_item', label: '寄錯商品' },
            { value: 'not_as_described', label: '商品與描述不符' },
            { value: 'personal_reason', label: '個人因素' },
            { value: 'other', label: '其他' }
          ]}
        />
      </Form.Item>
      
      {/* 詳細說明 */}
      <Form.Item 
        label="詳細說明"
        validateStatus={errors.description ? 'error' : ''}
        help={errors.description}
      >
        <TextArea
          rows={4}
          placeholder="請詳細說明退換貨原因"
          value={formData.description || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, description: value }))
            validateField('description', value)
          }}
        />
      </Form.Item>
      
      {/* 商品照片上傳 */}
      <Form.Item label="商品照片（選填）">
        <Upload
          listType="picture-card"
          fileList={uploadedImages}
          onChange={({ fileList }) => setUploadedImages(fileList)}
          beforeUpload={() => false}
          accept="*" // 無格式限制
        >
          <div>
            <PlusOutlined />
            <div style={{ marginTop: 8 }}>上傳照片</div>
          </div>
        </Upload>
        <div className={styles.uploadHint}>
          無檔案格式和大小限制
        </div>
      </Form.Item>
      
      <Form.Item>
        <Button type="primary" onClick={handleSubmit}>
          提交申請
        </Button>
      </Form.Item>
    </Form>
  )
}
```

## 評價表單驗證

### 1. 評價表單配置
```javascript
// forms/review/ReviewForm.jsx
const reviewValidationConfig = {
  rating: {
    rules: [] // 評分不是必填
  },
  content: {
    rules: [], // 評價文字內容不是必填
    asyncRules: ['profanity_filter'] // 需要過濾敏感詞彙
  },
  images: {
    rules: [] // 圖片選填，最多3張，無格式大小限制
  }
}

const ReviewForm = ({ product, onSubmit, onCancel }) => {
  const [formData, setFormData] = useState({})
  const [uploadedImages, setUploadedImages] = useState([])
  const [isSubmitting, setIsSubmitting] = useState(false)
  const { errors, validateField, validateForm } = useFormValidation(reviewValidationConfig)
  
  // 驗證用戶是否購買過商品
  useEffect(() => {
    const verifyPurchase = async () => {
      try {
        const response = await api.checkPurchaseHistory(product.id)
        if (!response.hasPurchased) {
          notification.error({
            message: '無法評價',
            description: '只有購買過的用戶才能評價此商品'
          })
          onCancel()
        }
      } catch (error) {
        notification.error({
          message: '驗證失敗',
          description: '無法驗證購買記錄'
        })
        onCancel()
      }
    }
    
    verifyPurchase()
  }, [product.id])
  
  const handleSubmit = async () => {
    const isValid = await validateForm(formData)
    if (!isValid) return
    
    setIsSubmitting(true)
    try {
      const reviewData = {
        productId: product.id,
        rating: formData.rating || 0, // 允許不評分
        content: formData.content || '', // 允許空內容
        images: uploadedImages.slice(0, 3) // 最多3張
      }
      
      await onSubmit(reviewData)
      
      notification.success({
        message: '評價提交成功',
        description: '感謝您的評價！評價可在7天內修改。'
      })
      
    } catch (error) {
      notification.error({
        message: '提交失敗',
        description: error.message
      })
    } finally {
      setIsSubmitting(false)
    }
  }
  
  return (
    <Form layout="vertical" className={styles.reviewForm}>
      {/* 評分 - 不是必填 */}
      <Form.Item label="評分（選填）">
        <Rate
          value={formData.rating || 0}
          onChange={(value) => {
            setFormData(prev => ({ ...prev, rating: value }))
            validateField('rating', value)
          }}
        />
      </Form.Item>
      
      {/* 評價內容 - 不是必填，不需要字數限制 */}
      <Form.Item 
        label="評價內容（選填）"
        validateStatus={errors.content ? 'error' : ''}
        help={errors.content}
      >
        <TextArea
          rows={4}
          placeholder="分享您的使用心得..."
          value={formData.content || ''}
          onChange={(e) => {
            const value = e.target.value
            setFormData(prev => ({ ...prev, content: value }))
            validateField('content', value)
          }}
          showCount={false} // 不顯示字數計數
        />
      </Form.Item>
      
      {/* 評價圖片 - 選填，最多3張，無格式大小限制 */}
      <Form.Item label="評價圖片（選填，最多3張）">
        <Upload
          listType="picture-card"
          fileList={uploadedImages}
          onChange={({ fileList }) => setUploadedImages(fileList)}
          beforeUpload={() => false}
          maxCount={3}
          accept="*" // 無格式限制
        >
          {uploadedImages.length < 3 && (
            <div>
              <PlusOutlined />
              <div style={{ marginTop: 8 }}>上傳圖片</div>
            </div>
          )}
        </Upload>
        <div className={styles.uploadHint}>
          無檔案格式和大小限制，最多上傳3張圖片
        </div>
      </Form.Item>
      
      {/* 提交按鈕 */}
      <Form.Item>
        <Space>
          <Button onClick={onCancel}>取消</Button>
          <Button 
            type="primary" 
            loading={isSubmitting}
            onClick={handleSubmit}
          >
            提交評價
          </Button>
        </Space>
      </Form.Item>
    </Form>
  )
}
```

## 統一錯誤處理

### 1. 錯誤顯示組件
```jsx
// components/FormErrorDisplay/index.jsx
const FormErrorDisplay = ({ error, field }) => {
  if (!error) return null
  
  return (
    <div className={styles.errorDisplay}>
      <ExclamationCircleOutlined className={styles.errorIcon} />
      <span className={styles.errorMessage}>{error}</span>
    </div>
  )
}
```

### 2. 表單樣式
```scss
// styles/FormValidation.module.scss
.errorDisplay {
  display: flex;
  align-items: center;
  gap: 4px;
  color: #ff4d4f;
  font-size: 12px;
  margin-top: 4px;
  
  .errorIcon {
    font-size: 12px;
  }
  
  .errorMessage {
    flex: 1;
  }
}

// 統一的表單驗證狀態樣式
.ant-form-item-has-error {
  .ant-input,
  .ant-select-selector,
  .ant-picker {
    border-color: #ff4d4f !important;
    box-shadow: 0 0 0 2px rgba(255, 77, 79, 0.2) !important;
  }
}

// 驗證中狀態
.validating {
  position: relative;
  
  &::after {
    content: '';
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 16px;
    height: 16px;
    border: 2px solid #d9d9d9;
    border-top: 2px solid #1890ff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
}

@keyframes spin {
  0% { transform: translateY(-50%) rotate(0deg); }
  100% { transform: translateY(-50%) rotate(360deg); }
}
```

## 驗證配置管理

### 1. 系統配置整合
```javascript
// utils/validation/systemConfig.js
export const getSystemConfig = async (key) => {
  try {
    const response = await api.getSystemConfig(key)
    return response.value
  } catch (error) {
    // 使用預設值
    const defaults = {
      minAge: 13,
      googleLoginEnabled: false,
      smsVerificationEnabled: false,
      invoiceEnabled: false
    }
    return defaults[key]
  }
}

// 動態更新驗證規則
export const updateValidationRules = async () => {
  const minAge = await getSystemConfig('minAge')
  
  validationEngine.registerRule('min_age', (value, params) => {
    if (!value) return true
    const { minAge: requiredAge = minAge } = params
    const birthDate = new Date(value)
    const today = new Date()
    let age = today.getFullYear() - birthDate.getFullYear()
    const monthDiff = today.getMonth() - birthDate.getMonth()
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--
    }
    
    return age >= requiredAge
  }, `年齡需滿 ${minAge} 歲`)
}
```

這個表單驗證系統文檔涵蓋了您討論的所有表單驗證需求，包括統一的驗證引擎、各種表單的具體配置、錯誤處理和系統整合。