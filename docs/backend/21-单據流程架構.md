# 单據流程架構 (Document Workflow Architecture)

## 1. 概述

单據流程架構是整個 MickeyShop Beauty 系統的核心業務流程管理系統，負責管理所有業務单據的生命週期，包括訂單、採購单、入庫单、出庫单、退貨单、盤點单等各類业務单據的建立、審核、執行、完成等流程。

### 1.1 核心功能
- 统一单據管理與流程控制
- 多層級審核工作流
- 单據狀態追蹤與轉換
- 自動化业務規則執行
- 单據關聯與依賴管理
- 异常處理與回滾機制
- 單據數據整合與分析

## 2. 单據類型體系

### 2.1 销售相關单據
```typescript
enum SalesDocumentType {
  // 訂單類
  SALES_ORDER = 'sales_order',           // 銷售訂單
  SALES_RETURN = 'sales_return',         // 銷售退貨单
  
  // 出貨類  
  DELIVERY_ORDER = 'delivery_order',     // 出貨单
  SHIPPING_ORDER = 'shipping_order',     // 發貨单
  PICKUP_ORDER = 'pickup_order',         // 取貨单
  
  // 發票類
  SALES_INVOICE = 'sales_invoice',       // 銷售發票
  CREDIT_NOTE = 'credit_note',           // 貸項通知单
  DEBIT_NOTE = 'debit_note',             // 借項通知单
  
  // 收款類
  PAYMENT_RECEIPT = 'payment_receipt',   // 收款单
  REFUND_RECEIPT = 'refund_receipt',     // 退款单
}
```

### 2.2 採購相關单據
```typescript
enum PurchaseDocumentType {
  // 採購類
  PURCHASE_REQUEST = 'purchase_request',     // 採購申請单
  PURCHASE_ORDER = 'purchase_order',         // 採購訂單
  PURCHASE_RETURN = 'purchase_return',       // 採購退貨单
  
  // 入庫類
  GOODS_RECEIPT = 'goods_receipt',           // 收貨单
  QUALITY_INSPECTION = 'quality_inspection', // 品質檢驗单
  
  // 付款類
  PURCHASE_INVOICE = 'purchase_invoice',     // 採購發票
  PAYMENT_VOUCHER = 'payment_voucher',       // 付款单
  ADVANCE_PAYMENT = 'advance_payment',       // 預付款单
}
```

### 2.3 庫存相關单據
```typescript
enum InventoryDocumentType {
  // 入庫類
  STOCK_IN = 'stock_in',                     // 入庫单
  STOCK_TRANSFER_IN = 'stock_transfer_in',   // 調撥入庫单
  PRODUCTION_IN = 'production_in',           // 生產入庫单
  ADJUSTMENT_IN = 'adjustment_in',           // 調整入庫单
  
  // 出庫類
  STOCK_OUT = 'stock_out',                   // 出庫单
  STOCK_TRANSFER_OUT = 'stock_transfer_out', // 調撥出庫单
  SALES_OUT = 'sales_out',                   // 銷售出庫单
  ADJUSTMENT_OUT = 'adjustment_out',         // 調整出庫单
  
  // 盤點類
  STOCK_COUNT = 'stock_count',               // 盤點单
  STOCK_ADJUSTMENT = 'stock_adjustment',     // 盤點調整单
  
  // 調撥類
  STOCK_TRANSFER = 'stock_transfer',         // 調撥单
  INTER_WAREHOUSE_TRANSFER = 'inter_warehouse_transfer', // 倉庫間調撥
}
```

### 2.4 財務相關单據
```typescript
enum FinancialDocumentType {
  // 會計憑證
  JOURNAL_ENTRY = 'journal_entry',           // 記帳憑證
  CASH_RECEIPT = 'cash_receipt',             // 現金收據
  CASH_PAYMENT = 'cash_payment',             // 現金支付单
  BANK_RECEIPT = 'bank_receipt',             // 銀行收款单
  BANK_PAYMENT = 'bank_payment',             // 銀行付款单
  
  // 對帳類
  BANK_RECONCILIATION = 'bank_reconciliation', // 銀行對帳单
  ACCOUNT_RECONCILIATION = 'account_reconciliation', // 帳戶對帳单
  
  // 預算類
  BUDGET_ALLOCATION = 'budget_allocation',    // 預算分配单
  BUDGET_ADJUSTMENT = 'budget_adjustment',    // 預算調整单
  
  // 費用類
  EXPENSE_CLAIM = 'expense_claim',            // 費用申請单
  EXPENSE_REIMBURSEMENT = 'expense_reimbursement', // 費用報銷单
}
```

## 3. 单據狀態管理

### 3.1 通用狀態定義
```typescript
enum DocumentStatus {
  // 基礎狀態
  DRAFT = 'draft',                    // 草稿
  SUBMITTED = 'submitted',            // 已提交
  
  // 審核狀態  
  PENDING_APPROVAL = 'pending_approval',   // 待審核
  APPROVED = 'approved',              // 已審核
  REJECTED = 'rejected',              // 已拒絕
  
  // 執行狀態
  CONFIRMED = 'confirmed',            // 已確認
  IN_PROGRESS = 'in_progress',        // 執行中
  PARTIALLY_COMPLETED = 'partially_completed', // 部分完成
  COMPLETED = 'completed',            // 已完成
  
  // 异常狀態
  CANCELLED = 'cancelled',            // 已取消
  SUSPENDED = 'suspended',            // 已暫停
  ERROR = 'error',                    // 錯誤
  EXPIRED = 'expired',                // 已過期
  
  // 關閉狀態
  CLOSED = 'closed',                  // 已結案
  ARCHIVED = 'archived',              // 已歸檔
}
```

### 3.2 狀態轉換規則
```typescript
interface DocumentStateTransition {
  fromStatus: DocumentStatus;
  toStatus: DocumentStatus;
  conditions: TransitionCondition[];
  permissions: string[];
  autoTransition: boolean;
  requiresApproval: boolean;
  notificationRules: NotificationRule[];
}

interface TransitionCondition {
  field: string;
  operator: 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'contains';
  value: any;
  errorMessage: string;
}

// 訂單狀態轉換規則範例
const SalesOrderTransitions: DocumentStateTransition[] = [
  {
    fromStatus: DocumentStatus.DRAFT,
    toStatus: DocumentStatus.SUBMITTED,
    conditions: [
      { 
        field: 'customer_id', 
        operator: 'not_equals', 
        value: null, 
        errorMessage: '必須選擇客戶' 
      },
      { 
        field: 'order_items.length', 
        operator: 'greater_than', 
        value: 0, 
        errorMessage: '訂單必須包含至少一個商品' 
      },
      { 
        field: 'total_amount', 
        operator: 'greater_than', 
        value: 0, 
        errorMessage: '訂單金額必須大於0' 
      }
    ],
    permissions: ['sales_order.submit'],
    autoTransition: false,
    requiresApproval: false,
    notificationRules: [
      {
        recipients: ['sales_manager'],
        template: 'new_order_submitted',
        channels: ['email', 'system']
      }
    ]
  },
  {
    fromStatus: DocumentStatus.SUBMITTED,
    toStatus: DocumentStatus.PENDING_APPROVAL,
    conditions: [
      { 
        field: 'total_amount', 
        operator: 'greater_than', 
        value: 10000, 
        errorMessage: '金額超過10,000需要審核' 
      }
    ],
    permissions: ['sales_order.review'],
    autoTransition: true,
    requiresApproval: true,
    notificationRules: [
      {
        recipients: ['finance_manager'],
        template: 'order_pending_approval',
        channels: ['email', 'sms']
      }
    ]
  },
  {
    fromStatus: DocumentStatus.PENDING_APPROVAL,
    toStatus: DocumentStatus.APPROVED,
    conditions: [],
    permissions: ['sales_order.approve'],
    autoTransition: false,
    requiresApproval: false,
    notificationRules: [
      {
        recipients: ['order_creator', 'warehouse_manager'],
        template: 'order_approved',
        channels: ['email', 'system']
      }
    ]
  },
  {
    fromStatus: DocumentStatus.APPROVED,
    toStatus: DocumentStatus.CONFIRMED,
    conditions: [
      { 
        field: 'payment_status', 
        operator: 'equals', 
        value: 'paid', 
        errorMessage: '需要付款後才能確認' 
      },
      { 
        field: 'inventory_reserved', 
        operator: 'equals', 
        value: true, 
        errorMessage: '庫存未預留' 
      }
    ],
    permissions: ['sales_order.confirm'],
    autoTransition: true,
    requiresApproval: false,
    notificationRules: [
      {
        recipients: ['warehouse_staff'],
        template: 'order_confirmed_prepare_shipping',
        channels: ['system', 'mobile']
      }
    ]
  }
];
```

## 4. 单據數據結構

### 4.1 单據基本結構
```typescript
interface BaseDocument {
  // 基本資訊
  documentId: string;
  documentType: string;
  documentNumber: string;
  version: number;
  
  // 狀態資訊
  status: DocumentStatus;
  statusHistory: DocumentStatusHistory[];
  
  // 業務資訊
  businessDate: Date;
  effectiveDate: Date;
  expiryDate?: Date;
  
  // 金額資訊
  currency: string;
  exchangeRate: number;
  subtotal: number;
  taxAmount: number;
  discountAmount: number;
  totalAmount: number;
  
  // 關聯資訊
  parentDocumentId?: string;
  sourceDocumentId?: string;
  relatedDocuments: DocumentRelation[];
  
  // 審核資訊
  approvalStatus: ApprovalStatus;
  currentApprovalLevel: number;
  approvalHistory: ApprovalHistory[];
  
  // 附加資訊
  description?: string;
  internalNotes?: string;
  customerNotes?: string;
  attachments: DocumentAttachment[];
  customFields: Record<string, any>;
  
  // 系統資訊
  companyId: string;
  branchId?: string;
  departmentId?: string;
  
  // 時間戳
  createdAt: Date;
  updatedAt: Date;
  createdBy: string;
  updatedBy: string;
  
  // 版本控制
  isLatestVersion: boolean;
  versionHistory: DocumentVersion[];
}

interface DocumentStatusHistory {
  historyId: string;
  fromStatus: DocumentStatus;
  toStatus: DocumentStatus;
  changedAt: Date;
  changedBy: string;
  reason?: string;
  comments?: string;
  systemGenerated: boolean;
}

interface DocumentRelation {
  relationId: string;
  relationType: DocumentRelationType;
  relatedDocumentId: string;
  relatedDocumentType: string;
  relatedDocumentNumber: string;
  relationStatus: 'active' | 'cancelled';
  createdAt: Date;
}

enum DocumentRelationType {
  PARENT = 'parent',           // 父單據
  CHILD = 'child',             // 子單據
  SOURCE = 'source',           // 來源單據
  TARGET = 'target',           // 目標單據
  REFERENCE = 'reference',     // 參考單據
  REPLACEMENT = 'replacement', // 替換單據
  REVERSE = 'reverse',         // 沖銷單據
}
```

### 4.2 销售訂單結構
```typescript
interface SalesOrder extends BaseDocument {
  // 客戶資訊
  customerId: string;
  customerCode: string;
  customerName: string;
  customerType: CustomerType;
  
  // 聯絡資訊
  contactPerson?: string;
  contactPhone?: string;
  contactEmail?: string;
  
  // 地址資訊
  billingAddress: Address;
  shippingAddress: Address;
  
  // 訂單詳情
  orderItems: SalesOrderItem[];
  
  // 付款資訊
  paymentTerms: PaymentTerms;
  paymentMethod: PaymentMethod;
  paymentStatus: PaymentStatus;
  paymentDueDate?: Date;
  
  // 出貨資訊
  requestedDeliveryDate?: Date;
  promisedDeliveryDate?: Date;
  shippingMethod: ShippingMethod;
  shippingStatus: ShippingStatus;
  
  // 優惠資訊
  promotions: AppliedPromotion[];
  discountType: DiscountType;
  discountValue: number;
  couponCodes: string[];
  
  // 稅務資訊
  taxExempt: boolean;
  taxExemptReason?: string;
  taxCalculation: TaxCalculation[];
  
  // 銷售資訊
  salesPersonId?: string;
  salesChannelId?: string;
  sourceChannel: SourceChannel;
  
  // 特殊標記
  isRush: boolean;
  isDropship: boolean;
  isGift: boolean;
  giftMessage?: string;
  
  // 風險控制
  riskScore: number;
  riskFlags: RiskFlag[];
  requiresManualReview: boolean;
}

interface SalesOrderItem {
  itemId: string;
  lineNumber: number;
  productId: string;
  productCode: string;
  productName: string;
  productVariantId?: string;
  
  // 數量與單位
  orderedQuantity: number;
  deliveredQuantity: number;
  unit: string;
  
  // 價格資訊
  unitPrice: number;
  discountPercent: number;
  discountAmount: number;
  netPrice: number;
  lineTotal: number;
  
  // 稅務
  taxCode: string;
  taxRate: number;
  taxAmount: number;
  
  // 庫存資訊
  availableQuantity: number;
  reservedQuantity: number;
  backorderQuantity: number;
  
  // 狀態
  itemStatus: OrderItemStatus;
  deliveryStatus: DeliveryStatus;
  
  // 特殊處理
  isGift: boolean;
  giftWrapRequired: boolean;
  specialInstructions?: string;
  
  // 供應商資訊（代發貨）
  supplierId?: string;
  supplierCode?: string;
  supplierProductCode?: string;
  
  // 序列號管理
  requiresSerialNumbers: boolean;
  serialNumbers: string[];
}
```

### 4.3 採購訂單結構
```typescript
interface PurchaseOrder extends BaseDocument {
  // 供應商資訊
  supplierId: string;
  supplierCode: string;
  supplierName: string;
  supplierType: SupplierType;
  
  // 聯絡資訊
  contactPerson?: string;
  contactPhone?: string;
  contactEmail?: string;
  
  // 地址資訊
  supplierAddress: Address;
  deliveryAddress: Address;
  billingAddress: Address;
  
  // 採購詳情
  purchaseItems: PurchaseOrderItem[];
  
  // 採購類型
  purchaseType: PurchaseType;
  purchaseCategory: PurchaseCategory;
  urgencyLevel: UrgencyLevel;
  
  // 交貨資訊
  requestedDeliveryDate: Date;
  confirmedDeliveryDate?: Date;
  deliveryTerms: DeliveryTerms;
  shippingMethod: ShippingMethod;
  
  // 付款資訊
  paymentTerms: PaymentTerms;
  paymentMethod: PaymentMethod;
  paymentDueDate?: Date;
  advancePaymentRequired: boolean;
  advancePaymentPercent?: number;
  
  // 合約資訊
  contractId?: string;
  contractNumber?: string;
  frameworkAgreement?: boolean;
  
  // 品質要求
  qualityRequirements: QualityRequirement[];
  inspectionRequired: boolean;
  inspectionCriteria?: string;
  
  // 預算控制
  budgetId?: string;
  budgetLineItem?: string;
  budgetRemaining?: number;
  requiresBudgetApproval: boolean;
  
  // 採購員資訊
  buyerId: string;
  buyerName: string;
  departmentId: string;
  
  // 特殊條款
  specialTerms?: string;
  warranties: WarrantyTerm[];
  penalties: PenaltyClause[];
}

interface PurchaseOrderItem {
  itemId: string;
  lineNumber: number;
  
  // 商品資訊
  productId?: string;
  productCode?: string;
  productName: string;
  productDescription?: string;
  supplierProductCode?: string;
  
  // 規格資訊
  specifications: ProductSpecification[];
  brandRequired?: string;
  modelRequired?: string;
  
  // 數量與單位
  orderedQuantity: number;
  receivedQuantity: number;
  unit: string;
  packageUnit?: string;
  packageQuantity?: number;
  
  // 價格資訊
  unitPrice: number;
  discountPercent: number;
  discountAmount: number;
  netPrice: number;
  lineTotal: number;
  
  // 稅務
  taxCode: string;
  taxRate: number;
  taxAmount: number;
  
  // 交貨要求
  requestedDeliveryDate: Date;
  confirmedDeliveryDate?: Date;
  partialDeliveryAllowed: boolean;
  
  // 狀態
  itemStatus: PurchaseItemStatus;
  receiptStatus: ReceiptStatus;
  
  // 品質控制
  qualityGrade?: string;
  inspectionRequired: boolean;
  acceptanceCriteria?: string;
  
  // 成本中心
  costCenterId?: string;
  projectId?: string;
  glAccount?: string;
  
  // 庫存資訊
  targetWarehouseId: string;
  targetLocationId?: string;
  
  // 替代商品
  substitutesAllowed: boolean;
  alternativeProducts: AlternativeProduct[];
}
```

## 5. 工作流程引擎

### 5.1 工作流定義
```typescript
interface WorkflowDefinition {
  workflowId: string;
  name: string;
  description?: string;
  version: string;
  isActive: boolean;
  
  // 適用範圍
  applicableDocumentTypes: string[];
  applicableConditions: WorkflowCondition[];
  
  // 流程節點
  nodes: WorkflowNode[];
  transitions: WorkflowTransition[];
  
  // 流程設定
  allowParallelExecution: boolean;
  maxExecutionTime?: number;
  escalationRules: EscalationRule[];
  
  // 通知設定
  notificationTemplates: NotificationTemplate[];
  
  // 變數定義
  variables: WorkflowVariable[];
  
  // 建立資訊
  createdAt: Date;
  createdBy: string;
  updatedAt: Date;
  updatedBy: string;
}

interface WorkflowNode {
  nodeId: string;
  nodeType: WorkflowNodeType;
  name: string;
  description?: string;
  
  // 節點配置
  configuration: NodeConfiguration;
  
  // 人員指派
  assignmentType: AssignmentType;
  assignmentRules: AssignmentRule[];
  
  // 時間限制
  slaMinutes?: number;
  warningMinutes?: number;
  escalationMinutes?: number;
  
  // 自動化配置
  autoExecute: boolean;
  autoExecuteConditions?: AutoExecuteCondition[];
  
  // 位置資訊（流程圖）
  position: NodePosition;
}

enum WorkflowNodeType {
  START = 'start',                    // 開始節點
  END = 'end',                        // 結束節點
  TASK = 'task',                      // 任務節點
  APPROVAL = 'approval',              // 審批節點
  DECISION = 'decision',              // 決策節點
  PARALLEL_GATEWAY = 'parallel_gateway', // 並行網關
  EXCLUSIVE_GATEWAY = 'exclusive_gateway', // 排他網關
  INCLUSIVE_GATEWAY = 'inclusive_gateway', // 包含網關
  SERVICE_TASK = 'service_task',      // 服務任務
  USER_TASK = 'user_task',            // 用戶任務
  TIMER = 'timer',                    // 計時器
  MESSAGE = 'message',                // 消息節點
  SUBPROCESS = 'subprocess',          // 子流程
}

enum AssignmentType {
  USER = 'user',                      // 指定用戶
  ROLE = 'role',                      // 指定角色
  GROUP = 'group',                    // 指定群組
  DEPARTMENT = 'department',          // 指定部門
  DYNAMIC = 'dynamic',                // 動態指派
  CREATOR = 'creator',                // 單據建立者
  MANAGER = 'manager',                // 建立者的主管
  CUSTOM_RULE = 'custom_rule',        // 自定義規則
}
```

### 5.2 審核節點配置
```typescript
interface ApprovalNodeConfiguration extends NodeConfiguration {
  // 審核設定
  approvalType: ApprovalType;
  requiredApprovals: number;
  allowDelegation: boolean;
  allowReassignment: boolean;
  
  // 決策選項
  approvalOptions: ApprovalOption[];
  defaultOption?: string;
  requireComments: boolean;
  
  // 條件設定
  approvalConditions: ApprovalCondition[];
  skipConditions: SkipCondition[];
  
  // 通知設定
  notifyOnAssignment: boolean;
  reminderIntervals: number[]; // 提醒間隔（分鐘）
  escalationLevels: EscalationLevel[];
}

enum ApprovalType {
  SINGLE = 'single',                  // 單人審批
  MULTIPLE = 'multiple',              // 多人審批
  SEQUENTIAL = 'sequential',          // 順序審批
  PARALLEL = 'parallel',              // 並行審批
  MAJORITY = 'majority',              // 多數決
  UNANIMOUS = 'unanimous',            // 一致通過
  FIRST_RESPONSE = 'first_response',  // 首位回應
  HIERARCHICAL = 'hierarchical',      // 階層式審批
}

interface ApprovalOption {
  optionId: string;
  name: string;
  displayName: string;
  description?: string;
  resultStatus: DocumentStatus;
  nextNodeId?: string;
  requiresReason: boolean;
  color?: string;
  icon?: string;
  order: number;
}

// 標準審核選項
const StandardApprovalOptions: ApprovalOption[] = [
  {
    optionId: 'approve',
    name: 'approve',
    displayName: '核准',
    resultStatus: DocumentStatus.APPROVED,
    requiresReason: false,
    color: 'green',
    icon: 'check',
    order: 1
  },
  {
    optionId: 'reject',
    name: 'reject', 
    displayName: '駁回',
    resultStatus: DocumentStatus.REJECTED,
    requiresReason: true,
    color: 'red',
    icon: 'times',
    order: 2
  },
  {
    optionId: 'hold',
    name: 'hold',
    displayName: '暫緩',
    resultStatus: DocumentStatus.SUSPENDED,
    requiresReason: true,
    color: 'orange',
    icon: 'pause',
    order: 3
  },
  {
    optionId: 'return',
    name: 'return',
    displayName: '退回修改',
    resultStatus: DocumentStatus.DRAFT,
    requiresReason: true,
    color: 'blue',
    icon: 'undo',
    order: 4
  },
  {
    optionId: 'delegate',
    name: 'delegate',
    displayName: '委派',
    resultStatus: DocumentStatus.PENDING_APPROVAL,
    requiresReason: false,
    color: 'purple',
    icon: 'user-plus',
    order: 5
  }
];
```

### 5.3 工作流執行引擎
```typescript
class WorkflowEngine {
  async startWorkflow(documentId: string, workflowId: string, initiatedBy: string): Promise<WorkflowInstance> {
    // 1. 驗證文檔和工作流
    const document = await this.documentService.getDocument(documentId);
    const workflow = await this.workflowService.getWorkflow(workflowId);
    
    if (!this.validateWorkflowApplicability(document, workflow)) {
      throw new Error('工作流不適用於此文檔類型');
    }

    // 2. 建立工作流實例
    const instance: WorkflowInstance = {
      instanceId: generateId(),
      workflowId,
      documentId,
      documentType: document.documentType,
      status: WorkflowInstanceStatus.RUNNING,
      startedAt: new Date(),
      startedBy: initiatedBy,
      currentNodes: [],
      variables: new Map(),
      executionHistory: []
    };

    // 3. 找到開始節點
    const startNode = workflow.nodes.find(node => node.nodeType === WorkflowNodeType.START);
    if (!startNode) {
      throw new Error('工作流缺少開始節點');
    }

    // 4. 執行開始節點
    await this.executeNode(instance, startNode, workflow);

    // 5. 保存工作流實例
    await this.workflowInstanceRepository.save(instance);

    return instance;
  }

  async executeNode(instance: WorkflowInstance, node: WorkflowNode, workflow: WorkflowDefinition): Promise<void> {
    const execution: NodeExecution = {
      executionId: generateId(),
      instanceId: instance.instanceId,
      nodeId: node.nodeId,
      status: NodeExecutionStatus.RUNNING,
      startedAt: new Date(),
      assignedUsers: [],
      results: []
    };

    instance.executionHistory.push(execution);

    try {
      switch (node.nodeType) {
        case WorkflowNodeType.START:
          await this.executeStartNode(instance, node, workflow);
          break;
        case WorkflowNodeType.APPROVAL:
          await this.executeApprovalNode(instance, node, workflow);
          break;
        case WorkflowNodeType.TASK:
          await this.executeTaskNode(instance, node, workflow);
          break;
        case WorkflowNodeType.DECISION:
          await this.executeDecisionNode(instance, node, workflow);
          break;
        case WorkflowNodeType.SERVICE_TASK:
          await this.executeServiceTaskNode(instance, node, workflow);
          break;
        case WorkflowNodeType.END:
          await this.executeEndNode(instance, node, workflow);
          break;
        default:
          throw new Error(`不支援的節點類型: ${node.nodeType}`);
      }

      execution.status = NodeExecutionStatus.COMPLETED;
      execution.completedAt = new Date();

    } catch (error) {
      execution.status = NodeExecutionStatus.FAILED;
      execution.error = error.message;
      execution.completedAt = new Date();
      
      // 處理錯誤
      await this.handleNodeError(instance, node, error);
    }
  }

  async executeApprovalNode(instance: WorkflowInstance, node: WorkflowNode, workflow: WorkflowDefinition): Promise<void> {
    const config = node.configuration as ApprovalNodeConfiguration;
    
    // 1. 計算審批人員
    const assignees = await this.calculateAssignees(instance, node);
    
    // 2. 建立審批任務
    const approvalTasks: ApprovalTask[] = [];
    for (const assignee of assignees) {
      const task: ApprovalTask = {
        taskId: generateId(),
        instanceId: instance.instanceId,
        nodeId: node.nodeId,
        assigneeId: assignee.userId,
        assigneeType: assignee.type,
        status: ApprovalTaskStatus.PENDING,
        createdAt: new Date(),
        dueAt: this.calculateDueDate(node.slaMinutes),
        options: config.approvalOptions,
        requireComments: config.requireComments
      };
      approvalTasks.push(task);
      await this.approvalTaskRepository.save(task);
    }

    // 3. 發送通知
    if (config.notifyOnAssignment) {
      await this.sendApprovalNotifications(approvalTasks, instance);
    }

    // 4. 設定提醒
    await this.scheduleReminders(approvalTasks, config.reminderIntervals);

    // 5. 設定升級
    await this.scheduleEscalations(approvalTasks, config.escalationLevels);

    // 6. 更新當前節點
    instance.currentNodes.push({
      nodeId: node.nodeId,
      status: NodeExecutionStatus.WAITING,
      waitingFor: 'approval',
      assignees: assignees.map(a => a.userId)
    });
  }

  async processApprovalResponse(taskId: string, response: ApprovalResponse): Promise<void> {
    // 1. 獲取審批任務
    const task = await this.approvalTaskRepository.findById(taskId);
    const instance = await this.workflowInstanceRepository.findById(task.instanceId);
    const workflow = await this.workflowService.getWorkflow(instance.workflowId);
    const node = workflow.nodes.find(n => n.nodeId === task.nodeId);
    const config = node.configuration as ApprovalNodeConfiguration;

    // 2. 驗證權限
    if (!await this.validateApprovalPermission(response.responderId, task)) {
      throw new Error('沒有審批權限');
    }

    // 3. 更新任務狀態
    task.status = ApprovalTaskStatus.COMPLETED;
    task.responderId = response.responderId;
    task.responseAt = new Date();
    task.decision = response.decision;
    task.comments = response.comments;
    await this.approvalTaskRepository.save(task);

    // 4. 檢查是否滿足節點完成條件
    const allTasks = await this.approvalTaskRepository.findByInstanceAndNode(
      instance.instanceId, 
      node.nodeId
    );
    
    const completedTasks = allTasks.filter(t => t.status === ApprovalTaskStatus.COMPLETED);
    const approvedTasks = completedTasks.filter(t => t.decision === 'approve');
    const rejectedTasks = completedTasks.filter(t => t.decision === 'reject');

    let nodeResult: NodeResult | null = null;

    // 根據審批類型判斷節點結果
    switch (config.approvalType) {
      case ApprovalType.SINGLE:
        nodeResult = { decision: response.decision, reason: response.comments };
        break;
        
      case ApprovalType.UNANIMOUS:
        if (rejectedTasks.length > 0) {
          nodeResult = { decision: 'reject', reason: '有人拒絕' };
        } else if (approvedTasks.length === allTasks.length) {
          nodeResult = { decision: 'approve', reason: '全體通過' };
        }
        break;
        
      case ApprovalType.MAJORITY:
        const totalTasks = allTasks.length;
        const requiredApprovals = Math.ceil(totalTasks / 2);
        if (approvedTasks.length >= requiredApprovals) {
          nodeResult = { decision: 'approve', reason: '多數通過' };
        } else if (rejectedTasks.length > totalTasks - requiredApprovals) {
          nodeResult = { decision: 'reject', reason: '多數拒絕' };
        }
        break;
    }

    // 5. 如果節點完成，繼續工作流
    if (nodeResult) {
      await this.completeNode(instance, node, workflow, nodeResult);
    }
  }

  private async completeNode(
    instance: WorkflowInstance, 
    node: WorkflowNode, 
    workflow: WorkflowDefinition, 
    result: NodeResult
  ): Promise<void> {
    // 1. 更新當前節點狀態
    const currentNode = instance.currentNodes.find(n => n.nodeId === node.nodeId);
    if (currentNode) {
      currentNode.status = NodeExecutionStatus.COMPLETED;
      currentNode.completedAt = new Date();
      currentNode.result = result;
    }

    // 2. 找到下一個節點
    const nextNodes = await this.findNextNodes(instance, node, workflow, result);

    // 3. 移除當前節點
    instance.currentNodes = instance.currentNodes.filter(n => n.nodeId !== node.nodeId);

    // 4. 執行下一個節點
    for (const nextNode of nextNodes) {
      await this.executeNode(instance, nextNode, workflow);
    }

    // 5. 檢查工作流是否完成
    if (instance.currentNodes.length === 0) {
      instance.status = WorkflowInstanceStatus.COMPLETED;
      instance.completedAt = new Date();
      
      // 更新文檔狀態
      await this.updateDocumentStatus(instance.documentId, result);
    }

    // 6. 保存工作流實例
    await this.workflowInstanceRepository.save(instance);
  }
}

interface WorkflowInstance {
  instanceId: string;
  workflowId: string;
  documentId: string;
  documentType: string;
  status: WorkflowInstanceStatus;
  startedAt: Date;
  completedAt?: Date;
  startedBy: string;
  currentNodes: CurrentNodeExecution[];
  variables: Map<string, any>;
  executionHistory: NodeExecution[];
}

enum WorkflowInstanceStatus {
  RUNNING = 'running',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled',
  ERROR = 'error',
  SUSPENDED = 'suspended'
}

interface ApprovalTask {
  taskId: string;
  instanceId: string;
  nodeId: string;
  assigneeId: string;
  assigneeType: AssignmentType;
  status: ApprovalTaskStatus;
  createdAt: Date;
  dueAt?: Date;
  responderId?: string;
  responseAt?: Date;
  decision?: string;
  comments?: string;
  options: ApprovalOption[];
  requireComments: boolean;
}

enum ApprovalTaskStatus {
  PENDING = 'pending',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled',
  EXPIRED = 'expired',
  DELEGATED = 'delegated'
}
```

## 6. 单據關聯管理

### 6.1 单據關聯規則
```typescript
class DocumentRelationManager {
  // 建立单據關聯
  async createRelation(relation: DocumentRelationInput): Promise<DocumentRelation> {
    // 1. 驗證关联規則
    await this.validateRelation(relation);

    // 2. 檢查循環關聯
    await this.checkCircularReference(relation.sourceDocumentId, relation.targetDocumentId);

    // 3. 建立關聯記錄
    const documentRelation: DocumentRelation = {
      relationId: generateId(),
      relationType: relation.relationType,
      relatedDocumentId: relation.targetDocumentId,
      relatedDocumentType: relation.targetDocumentType,
      relatedDocumentNumber: relation.targetDocumentNumber,
      relationStatus: 'active',
      createdAt: new Date()
    };

    // 4. 更新源文檔
    await this.documentService.addRelation(relation.sourceDocumentId, documentRelation);

    // 5. 建立反向關聯（如果需要）
    if (this.needsReverseRelation(relation.relationType)) {
      const reverseRelation: DocumentRelation = {
        relationId: generateId(),
        relationType: this.getReverseRelationType(relation.relationType),
        relatedDocumentId: relation.sourceDocumentId,
        relatedDocumentType: relation.sourceDocumentType,
        relatedDocumentNumber: relation.sourceDocumentNumber,
        relationStatus: 'active',
        createdAt: new Date()
      };
      await this.documentService.addRelation(relation.targetDocumentId, reverseRelation);
    }

    return documentRelation;
  }

  // 验证关联规则
  private async validateRelation(relation: DocumentRelationInput): Promise<void> {
    const rules = await this.getRelationRules(
      relation.sourceDocumentType, 
      relation.targetDocumentType, 
      relation.relationType
    );

    for (const rule of rules) {
      if (!await this.evaluateRule(rule, relation)) {
        throw new Error(`關聯規則驗證失敗: ${rule.errorMessage}`);
      }
    }
  }

  // 获取关联规则
  private async getRelationRules(
    sourceType: string, 
    targetType: string, 
    relationType: DocumentRelationType
  ): Promise<RelationRule[]> {
    // 預定義的關聯規則
    const relationRules: Record<string, RelationRule[]> = {
      // 銷售訂單 -> 出貨單
      [`${SalesDocumentType.SALES_ORDER}-${SalesDocumentType.DELIVERY_ORDER}-${DocumentRelationType.PARENT}`]: [
        {
          ruleId: 'so_to_do_status',
          description: '銷售訂單必須是已確認狀態',
          condition: 'source.status == "confirmed"',
          errorMessage: '銷售訂單必須先確認才能建立出貨單'
        },
        {
          ruleId: 'so_to_do_inventory',
          description: '庫存必須足夠',
          condition: 'source.inventory_reserved == true',
          errorMessage: '庫存不足或未預留'
        }
      ],
      
      // 採購訂單 -> 收貨單
      [`${PurchaseDocumentType.PURCHASE_ORDER}-${PurchaseDocumentType.GOODS_RECEIPT}-${DocumentRelationType.PARENT}`]: [
        {
          ruleId: 'po_to_gr_status',
          description: '採購訂單必須是已審核狀態',
          condition: 'source.status == "approved"',
          errorMessage: '採購訂單必須先審核才能建立收貨單'
        },
        {
          ruleId: 'po_to_gr_supplier',
          description: '供應商必須一致',
          condition: 'source.supplierId == target.supplierId',
          errorMessage: '收貨單的供應商必須與採購訂單一致'
        }
      ],
      
      // 銷售訂單 -> 銷售發票
      [`${SalesDocumentType.SALES_ORDER}-${SalesDocumentType.SALES_INVOICE}-${DocumentRelationType.SOURCE}`]: [
        {
          ruleId: 'so_to_si_delivered',
          description: '必須已出貨',
          condition: 'source.shippingStatus == "shipped" OR source.shippingStatus == "delivered"',
          errorMessage: '必須先出貨才能開立發票'
        },
        {
          ruleId: 'so_to_si_customer',
          description: '客戶必須一致',
          condition: 'source.customerId == target.customerId',
          errorMessage: '發票客戶必須與訂單客戶一致'
        }
      ]
    };

    const key = `${sourceType}-${targetType}-${relationType}`;
    return relationRules[key] || [];
  }
}

interface DocumentRelationInput {
  sourceDocumentId: string;
  sourceDocumentType: string;
  sourceDocumentNumber: string;
  targetDocumentId: string;
  targetDocumentType: string;
  targetDocumentNumber: string;
  relationType: DocumentRelationType;
}

interface RelationRule {
  ruleId: string;
  description: string;
  condition: string;
  errorMessage: string;
  severity: 'error' | 'warning';
  skipCondition?: string;
}
```

### 6.2 单據依賴追蹤
```typescript
class DocumentDependencyTracker {
  // 獲取单據依賴樹
  async getDependencyTree(documentId: string, depth: number = 3): Promise<DependencyNode> {
    const document = await this.documentService.getDocument(documentId);
    const node: DependencyNode = {
      documentId: document.documentId,
      documentType: document.documentType,
      documentNumber: document.documentNumber,
      status: document.status,
      children: [],
      parents: []
    };

    if (depth > 0) {
      // 獲取子文檔
      const childRelations = document.relatedDocuments.filter(r => 
        r.relationType === DocumentRelationType.CHILD
      );
      
      for (const relation of childRelations) {
        const childNode = await this.getDependencyTree(relation.relatedDocumentId, depth - 1);
        node.children.push(childNode);
      }

      // 獲取父文檔
      const parentRelations = document.relatedDocuments.filter(r => 
        r.relationType === DocumentRelationType.PARENT
      );
      
      for (const relation of parentRelations) {
        const parentNode = await this.getDependencyTree(relation.relatedDocumentId, depth - 1);
        node.parents.push(parentNode);
      }
    }

    return node;
  }

  // 獲取单據影響範圍
  async getImpactScope(documentId: string, operationType: OperationType): Promise<ImpactScope> {
    const dependencyTree = await this.getDependencyTree(documentId);
    const impactedDocuments: ImpactedDocument[] = [];

    // 分析影響範圍
    await this.analyzeImpact(dependencyTree, operationType, impactedDocuments);

    // 計算風險等級
    const riskLevel = this.calculateRiskLevel(impactedDocuments);

    return {
      sourceDocumentId: documentId,
      operationType,
      riskLevel,
      impactedDocuments,
      recommendedActions: await this.getRecommendedActions(impactedDocuments),
      analysisAt: new Date()
    };
  }

  private async analyzeImpact(
    node: DependencyNode, 
    operation: OperationType, 
    impactedDocuments: ImpactedDocument[]
  ): Promise<void> {
    const impactRules = await this.getImpactRules(node.documentType, operation);

    for (const rule of impactRules) {
      if (await this.evaluateImpactRule(rule, node)) {
        // 檢查子文檔影響
        for (const child of node.children) {
          if (rule.affectsChildren) {
            impactedDocuments.push({
              documentId: child.documentId,
              documentType: child.documentType,
              documentNumber: child.documentNumber,
              currentStatus: child.status,
              impactType: rule.childImpactType,
              severity: rule.severity,
              description: rule.description,
              requiredActions: rule.requiredActions
            });

            // 遞歸分析
            if (rule.propagateToGrandChildren) {
              await this.analyzeImpact(child, operation, impactedDocuments);
            }
          }
        }

        // 檢查父文檔影響
        for (const parent of node.parents) {
          if (rule.affectsParents) {
            impactedDocuments.push({
              documentId: parent.documentId,
              documentType: parent.documentType,
              documentNumber: parent.documentNumber,
              currentStatus: parent.status,
              impactType: rule.parentImpactType,
              severity: rule.severity,
              description: rule.description,
              requiredActions: rule.requiredActions
            });
          }
        }
      }
    }
  }

  // 獲取影響規則
  private async getImpactRules(documentType: string, operation: OperationType): Promise<ImpactRule[]> {
    // 預定義影響規則
    const impactRules: Record<string, ImpactRule[]> = {
      // 銷售訂單取消的影響
      [`${SalesDocumentType.SALES_ORDER}-${OperationType.CANCEL}`]: [
        {
          ruleId: 'so_cancel_delivery',
          description: '取消銷售訂單會影響相關出貨單',
          condition: 'document.status != "draft"',
          affectsChildren: true,
          childImpactType: ImpactType.STATUS_CHANGE,
          severity: ImpactSeverity.HIGH,
          requiredActions: [RequiredAction.CANCEL_DOCUMENT, RequiredAction.NOTIFY_STAKEHOLDERS],
          propagateToGrandChildren: true
        },
        {
          ruleId: 'so_cancel_inventory',
          description: '取消銷售訂單會釋放預留庫存',
          condition: 'document.inventory_reserved == true',
          affectsChildren: false,
          impactType: ImpactType.INVENTORY_CHANGE,
          severity: ImpactSeverity.MEDIUM,
          requiredActions: [RequiredAction.RELEASE_INVENTORY]
        }
      ],
      
      // 採購訂單修改的影響
      [`${PurchaseDocumentType.PURCHASE_ORDER}-${OperationType.MODIFY}`]: [
        {
          ruleId: 'po_modify_receipt',
          description: '修改採購訂單可能影響收貨單',
          condition: 'hasChildren("goods_receipt")',
          affectsChildren: true,
          childImpactType: ImpactType.DATA_INCONSISTENCY,
          severity: ImpactSeverity.MEDIUM,
          requiredActions: [RequiredAction.VALIDATE_CONSISTENCY, RequiredAction.UPDATE_CHILDREN]
        }
      ]
    };

    const key = `${documentType}-${operation}`;
    return impactRules[key] || [];
  }
}

interface DependencyNode {
  documentId: string;
  documentType: string;
  documentNumber: string;
  status: DocumentStatus;
  children: DependencyNode[];
  parents: DependencyNode[];
}

interface ImpactScope {
  sourceDocumentId: string;
  operationType: OperationType;
  riskLevel: RiskLevel;
  impactedDocuments: ImpactedDocument[];
  recommendedActions: RecommendedAction[];
  analysisAt: Date;
}

interface ImpactedDocument {
  documentId: string;
  documentType: string;
  documentNumber: string;
  currentStatus: DocumentStatus;
  impactType: ImpactType;
  severity: ImpactSeverity;
  description: string;
  requiredActions: RequiredAction[];
}

enum OperationType {
  CREATE = 'create',
  MODIFY = 'modify',
  DELETE = 'delete',
  CANCEL = 'cancel',
  STATUS_CHANGE = 'status_change',
  APPROVE = 'approve',
  REJECT = 'reject'
}

enum ImpactType {
  STATUS_CHANGE = 'status_change',
  DATA_INCONSISTENCY = 'data_inconsistency',
  INVENTORY_CHANGE = 'inventory_change',
  FINANCIAL_IMPACT = 'financial_impact',
  WORKFLOW_DISRUPTION = 'workflow_disruption'
}

enum ImpactSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

enum RequiredAction {
  CANCEL_DOCUMENT = 'cancel_document',
  UPDATE_CHILDREN = 'update_children',
  VALIDATE_CONSISTENCY = 'validate_consistency',
  NOTIFY_STAKEHOLDERS = 'notify_stakeholders',
  RELEASE_INVENTORY = 'release_inventory',
  RECALCULATE_FINANCIALS = 'recalculate_financials'
}
```

## 7. 异常處理與回滾

### 7.1 异常處理機制
```typescript
class DocumentExceptionHandler {
  // 處理单據异常
  async handleException(exception: DocumentException): Promise<ExceptionResolution> {
    // 1. 記錄异常
    await this.logException(exception);

    // 2. 分析异常類型
    const analysis = await this.analyzeException(exception);

    // 3. 獲取處理策略
    const strategy = await this.getHandlingStrategy(analysis);

    // 4. 執行處理策略
    const resolution = await this.executeStrategy(exception, strategy);

    // 5. 通知相關人員
    await this.notifyStakeholders(exception, resolution);

    return resolution;
  }

  // 分析异常
  private async analyzeException(exception: DocumentException): Promise<ExceptionAnalysis> {
    const analysis: ExceptionAnalysis = {
      exceptionId: exception.exceptionId,
      category: await this.categorizeException(exception),
      severity: await this.calculateSeverity(exception),
      rootCause: await this.identifyRootCause(exception),
      impactScope: await this.assessImpact(exception),
      recoverability: await this.assessRecoverability(exception)
    };

    return analysis;
  }

  // 獲取處理策略
  private async getHandlingStrategy(analysis: ExceptionAnalysis): Promise<HandlingStrategy> {
    const strategies = await this.getAvailableStrategies(analysis);
    
    // 根據嚴重程度和可恢復性選擇策略
    if (analysis.severity === ExceptionSeverity.CRITICAL) {
      return strategies.find(s => s.type === StrategyType.IMMEDIATE_ROLLBACK) || 
             strategies.find(s => s.type === StrategyType.EMERGENCY_STOP);
    }

    if (analysis.recoverability === RecoverabilityLevel.AUTO_RECOVERABLE) {
      return strategies.find(s => s.type === StrategyType.AUTO_RECOVERY);
    }

    return strategies.find(s => s.type === StrategyType.MANUAL_INTERVENTION) ||
           strategies.find(s => s.type === StrategyType.WAIT_AND_RETRY);
  }

  // 執行處理策略
  private async executeStrategy(
    exception: DocumentException, 
    strategy: HandlingStrategy
  ): Promise<ExceptionResolution> {
    const resolution: ExceptionResolution = {
      resolutionId: generateId(),
      exceptionId: exception.exceptionId,
      strategy: strategy.type,
      startedAt: new Date(),
      status: ResolutionStatus.IN_PROGRESS,
      actions: []
    };

    try {
      switch (strategy.type) {
        case StrategyType.IMMEDIATE_ROLLBACK:
          await this.executeRollback(exception, resolution);
          break;
        case StrategyType.AUTO_RECOVERY:
          await this.executeAutoRecovery(exception, resolution);
          break;
        case StrategyType.MANUAL_INTERVENTION:
          await this.requestManualIntervention(exception, resolution);
          break;
        case StrategyType.WAIT_AND_RETRY:
          await this.scheduleRetry(exception, resolution);
          break;
      }

      resolution.status = ResolutionStatus.COMPLETED;
      resolution.completedAt = new Date();

    } catch (error) {
      resolution.status = ResolutionStatus.FAILED;
      resolution.error = error.message;
      resolution.completedAt = new Date();
      
      // 升級到更嚴重的處理策略
      await this.escalateException(exception);
    }

    return resolution;
  }
}

interface DocumentException {
  exceptionId: string;
  documentId: string;
  documentType: string;
  exceptionType: ExceptionType;
  errorCode: string;
  errorMessage: string;
  stackTrace?: string;
  context: Record<string, any>;
  occuredAt: Date;
  reportedBy: string;
  relatedExceptions: string[];
}

enum ExceptionType {
  VALIDATION_ERROR = 'validation_error',
  WORKFLOW_ERROR = 'workflow_error',
  INTEGRATION_ERROR = 'integration_error',
  DATA_CONSISTENCY_ERROR = 'data_consistency_error',
  PERMISSION_ERROR = 'permission_error',
  SYSTEM_ERROR = 'system_error',
  BUSINESS_RULE_VIOLATION = 'business_rule_violation',
  TIMEOUT_ERROR = 'timeout_error',
  CONCURRENCY_ERROR = 'concurrency_error'
}

enum ExceptionSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

enum StrategyType {
  IMMEDIATE_ROLLBACK = 'immediate_rollback',
  AUTO_RECOVERY = 'auto_recovery',
  MANUAL_INTERVENTION = 'manual_intervention',
  WAIT_AND_RETRY = 'wait_and_retry',
  EMERGENCY_STOP = 'emergency_stop',
  DATA_REPAIR = 'data_repair'
}
```

### 7.2 回滾機制
```typescript
class DocumentRollbackManager {
  // 執行单據回滾
  async rollbackDocument(documentId: string, rollbackReason: string): Promise<RollbackResult> {
    const rollback: DocumentRollback = {
      rollbackId: generateId(),
      documentId,
      initiatedBy: getCurrentUserId(),
      initiatedAt: new Date(),
      reason: rollbackReason,
      status: RollbackStatus.IN_PROGRESS,
      steps: []
    };

    try {
      // 1. 分析回滾範圍
      const scope = await this.analyzeRollbackScope(documentId);
      
      // 2. 建立回滾計劃
      const plan = await this.createRollbackPlan(scope);
      
      // 3. 執行回滾步驟
      for (const step of plan.steps) {
        await this.executeRollbackStep(rollback, step);
      }

      rollback.status = RollbackStatus.COMPLETED;
      rollback.completedAt = new Date();

      return {
        success: true,
        rollbackId: rollback.rollbackId,
        message: '回滾成功完成',
        details: rollback
      };

    } catch (error) {
      rollback.status = RollbackStatus.FAILED;
      rollback.error = error.message;
      rollback.completedAt = new Date();

      // 嘗試部分回滾
      await this.attemptPartialRollback(rollback);

      return {
        success: false,
        rollbackId: rollback.rollbackId,
        message: `回滾失敗: ${error.message}`,
        details: rollback
      };
    }
  }

  // 分析回滾範圍
  private async analyzeRollbackScope(documentId: string): Promise<RollbackScope> {
    const document = await this.documentService.getDocument(documentId);
    const dependencyTree = await this.dependencyTracker.getDependencyTree(documentId);
    
    const scope: RollbackScope = {
      primaryDocument: {
        documentId: document.documentId,
        documentType: document.documentType,
        currentStatus: document.status,
        rollbackToStatus: await this.determinePreviousStatus(document)
      },
      affectedDocuments: [],
      affectedInventory: [],
      affectedPayments: [],
      affectedAccounting: []
    };

    // 分析子文檔影響
    for (const child of dependencyTree.children) {
      if (this.requiresRollback(child, document)) {
        scope.affectedDocuments.push({
          documentId: child.documentId,
          documentType: child.documentType,
          currentStatus: child.status,
          rollbackAction: await this.determineRollbackAction(child, document)
        });
      }
    }

    // 分析庫存影響
    scope.affectedInventory = await this.analyzeInventoryImpact(document);

    // 分析付款影響  
    scope.affectedPayments = await this.analyzePaymentImpact(document);

    // 分析會計影響
    scope.affectedAccounting = await this.analyzeAccountingImpact(document);

    return scope;
  }

  // 建立回滾計劃
  private async createRollbackPlan(scope: RollbackScope): Promise<RollbackPlan> {
    const plan: RollbackPlan = {
      planId: generateId(),
      steps: [],
      estimatedDuration: 0,
      riskLevel: RiskLevel.MEDIUM,
      checkpoints: []
    };

    // 1. 建立檢查點
    const checkpoint = await this.createCheckpoint(scope);
    plan.checkpoints.push(checkpoint);

    // 2. 規劃回滾步驟（逆序執行）
    
    // Step 1: 回滾會計記錄
    if (scope.affectedAccounting.length > 0) {
      plan.steps.push({
        stepId: generateId(),
        stepType: RollbackStepType.ACCOUNTING_ROLLBACK,
        description: '回滾會計記錄',
        targetItems: scope.affectedAccounting,
        estimatedDuration: 300, // 5分鐘
        rollbackFunction: this.rollbackAccountingEntries
      });
    }

    // Step 2: 回滾付款記錄
    if (scope.affectedPayments.length > 0) {
      plan.steps.push({
        stepId: generateId(),
        stepType: RollbackStepType.PAYMENT_ROLLBACK,
        description: '回滾付款記錄',
        targetItems: scope.affectedPayments,
        estimatedDuration: 180,
        rollbackFunction: this.rollbackPayments
      });
    }

    // Step 3: 回滾庫存變動
    if (scope.affectedInventory.length > 0) {
      plan.steps.push({
        stepId: generateId(),
        stepType: RollbackStepType.INVENTORY_ROLLBACK,
        description: '回滾庫存變動',
        targetItems: scope.affectedInventory,
        estimatedDuration: 120,
        rollbackFunction: this.rollbackInventoryChanges
      });
    }

    // Step 4: 回滾子文檔
    for (const doc of scope.affectedDocuments) {
      plan.steps.push({
        stepId: generateId(),
        stepType: RollbackStepType.DOCUMENT_ROLLBACK,
        description: `回滾文檔 ${doc.documentId}`,
        targetItems: [doc],
        estimatedDuration: 60,
        rollbackFunction: this.rollbackChildDocument
      });
    }

    // Step 5: 回滾主文檔
    plan.steps.push({
      stepId: generateId(),
      stepType: RollbackStepType.DOCUMENT_ROLLBACK,
      description: '回滾主文檔狀態',
      targetItems: [scope.primaryDocument],
      estimatedDuration: 30,
      rollbackFunction: this.rollbackPrimaryDocument
    });

    // 計算總預估時間
    plan.estimatedDuration = plan.steps.reduce((total, step) => total + step.estimatedDuration, 0);

    // 評估風險等級
    plan.riskLevel = this.assessRollbackRisk(scope, plan);

    return plan;
  }

  // 執行回滾步驟
  private async executeRollbackStep(rollback: DocumentRollback, step: RollbackStep): Promise<void> {
    const stepExecution: RollbackStepExecution = {
      stepId: step.stepId,
      status: RollbackStepStatus.RUNNING,
      startedAt: new Date(),
      progress: 0
    };

    rollback.steps.push(stepExecution);

    try {
      // 執行回滾函數
      await step.rollbackFunction.call(this, step.targetItems, (progress: number) => {
        stepExecution.progress = progress;
      });

      stepExecution.status = RollbackStepStatus.COMPLETED;
      stepExecution.completedAt = new Date();
      stepExecution.progress = 100;

    } catch (error) {
      stepExecution.status = RollbackStepStatus.FAILED;
      stepExecution.error = error.message;
      stepExecution.completedAt = new Date();
      
      throw new Error(`回滾步驟失敗: ${step.description} - ${error.message}`);
    }
  }

  // 回滾庫存變動
  private async rollbackInventoryChanges(
    inventoryItems: InventoryRollbackItem[], 
    progressCallback: (progress: number) => void
  ): Promise<void> {
    for (let i = 0; i < inventoryItems.length; i++) {
      const item = inventoryItems[i];
      
      // 執行庫存回滾
      await this.inventoryService.rollbackTransaction(item.transactionId);
      
      // 更新進度
      progressCallback((i + 1) / inventoryItems.length * 100);
    }
  }

  // 回滾付款記錄
  private async rollbackPayments(
    paymentItems: PaymentRollbackItem[],
    progressCallback: (progress: number) => void
  ): Promise<void> {
    for (let i = 0; i < paymentItems.length; i++) {
      const item = paymentItems[i];
      
      // 根據付款狀態決定回滾方式
      switch (item.rollbackAction) {
        case PaymentRollbackAction.VOID:
          await this.paymentService.voidPayment(item.paymentId);
          break;
        case PaymentRollbackAction.REFUND:
          await this.paymentService.refundPayment(item.paymentId);
          break;
        case PaymentRollbackAction.CANCEL:
          await this.paymentService.cancelPayment(item.paymentId);
          break;
      }
      
      progressCallback((i + 1) / paymentItems.length * 100);
    }
  }
}

interface DocumentRollback {
  rollbackId: string;
  documentId: string;
  initiatedBy: string;
  initiatedAt: Date;
  completedAt?: Date;
  reason: string;
  status: RollbackStatus;
  error?: string;
  steps: RollbackStepExecution[];
}

enum RollbackStatus {
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  FAILED = 'failed',
  PARTIALLY_COMPLETED = 'partially_completed'
}

interface RollbackScope {
  primaryDocument: DocumentRollbackItem;
  affectedDocuments: DocumentRollbackItem[];
  affectedInventory: InventoryRollbackItem[];
  affectedPayments: PaymentRollbackItem[];
  affectedAccounting: AccountingRollbackItem[];
}

enum RollbackStepType {
  DOCUMENT_ROLLBACK = 'document_rollback',
  INVENTORY_ROLLBACK = 'inventory_rollback', 
  PAYMENT_ROLLBACK = 'payment_rollback',
  ACCOUNTING_ROLLBACK = 'accounting_rollback',
  NOTIFICATION_ROLLBACK = 'notification_rollback'
}
```

## 8. API 介面設計

### 8.1 单據管理 API
```typescript
// 建立单據
// POST /api/documents
interface CreateDocumentRequest {
  documentType: string;
  templateId?: string;
  data: Record<string, any>;
  autoSubmit?: boolean;
  workflowId?: string;
}

interface CreateDocumentResponse {
  documentId: string;
  documentNumber: string;
  status: DocumentStatus;
  workflowInstanceId?: string;
}

// 獲取单據詳情
// GET /api/documents/:documentId
interface GetDocumentResponse extends BaseDocument {
  // 包含完整的单據資料
}

// 更新单據
// PUT /api/documents/:documentId  
interface UpdateDocumentRequest {
  data: Partial<Record<string, any>>;
  reason?: string;
  forceUpdate?: boolean;
}

// 提交单據
// POST /api/documents/:documentId/submit
interface SubmitDocumentRequest {
  workflowId?: string;
  comments?: string;
}

// 取消单據
// POST /api/documents/:documentId/cancel
interface CancelDocumentRequest {
  reason: string;
  cancellationType: 'soft' | 'hard';
  notifyStakeholders: boolean;
}
```

### 8.2 工作流程 API
```typescript
// 獲取待辦審批
// GET /api/workflow/approvals/pending
interface GetPendingApprovalsRequest {
  userId?: string;
  documentType?: string;
  priority?: ApprovalPriority;
  dueDate?: Date;
  page?: number;
  pageSize?: number;
}

interface GetPendingApprovalsResponse {
  tasks: ApprovalTask[];
  total: number;
  urgent: number;
  overdue: number;
}

// 執行審批
// POST /api/workflow/approvals/:taskId/respond
interface ApprovalResponseRequest {
  decision: string;
  comments?: string;
  delegateToUserId?: string;
  attachments?: string[];
}

// 獲取工作流狀態
// GET /api/workflow/instances/:instanceId
interface GetWorkflowInstanceResponse {
  instance: WorkflowInstance;
  currentTasks: ApprovalTask[];
  availableActions: WorkflowAction[];
}

// 委派審批
// POST /api/workflow/approvals/:taskId/delegate
interface DelegateApprovalRequest {
  targetUserId: string;
  reason: string;
  retainResponsibility: boolean;
  dueDate?: Date;
}
```

### 8.3 单據關聯 API
```typescript
// 建立单據關聯
// POST /api/documents/:documentId/relations
interface CreateDocumentRelationRequest {
  targetDocumentId: string;
  relationType: DocumentRelationType;
  metadata?: Record<string, any>;
}

// 獲取关联单據
// GET /api/documents/:documentId/relations
interface GetDocumentRelationsResponse {
  relations: DocumentRelation[];
  dependencyTree: DependencyNode;
}

// 分析影響範圍
// POST /api/documents/:documentId/impact-analysis
interface ImpactAnalysisRequest {
  operationType: OperationType;
  proposedChanges?: Record<string, any>;
}

interface ImpactAnalysisResponse {
  impactScope: ImpactScope;
  warnings: ImpactWarning[];
  recommendedActions: RecommendedAction[];
}
```

### 8.4 异常處理 API
```typescript
// 報告异常
// POST /api/documents/:documentId/exceptions
interface ReportExceptionRequest {
  exceptionType: ExceptionType;
  errorCode: string;
  errorMessage: string;
  context: Record<string, any>;
  severity?: ExceptionSeverity;
}

// 獲取异常列表
// GET /api/documents/exceptions
interface GetExceptionsRequest {
  documentId?: string;
  exceptionType?: ExceptionType;
  severity?: ExceptionSeverity;
  status?: ExceptionStatus;
  dateFrom?: Date;
  dateTo?: Date;
}

// 執行回滾
// POST /api/documents/:documentId/rollback
interface RollbackDocumentRequest {
  reason: string;
  rollbackType: 'partial' | 'full';
  targetStatus?: DocumentStatus;
  notifyStakeholders: boolean;
}

interface RollbackDocumentResponse {
  rollbackId: string;
  estimatedDuration: number;
  riskLevel: RiskLevel;
  affectedDocuments: string[];
}
```

## 9. 資料庫設計

### 9.1 单據主表設計
```sql
-- 通用单據表
CREATE TABLE documents (
    document_id VARCHAR(50) PRIMARY KEY,
    document_type VARCHAR(50) NOT NULL,
    document_number VARCHAR(100) NOT NULL UNIQUE,
    version INT DEFAULT 1,
    
    -- 狀態資訊
    status VARCHAR(50) NOT NULL DEFAULT 'draft',
    previous_status VARCHAR(50),
    status_changed_at DATETIME,
    status_changed_by VARCHAR(50),
    
    -- 業務資訊
    business_date DATE NOT NULL,
    effective_date DATE NOT NULL,
    expiry_date DATE,
    
    -- 金額資訊
    currency VARCHAR(10) DEFAULT 'TWD',
    exchange_rate DECIMAL(12,6) DEFAULT 1.0,
    subtotal DECIMAL(15,2) DEFAULT 0,
    tax_amount DECIMAL(15,2) DEFAULT 0,
    discount_amount DECIMAL(15,2) DEFAULT 0,
    total_amount DECIMAL(15,2) DEFAULT 0,
    
    -- 關聯資訊
    parent_document_id VARCHAR(50),
    source_document_id VARCHAR(50),
    
    -- 審核資訊
    approval_status VARCHAR(50) DEFAULT 'not_required',
    current_approval_level INT DEFAULT 0,
    
    -- 附加資訊
    description TEXT,
    internal_notes TEXT,
    customer_notes TEXT,
    custom_fields JSON,
    
    -- 組織資訊
    company_id VARCHAR(50) NOT NULL,
    branch_id VARCHAR(50),
    department_id VARCHAR(50),
    
    -- 時間戳記
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_by VARCHAR(50) NOT NULL,
    updated_by VARCHAR(50) NOT NULL,
    
    -- 版本控制
    is_latest_version BOOLEAN DEFAULT TRUE,
    
    INDEX idx_document_type (document_type),
    INDEX idx_status (status),
    INDEX idx_business_date (business_date),
    INDEX idx_created_at (created_at),
    INDEX idx_company_id (company_id),
    INDEX idx_parent_document (parent_document_id),
    INDEX idx_source_document (source_document_id),
    
    FOREIGN KEY (parent_document_id) REFERENCES documents(document_id),
    FOREIGN KEY (source_document_id) REFERENCES documents(document_id)
);

-- 单據狀態歷史
CREATE TABLE document_status_history (
    history_id VARCHAR(50) PRIMARY KEY,
    document_id VARCHAR(50) NOT NULL,
    from_status VARCHAR(50),
    to_status VARCHAR(50) NOT NULL,
    changed_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    changed_by VARCHAR(50) NOT NULL,
    reason VARCHAR(500),
    comments TEXT,
    system_generated BOOLEAN DEFAULT FALSE,
    
    FOREIGN KEY (document_id) REFERENCES documents(document_id) ON DELETE CASCADE,
    INDEX idx_document_id (document_id),
    INDEX idx_changed_at (changed_at)
);

-- 单據關聯
CREATE TABLE document_relations (
    relation_id VARCHAR(50) PRIMARY KEY,
    source_document_id VARCHAR(50) NOT NULL,
    target_document_id VARCHAR(50) NOT NULL,
    relation_type VARCHAR(50) NOT NULL,
    relation_status VARCHAR(20) DEFAULT 'active',
    metadata JSON,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(50) NOT NULL,
    
    FOREIGN KEY (source_document_id) REFERENCES documents(document_id) ON DELETE CASCADE,
    FOREIGN KEY (target_document_id) REFERENCES documents(document_id) ON DELETE CASCADE,
    INDEX idx_source_document (source_document_id),
    INDEX idx_target_document (target_document_id),
    INDEX idx_relation_type (relation_type),
    
    UNIQUE KEY uk_relation (source_document_id, target_document_id, relation_type)
);
```

### 9.2 工作流程表設計
```sql
-- 工作流程定義
CREATE TABLE workflow_definitions (
    workflow_id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    version VARCHAR(20) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    applicable_document_types JSON NOT NULL,
    workflow_config JSON NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_by VARCHAR(50) NOT NULL,
    updated_by VARCHAR(50) NOT NULL,
    
    INDEX idx_document_types (applicable_document_types),
    INDEX idx_is_active (is_active),
    UNIQUE KEY uk_workflow_version (name, version)
);

-- 工作流程實例
CREATE TABLE workflow_instances (
    instance_id VARCHAR(50) PRIMARY KEY,
    workflow_id VARCHAR(50) NOT NULL,
    document_id VARCHAR(50) NOT NULL,
    document_type VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'running',
    started_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME,
    started_by VARCHAR(50) NOT NULL,
    variables JSON,
    
    FOREIGN KEY (workflow_id) REFERENCES workflow_definitions(workflow_id),
    FOREIGN KEY (document_id) REFERENCES documents(document_id) ON DELETE CASCADE,
    INDEX idx_document_id (document_id),
    INDEX idx_status (status),
    INDEX idx_started_at (started_at)
);

-- 審批任務
CREATE TABLE approval_tasks (
    task_id VARCHAR(50) PRIMARY KEY,
    instance_id VARCHAR(50) NOT NULL,
    node_id VARCHAR(50) NOT NULL,
    assignee_id VARCHAR(50) NOT NULL,
    assignee_type VARCHAR(20) NOT NULL DEFAULT 'user',
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    due_at DATETIME,
    responded_at DATETIME,
    responder_id VARCHAR(50),
    decision VARCHAR(50),
    comments TEXT,
    require_comments BOOLEAN DEFAULT FALSE,
    
    FOREIGN KEY (instance_id) REFERENCES workflow_instances(instance_id) ON DELETE CASCADE,
    INDEX idx_assignee_id (assignee_id),
    INDEX idx_status (status),
    INDEX idx_due_at (due_at),
    INDEX idx_created_at (created_at)
);

-- 節點執行歷史
CREATE TABLE node_execution_history (
    execution_id VARCHAR(50) PRIMARY KEY,
    instance_id VARCHAR(50) NOT NULL,
    node_id VARCHAR(50) NOT NULL,
    node_type VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL,
    started_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME,
    input_data JSON,
    output_data JSON,
    error_message TEXT,
    
    FOREIGN KEY (instance_id) REFERENCES workflow_instances(instance_id) ON DELETE CASCADE,
    INDEX idx_instance_id (instance_id),
    INDEX idx_node_id (node_id),
    INDEX idx_status (status)
);
```

### 9.3 异常處理表設計
```sql
-- 单據异常
CREATE TABLE document_exceptions (
    exception_id VARCHAR(50) PRIMARY KEY,
    document_id VARCHAR(50) NOT NULL,
    document_type VARCHAR(50) NOT NULL,
    exception_type VARCHAR(50) NOT NULL,
    error_code VARCHAR(50) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    context_data JSON,
    severity VARCHAR(20) NOT NULL DEFAULT 'medium',
    status VARCHAR(50) NOT NULL DEFAULT 'open',
    occured_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    reported_by VARCHAR(50) NOT NULL,
    resolved_at DATETIME,
    resolved_by VARCHAR(50),
    resolution_notes TEXT,
    
    FOREIGN KEY (document_id) REFERENCES documents(document_id),
    INDEX idx_document_id (document_id),
    INDEX idx_exception_type (exception_type),
    INDEX idx_severity (severity),
    INDEX idx_status (status),
    INDEX idx_occured_at (occured_at)
);

-- 回滾記錄
CREATE TABLE document_rollbacks (
    rollback_id VARCHAR(50) PRIMARY KEY,
    document_id VARCHAR(50) NOT NULL,
    rollback_type VARCHAR(20) NOT NULL,
    reason TEXT NOT NULL,
    initiated_by VARCHAR(50) NOT NULL,
    initiated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME,
    status VARCHAR(50) NOT NULL DEFAULT 'in_progress',
    rollback_plan JSON,
    execution_log JSON,
    error_message TEXT,
    
    FOREIGN KEY (document_id) REFERENCES documents(document_id),
    INDEX idx_document_id (document_id),
    INDEX idx_status (status),
    INDEX idx_initiated_at (initiated_at)
);

-- 回滾步驟執行
CREATE TABLE rollback_step_executions (
    execution_id VARCHAR(50) PRIMARY KEY,
    rollback_id VARCHAR(50) NOT NULL,
    step_id VARCHAR(50) NOT NULL,
    step_type VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    started_at DATETIME,
    completed_at DATETIME,
    progress INT DEFAULT 0,
    result_data JSON,
    error_message TEXT,
    
    FOREIGN KEY (rollback_id) REFERENCES document_rollbacks(rollback_id) ON DELETE CASCADE,
    INDEX idx_rollback_id (rollback_id),
    INDEX idx_status (status)
);
```

## 10. 部署與監控

### 10.1 系統部署
```yaml
# docker-compose.yml
version: '3.8'

services:
  document-workflow-service:
    build: 
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - REDIS_HOST=redis
      - RABBITMQ_URL=amqp://rabbitmq:5672
    depends_on:
      - mysql
      - redis
      - rabbitmq
    networks:
      - document-network

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root_password
      - MYSQL_DATABASE=document_workflow
    volumes:
      - mysql_data:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - document-network

  redis:
    image: redis:7-alpine
    networks:
      - document-network

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=admin
    networks:
      - document-network

volumes:
  mysql_data:

networks:
  document-network:
    driver: bridge
```

### 10.2 監控配置
```typescript
class DocumentWorkflowMonitor {
  // 監控单據處理效能
  async monitorDocumentProcessing(): Promise<void> {
    const metrics = await this.collectProcessingMetrics();
    
    // 檢查處理時間
    if (metrics.averageProcessingTime > 300000) { // 5分鐘
      await this.alertService.sendAlert({
        type: 'SLOW_DOCUMENT_PROCESSING',
        severity: 'WARNING',
        message: `單據平均處理時間過長: ${metrics.averageProcessingTime}ms`,
        data: metrics
      });
    }

    // 檢查待處理数量
    if (metrics.pendingCount > 1000) {
      await this.alertService.sendAlert({
        type: 'HIGH_PENDING_COUNT',
        severity: 'HIGH',
        message: `待處理單據數量過多: ${metrics.pendingCount}`,
        data: metrics
      });
    }

    // 檢查异常率
    if (metrics.exceptionRate > 0.05) { // 5%
      await this.alertService.sendAlert({
        type: 'HIGH_EXCEPTION_RATE',
        severity: 'CRITICAL',
        message: `單據異常率過高: ${metrics.exceptionRate * 100}%`,
        data: metrics
      });
    }
  }

  // 監控工作流效能
  async monitorWorkflowPerformance(): Promise<void> {
    const metrics = await this.collectWorkflowMetrics();
    
    // 檢查審批超時
    const overdueApprovals = await this.getOverdueApprovals();
    if (overdueApprovals.length > 0) {
      await this.alertService.sendAlert({
        type: 'OVERDUE_APPROVALS',
        severity: 'HIGH',
        message: `有 ${overdueApprovals.length} 個審批任務超時`,
        data: { overdueApprovals }
      });
    }

    // 檢查工作流卡住
    const stuckInstances = await this.getStuckWorkflowInstances();
    if (stuckInstances.length > 0) {
      await this.alertService.sendAlert({
        type: 'STUCK_WORKFLOWS',
        severity: 'CRITICAL',
        message: `有 ${stuckInstances.length} 個工作流卡住`,
        data: { stuckInstances }
      });
    }
  }
}
```

此单據流程架構提供了完整的业务单據生命週期管理，包括状態控制、工作流程、关联管理、异常處理和回滾機制，能夠支撑 MickeyShop Beauty 系統的所有业务流程需求。

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "設計系統設定模組功能規格", "status": "completed", "activeForm": "設計系統設定模組功能規格"}, {"content": "設計完整的单據流程", "status": "completed", "activeForm": "設計完整的单據流程"}, {"content": "設計綠界物流整合架構", "status": "in_progress", "activeForm": "設計綠界物流整合架構"}, {"content": "完善前台與後台API整合規格", "status": "pending", "activeForm": "完善前台與後台API整合規格"}, {"content": "確認架構設計完整性", "status": "pending", "activeForm": "確認架構設計完整性"}]