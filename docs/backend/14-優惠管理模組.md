# 模組 14: 優惠管理模組 (Coupon Management Module)

## 模組概述

優惠管理模組提供完整的折扣券與優惠碼管理功能，包含多種優惠類型、智能疊加規則、社群分享機制、自動化發放系統，以及完整的生命週期管理。支援與節慶管理、會員系統、行銷活動的深度整合，提供靈活的優惠策略配置和精確的使用效果分析。

## 核心功能架構

### 1. 優惠券類型與結構

#### 1.1 優惠券基本結構
```typescript
interface Coupon {
  id: string
  code: string                         // 優惠碼
  name: string                         // 優惠券名稱
  description: string                  // 優惠券說明
  type: CouponType                     // 優惠類型
  discountConfig: DiscountConfig       // 折扣配置
  conditions: CouponCondition[]        // 使用條件
  limitations: CouponLimitation        // 使用限制
  validity: CouponValidity             // 有效期設定
  distribution: DistributionConfig     // 發放配置
  stackingRules: StackingRule[]        // 疊加規則
  sharingConfig: SharingConfig         // 分享配置
  status: CouponStatus
  metadata: CouponMetadata
  createdAt: Date
  updatedAt: Date
}

enum CouponType {
  FIXED_AMOUNT = 'fixed_amount',           // 固定金額折扣
  PERCENTAGE = 'percentage',               // 百分比折扣
  FREE_SHIPPING = 'free_shipping',         // 免運券
  BUY_ONE_GET_ONE = 'bogo',               // 買一送一
  BUNDLE_DISCOUNT = 'bundle_discount',     // 組合優惠
  MEMBER_EXCLUSIVE = 'member_exclusive',   // 會員專屬
  NEW_USER_BONUS = 'new_user_bonus',      // 新會員優惠
  BIRTHDAY_GIFT = 'birthday_gift',        // 生日禮券
  CASHBACK = 'cashback'                   // 現金回饋
}

interface DiscountConfig {
  value: number                        // 折扣值
  maxDiscount?: number                 // 最大折扣金額
  minOrderAmount?: number              // 最低訂單金額
  applicableProducts?: string[]        // 適用商品ID
  applicableCategories?: string[]      // 適用分類ID
  excludedProducts?: string[]          // 排除商品ID
  calculation: DiscountCalculation
}

enum DiscountCalculation {
  BEFORE_TAX = 'before_tax',           // 稅前計算
  AFTER_TAX = 'after_tax',            // 稅後計算
  ON_SUBTOTAL = 'on_subtotal',        // 商品小計
  ON_TOTAL = 'on_total'               // 訂單總額
}
```

#### 1.2 優惠券條件與限制
```typescript
interface CouponCondition {
  type: ConditionType
  operator: ComparisonOperator
  value: any
  description: string
}

enum ConditionType {
  MIN_ORDER_AMOUNT = 'min_order_amount',       // 最低訂單金額
  MIN_QUANTITY = 'min_quantity',               // 最低購買數量
  MEMBER_LEVEL = 'member_level',               // 會員等級
  FIRST_ORDER = 'first_order',                 // 首次購買
  PRODUCT_CATEGORY = 'product_category',       // 商品分類
  BRAND = 'brand',                             // 指定品牌
  DAY_OF_WEEK = 'day_of_week',                // 星期限制
  TIME_RANGE = 'time_range',                   // 時間範圍
  LOCATION = 'location',                       // 地區限制
  PAYMENT_METHOD = 'payment_method'            // 付款方式
}

interface CouponLimitation {
  totalUsageLimit?: number             // 總使用次數限制
  perUserLimit?: number                // 每用戶使用次數限制
  dailyLimit?: number                  // 每日使用次數限制
  concurrentUsage?: number             // 同時使用數量限制
  cooldownPeriod?: number              // 冷卻期(小時)
  deviceLimit?: number                 // 設備限制
  ipLimit?: number                     // IP限制
}

interface CouponValidity {
  startDate: Date                      // 開始時間
  endDate: Date                        // 結束時間
  validityType: ValidityType           // 有效期類型
  validityDays?: number                // 有效天數
  autoExtend?: boolean                 // 自動延期
  expiryWarningDays: number            // 到期提醒天數
}

enum ValidityType {
  FIXED_PERIOD = 'fixed_period',       // 固定期間
  RELATIVE_DAYS = 'relative_days',     // 相對天數
  PERMANENT = 'permanent'              // 永久有效
}
```

### 2. 智能疊加規則系統

#### 2.1 疊加規則引擎
```typescript
interface StackingRule {
  id: string
  name: string
  priority: number                     // 優先級 (數字越大優先級越高)
  stackingType: StackingType
  compatibleTypes: CouponType[]        // 可疊加的券類型
  incompatibleTypes: CouponType[]      // 不可疊加的券類型
  maxStackCount?: number               // 最大疊加數量
  conditions: StackingCondition[]
  calculationOrder: CalculationOrder
  isActive: boolean
}

enum StackingType {
  ALLOW_ALL = 'allow_all',             // 允許所有疊加
  SELECTIVE = 'selective',             // 選擇性疊加
  EXCLUSIVE = 'exclusive',             // 互斥使用
  HIERARCHICAL = 'hierarchical'        // 階層式疊加
}

enum CalculationOrder {
  PERCENTAGE_FIRST = 'percentage_first',   // 百分比優先
  AMOUNT_FIRST = 'amount_first',          // 固定金額優先
  PRIORITY_BASED = 'priority_based',       // 優先級順序
  BEST_FOR_CUSTOMER = 'best_for_customer'  // 對客戶最優惠
}

interface StackingCondition {
  field: string                        // 條件欄位
  operator: ComparisonOperator
  value: any
  logicalOperator?: 'AND' | 'OR'
}

class CouponStackingEngine {
  // 計算疊加優惠
  async calculateStackedDiscount(
    coupons: UserCoupon[],
    cartData: CartData
  ): Promise<StackedDiscountResult> {
    
    // 1. 驗證優惠券有效性
    const validCoupons = await this.validateCoupons(coupons, cartData)
    
    // 2. 檢查疊加相容性
    const compatibleGroups = await this.groupCompatibleCoupons(validCoupons)
    
    // 3. 計算所有可能的疊加組合
    const stackingCombinations = await this.generateStackingCombinations(compatibleGroups)
    
    // 4. 為每個組合計算折扣
    const calculatedCombinations = await Promise.all(
      stackingCombinations.map(combination => 
        this.calculateCombinationDiscount(combination, cartData)
      )
    )
    
    // 5. 選擇最優組合
    const bestCombination = this.selectBestCombination(calculatedCombinations)
    
    return {
      appliedCoupons: bestCombination.coupons,
      totalDiscount: bestCombination.totalDiscount,
      discountBreakdown: bestCombination.breakdown,
      savingsComparison: this.compareSavings(calculatedCombinations),
      warnings: bestCombination.warnings
    }
  }

  // 檢查疊加相容性
  private async groupCompatibleCoupons(coupons: UserCoupon[]): Promise<CouponGroup[]> {
    const groups: CouponGroup[] = []
    
    for (const coupon of coupons) {
      const stackingRule = await this.getStackingRule(coupon.type)
      
      if (stackingRule.stackingType === StackingType.EXCLUSIVE) {
        // 互斥券單獨分組
        groups.push({
          type: 'exclusive',
          coupons: [coupon],
          maxStack: 1
        })
      } else {
        // 尋找相容的分組
        const compatibleGroup = groups.find(group => 
          this.areCompatible(group.coupons, coupon, stackingRule)
        )
        
        if (compatibleGroup && compatibleGroup.coupons.length < (stackingRule.maxStackCount || 10)) {
          compatibleGroup.coupons.push(coupon)
        } else {
          groups.push({
            type: 'stackable',
            coupons: [coupon],
            maxStack: stackingRule.maxStackCount || 10
          })
        }
      }
    }
    
    return groups
  }

  // 計算組合折扣
  private async calculateCombinationDiscount(
    combination: CouponCombination,
    cartData: CartData
  ): Promise<CombinationResult> {
    
    let runningTotal = cartData.subtotal
    let totalDiscount = 0
    const breakdown: DiscountBreakdown[] = []
    const warnings: string[] = []
    
    // 按計算順序排序優惠券
    const sortedCoupons = this.sortByCalculationOrder(combination.coupons)
    
    for (const coupon of sortedCoupons) {
      try {
        const discount = await this.calculateSingleDiscount(
          coupon,
          runningTotal,
          cartData
        )
        
        if (discount.amount > 0) {
          totalDiscount += discount.amount
          runningTotal = Math.max(0, runningTotal - discount.amount)
          
          breakdown.push({
            couponId: coupon.id,
            couponName: coupon.name,
            discountAmount: discount.amount,
            appliedTo: discount.appliedTo,
            calculation: discount.calculation
          })
        } else {
          warnings.push(`優惠券 "${coupon.name}" 無法套用：${discount.reason}`)
        }
      } catch (error) {
        warnings.push(`優惠券 "${coupon.name}" 計算錯誤：${error.message}`)
      }
    }
    
    return {
      coupons: combination.coupons,
      totalDiscount: totalDiscount,
      breakdown: breakdown,
      finalAmount: Math.max(0, cartData.subtotal - totalDiscount),
      warnings: warnings
    }
  }
}

interface StackedDiscountResult {
  appliedCoupons: UserCoupon[]
  totalDiscount: number
  discountBreakdown: DiscountBreakdown[]
  savingsComparison: SavingsComparison
  warnings: string[]
}
```

### 3. 社群分享系統

#### 3.1 分享機制設計
```typescript
interface SharingConfig {
  isShareable: boolean                 // 是否可分享
  shareTypes: ShareType[]              // 分享類型
  shareRewards: ShareReward            // 分享獎勵
  sharingLimits: SharingLimits         // 分享限制
  viralConfig?: ViralConfig            // 病毒式傳播配置
}

enum ShareType {
  DIRECT_LINK = 'direct_link',         // 直接連結分享
  QR_CODE = 'qr_code',                 // QR碼分享
  SOCIAL_MEDIA = 'social_media',       // 社群媒體分享
  REFERRAL_CODE = 'referral_code',     // 推薦碼分享
  GROUP_PURCHASE = 'group_purchase'    // 團購分享
}

interface ShareReward {
  sharerReward: RewardConfig           // 分享者獎勵
  shareeCReward: RewardConfig          // 被分享者獎勵
  rewardConditions: RewardCondition[]  // 獎勵條件
}

interface RewardConfig {
  type: 'coupon' | 'points' | 'cashback' | 'gift'
  value: number
  couponTemplate?: string              // 獎勵優惠券模板
  description: string
}

interface SharingLimits {
  maxSharesPerUser: number             // 每用戶最大分享次數
  maxSharesPerDay: number              // 每日最大分享次數
  cooldownHours: number                // 分享冷卻時間
  validityDays: number                 // 分享連結有效期
}

class CouponSharingService {
  // 生成分享連結
  async generateShareLink(
    userId: string,
    couponId: string,
    shareType: ShareType
  ): Promise<ShareLinkResult> {
    
    const coupon = await this.couponRepository.findById(couponId)
    const user = await this.userService.findById(userId)
    
    // 檢查分享權限
    await this.validateSharingPermission(user, coupon)
    
    // 檢查分享限制
    await this.checkSharingLimits(userId, coupon.id)
    
    const shareToken = this.generateShareToken(userId, couponId, shareType)
    const shareLink = this.buildShareLink(shareToken, shareType)
    
    // 記錄分享事件
    await this.recordShareEvent({
      userId: userId,
      couponId: couponId,
      shareType: shareType,
      shareToken: shareToken,
      shareLink: shareLink.url,
      createdAt: new Date()
    })
    
    return {
      shareLink: shareLink,
      qrCode: await this.generateQRCode(shareLink.url),
      socialMediaContent: this.generateSocialContent(coupon, shareLink),
      expiresAt: this.calculateShareExpiry(coupon.sharingConfig.sharingLimits.validityDays)
    }
  }

  // 處理分享點擊
  async handleShareClick(
    shareToken: string,
    clickerId?: string
  ): Promise<ShareClickResult> {
    
    const shareEvent = await this.shareEventRepository.findByToken(shareToken)
    
    if (!shareEvent || this.isShareExpired(shareEvent)) {
      throw new Error('分享連結已過期或無效')
    }
    
    const coupon = await this.couponRepository.findById(shareEvent.couponId)
    const sharer = await this.userService.findById(shareEvent.userId)
    
    // 記錄點擊事件
    await this.recordShareClick(shareEvent.id, clickerId)
    
    // 檢查是否為新用戶或是否符合獎勵條件
    const rewardEligibility = await this.checkRewardEligibility(
      shareEvent.userId,
      clickerId,
      coupon.sharingConfig.shareRewards
    )
    
    return {
      coupon: coupon,
      sharer: {
        name: sharer.name,
        avatar: sharer.avatar
      },
      isEligibleForReward: rewardEligibility.eligible,
      rewardConditions: rewardEligibility.conditions,
      claimInstructions: this.generateClaimInstructions(coupon, shareEvent)
    }
  }

  // 發放分享獎勵
  async processShareReward(
    shareEventId: string,
    completedAction: CompletedAction
  ): Promise<void> {
    
    const shareEvent = await this.shareEventRepository.findById(shareEventId)
    const coupon = await this.couponRepository.findById(shareEvent.couponId)
    
    const rewards = coupon.sharingConfig.shareRewards
    
    // 發放分享者獎勵
    if (rewards.sharerReward) {
      await this.grantReward(
        shareEvent.userId,
        rewards.sharerReward,
        `分享優惠券獎勵: ${coupon.name}`
      )
    }
    
    // 發放被分享者獎勵
    if (rewards.shareeCReward && completedAction.userId) {
      await this.grantReward(
        completedAction.userId,
        rewards.shareeCReward,
        `使用分享優惠券獎勵: ${coupon.name}`
      )
    }
    
    // 更新分享事件狀態
    await this.shareEventRepository.update(shareEventId, {
      status: 'rewarded',
      rewardGrantedAt: new Date(),
      completedAction: completedAction
    })
  }

  // 病毒式傳播追蹤
  async trackViralSpread(shareEventId: string): Promise<ViralSpreadMetrics> {
    const shareEvent = await this.shareEventRepository.findById(shareEventId)
    
    // 追蹤傳播層級
    const spreadLevels = await this.calculateSpreadLevels(shareEvent)
    
    // 計算傳播效果
    const viralMetrics = await this.calculateViralMetrics(shareEvent)
    
    return {
      originalSharer: shareEvent.userId,
      totalClicks: viralMetrics.totalClicks,
      totalConversions: viralMetrics.totalConversions,
      spreadLevels: spreadLevels,
      viralCoefficient: viralMetrics.viralCoefficient,
      revenueGenerated: viralMetrics.revenueGenerated
    }
  }
}

interface ShareLinkResult {
  shareLink: ShareLink
  qrCode: string
  socialMediaContent: SocialMediaContent
  expiresAt: Date
}

interface ShareLink {
  url: string
  shortUrl: string
  trackingParams: Record<string, string>
}
```

### 4. 優惠券生命週期管理

#### 4.1 自動化生命週期處理
```typescript
class CouponLifecycleManager {
  // 優惠券狀態自動管理
  async manageLifecycle(): Promise<void> {
    // 處理即將到期的優惠券
    await this.handleExpiringCoupons()
    
    // 處理已過期的優惠券
    await this.handleExpiredCoupons()
    
    // 處理用完的優惠券
    await this.handleDepletedCoupons()
    
    // 清理無效數據
    await this.cleanupInvalidData()
  }

  // 處理即將到期的優惠券
  private async handleExpiringCoupons(): Promise<void> {
    const expiringCoupons = await this.userCouponRepository.findExpiringCoupons(
      7 // 7天內到期
    )
    
    for (const userCoupon of expiringCoupons) {
      // 發送到期提醒通知
      await this.notificationService.sendExpiryReminder(
        userCoupon.userId,
        userCoupon,
        this.calculateDaysToExpiry(userCoupon.expiryDate)
      )
      
      // 記錄提醒歷史
      await this.couponNotificationHistoryRepository.create({
        userCouponId: userCoupon.id,
        userId: userCoupon.userId,
        notificationType: 'expiry_reminder',
        sentAt: new Date()
      })
    }
  }

  // 處理已過期的優惠券
  private async handleExpiredCoupons(): Promise<void> {
    const expiredCoupons = await this.userCouponRepository.findExpiredCoupons()
    
    for (const userCoupon of expiredCoupons) {
      // 更新狀態為已過期
      await this.userCouponRepository.update(userCoupon.id, {
        status: CouponStatus.EXPIRED,
        expiredAt: new Date()
      })
      
      // 檢查是否有自動延期設定
      const coupon = await this.couponRepository.findById(userCoupon.couponId)
      if (coupon.validity.autoExtend) {
        await this.handleAutoExtension(userCoupon, coupon)
      }
      
      // 發送過期通知
      await this.notificationService.sendExpiredNotification(
        userCoupon.userId,
        userCoupon
      )
    }
  }

  // 自動延期處理
  private async handleAutoExtension(
    userCoupon: UserCoupon,
    coupon: Coupon
  ): Promise<void> {
    
    // 檢查延期條件
    const extensionEligible = await this.checkExtensionEligibility(userCoupon, coupon)
    
    if (extensionEligible) {
      const newExpiryDate = this.calculateExtendedExpiryDate(
        userCoupon.expiryDate,
        coupon.validity.validityDays || 30
      )
      
      await this.userCouponRepository.update(userCoupon.id, {
        status: CouponStatus.AVAILABLE,
        expiryDate: newExpiryDate,
        isExtended: true,
        extensionCount: (userCoupon.extensionCount || 0) + 1
      })
      
      // 發送延期通知
      await this.notificationService.sendExtensionNotification(
        userCoupon.userId,
        userCoupon,
        newExpiryDate
      )
    }
  }
}

enum CouponStatus {
  DRAFT = 'draft',                     // 草稿
  ACTIVE = 'active',                   // 啟用中
  PAUSED = 'paused',                   // 暫停
  EXPIRED = 'expired',                 // 已過期
  DEPLETED = 'depleted',               // 已用完
  CANCELLED = 'cancelled'              // 已取消
}

// 用戶優惠券狀態
enum UserCouponStatus {
  AVAILABLE = 'available',             // 可使用
  USED = 'used',                       // 已使用
  EXPIRED = 'expired',                 // 已過期
  RESERVED = 'reserved',               // 預留中
  CANCELLED = 'cancelled'              // 已取消
}
```

#### 4.2 過期優惠券處理
```typescript
interface ExpiredCouponHandler {
  // 在用戶優惠券管理中顯示過期券
  displayExpiredCoupons: boolean       // 是否顯示過期券
  expiredRetentionDays: number         // 過期券保留天數
  expiredDisplayOptions: ExpiredDisplayOptions
}

interface ExpiredDisplayOptions {
  showInSeparateSection: boolean       // 單獨區域顯示
  showExpiryReason: boolean           // 顯示過期原因
  allowReactivation: boolean          // 允許重新激活
  showSimilarCoupons: boolean         // 顯示類似可用券
}

class ExpiredCouponDisplayService {
  // 取得用戶優惠券（包含過期券）
  async getUserCoupons(userId: string): Promise<UserCouponsResponse> {
    const activeCoupons = await this.userCouponRepository.findByUserAndStatus(
      userId, 
      [UserCouponStatus.AVAILABLE, UserCouponStatus.RESERVED]
    )
    
    const expiredCoupons = await this.userCouponRepository.findExpiredByUser(userId)
    
    // 為過期券添加顯示資訊
    const expiredWithDisplayInfo = await Promise.all(
      expiredCoupons.map(async (coupon) => ({
        ...coupon,
        displayInfo: await this.generateExpiredDisplayInfo(coupon)
      }))
    )
    
    return {
      active: activeCoupons,
      expired: expiredWithDisplayInfo,
      statistics: {
        totalActive: activeCoupons.length,
        totalExpired: expiredCoupons.length,
        totalSavingsLost: expiredCoupons.reduce((sum, c) => sum + (c.potentialSavings || 0), 0)
      }
    }
  }

  // 生成過期券顯示資訊
  private async generateExpiredDisplayInfo(
    expiredCoupon: UserCoupon
  ): Promise<ExpiredDisplayInfo> {
    
    const coupon = await this.couponRepository.findById(expiredCoupon.couponId)
    
    return {
      expiryReason: this.determineExpiryReason(expiredCoupon),
      expiredDaysAgo: this.calculateExpiredDaysAgo(expiredCoupon.expiryDate),
      potentialSavings: await this.calculatePotentialSavings(coupon),
      similarAvailableCoupons: await this.findSimilarCoupons(coupon, expiredCoupon.userId),
      reactivationOption: await this.checkReactivationEligibility(expiredCoupon),
      displayStyle: {
        opacity: 0.6,
        showStrikethrough: true,
        badgeColor: 'gray',
        badgeText: '已過期'
      }
    }
  }

  // 尋找類似可用優惠券
  private async findSimilarCoupons(
    expiredCoupon: Coupon,
    userId: string
  ): Promise<SimilarCoupon[]> {
    
    const similarCoupons = await this.couponRepository.findSimilar({
      type: expiredCoupon.type,
      discountValue: expiredCoupon.discountConfig.value,
      conditions: expiredCoupon.conditions,
      excludeIds: [expiredCoupon.id]
    })
    
    const availableToUser = []
    
    for (const similar of similarCoupons) {
      const canClaim = await this.couponEligibilityService.checkEligibility(
        userId,
        similar.id
      )
      
      if (canClaim.eligible) {
        availableToUser.push({
          coupon: similar,
          claimable: true,
          reason: canClaim.reason
        })
      }
    }
    
    return availableToUser
  }
}

interface ExpiredDisplayInfo {
  expiryReason: string
  expiredDaysAgo: number
  potentialSavings: number
  similarAvailableCoupons: SimilarCoupon[]
  reactivationOption?: ReactivationOption
  displayStyle: ExpiredDisplayStyle
}

interface ExpiredDisplayStyle {
  opacity: number
  showStrikethrough: boolean
  badgeColor: string
  badgeText: string
}
```

### 5. 用戶優惠券管理界面

#### 5.1 前台用戶介面
```typescript
interface UserCouponManagementUI {
  // 我的優惠券頁面
  myCouponsPage: {
    sections: [
      'AvailableCoupons',        // 可使用的券
      'ExpiredCoupons',          // 過期的券
      'UsedCoupons',             // 已使用的券
      'RecommendedCoupons'       // 推薦優惠券
    ]
    features: [
      'category_filter',         // 分類篩選
      'sort_by_expiry',         // 依到期日排序
      'search_coupons',         // 搜索優惠券
      'bulk_share',             // 批量分享
      'usage_history'           // 使用記錄
    ]
  }

  // 過期券顯示區域
  expiredCouponsSection: {
    displayStyle: 'collapsed_expandable'  // 摺疊可展開
    showByDefault: false                   // 預設不顯示
    features: [
      'expiry_reason_tooltip',   // 過期原因提示
      'similar_coupon_suggestions', // 類似券推薦
      'reactivation_request',    // 重新激活請求
      'cleanup_expired'          // 清理過期券
    ]
  }

  // 優惠券詳情頁面
  couponDetailPage: {
    components: [
      'CouponInfo',              // 基本資訊
      'UsageConditions',         // 使用條件
      'ApplicableProducts',      // 適用商品
      'SharingOptions',          // 分享選項
      'UsageHistory'             // 使用記錄
    ]
  }
}

class UserCouponController {
  // 取得用戶優惠券列表
  async getUserCoupons(userId: string, filters: CouponFilters): Promise<UserCouponsResponse> {
    const coupons = await this.userCouponService.getUserCoupons(userId, filters)
    
    // 分組處理
    const grouped = {
      available: coupons.filter(c => c.status === UserCouponStatus.AVAILABLE),
      expiring: coupons.filter(c => 
        c.status === UserCouponStatus.AVAILABLE && 
        this.isExpiringSoon(c.expiryDate, 7)
      ),
      expired: coupons.filter(c => c.status === UserCouponStatus.EXPIRED),
      used: coupons.filter(c => c.status === UserCouponStatus.USED)
    }
    
    return {
      groups: grouped,
      statistics: this.calculateUserCouponStats(coupons),
      recommendations: await this.getRecommendedCoupons(userId)
    }
  }

  // 分享優惠券
  async shareCoupon(
    userId: string,
    couponId: string,
    shareRequest: ShareCouponRequest
  ): Promise<ShareResult> {
    
    // 檢查分享權限
    await this.validateSharingPermission(userId, couponId)
    
    // 生成分享內容
    const shareContent = await this.couponSharingService.generateShareContent(
      userId,
      couponId,
      shareRequest
    )
    
    // 記錄分享行為
    await this.analyticsService.trackCouponShare(userId, couponId, shareRequest.platform)
    
    return shareContent
  }

  // 清理過期優惠券
  async cleanupExpiredCoupons(
    userId: string,
    olderThanDays: number = 30
  ): Promise<CleanupResult> {
    
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays)
    
    const expiredCoupons = await this.userCouponRepository.findExpiredBefore(userId, cutoffDate)
    
    // 軟刪除過期券
    await this.userCouponRepository.softDeleteBatch(
      expiredCoupons.map(c => c.id)
    )
    
    return {
      cleanedCount: expiredCoupons.length,
      freedSpace: this.calculateFreedSpace(expiredCoupons),
      cleanedCoupons: expiredCoupons.map(c => ({
        name: c.name,
        expiredAt: c.expiredAt
      }))
    }
  }
}
```

### 6. 優惠券效果分析

#### 6.1 使用統計與分析
```typescript
class CouponAnalyticsService {
  // 優惠券效果分析
  async generateCouponAnalytics(
    couponId: string,
    dateRange: DateRange
  ): Promise<CouponAnalytics> {
    
    const coupon = await this.couponRepository.findById(couponId)
    const usage = await this.couponUsageRepository.findByCouponAndDateRange(couponId, dateRange)
    const distribution = await this.couponDistributionRepository.findByCouponAndDateRange(couponId, dateRange)
    
    const analytics: CouponAnalytics = {
      basic: {
        totalDistributed: distribution.length,
        totalUsed: usage.length,
        usageRate: usage.length / distribution.length,
        totalDiscount: usage.reduce((sum, u) => sum + u.discountAmount, 0),
        averageDiscount: usage.length > 0 ? usage.reduce((sum, u) => sum + u.discountAmount, 0) / usage.length : 0
      },
      
      temporal: await this.analyzeTemporalPatterns(usage, dateRange),
      demographic: await this.analyzeDemographicUsage(usage),
      behavioral: await this.analyzeBehavioralPatterns(usage),
      financial: await this.analyzeFinancialImpact(coupon, usage),
      sharing: await this.analyzeSharingMetrics(couponId, dateRange)
    }
    
    return analytics
  }

  // 分享效果分析
  private async analyzeSharingMetrics(
    couponId: string,
    dateRange: DateRange
  ): Promise<SharingAnalytics> {
    
    const shareEvents = await this.shareEventRepository.findByCouponAndDateRange(couponId, dateRange)
    const shareClicks = await this.shareClickRepository.findByCouponAndDateRange(couponId, dateRange)
    
    return {
      totalShares: shareEvents.length,
      totalClicks: shareClicks.length,
      clickThroughRate: shareClicks.length / shareEvents.length,
      shareChannels: this.groupByShareChannel(shareEvents),
      viralCoefficient: await this.calculateViralCoefficient(shareEvents),
      shareConversion: await this.calculateShareConversion(shareEvents, shareClicks),
      topSharers: await this.identifyTopSharers(shareEvents)
    }
  }

  // ROI 計算
  private async analyzeFinancialImpact(
    coupon: Coupon,
    usage: CouponUsage[]
  ): Promise<FinancialImpact> {
    
    const totalDiscountGiven = usage.reduce((sum, u) => sum + u.discountAmount, 0)
    const totalRevenueGenerated = usage.reduce((sum, u) => sum + u.orderAmount, 0)
    const distributionCost = await this.calculateDistributionCost(coupon)
    
    const roi = (totalRevenueGenerated - totalDiscountGiven - distributionCost) / (totalDiscountGiven + distributionCost)
    
    return {
      totalDiscountGiven,
      totalRevenueGenerated,
      distributionCost,
      netProfit: totalRevenueGenerated - totalDiscountGiven - distributionCost,
      roi: roi,
      customerAcquisitionCost: distributionCost / usage.length,
      customerLifetimeValue: await this.calculateCLV(usage)
    }
  }
}

interface CouponAnalytics {
  basic: BasicAnalytics
  temporal: TemporalAnalytics
  demographic: DemographicAnalytics
  behavioral: BehavioralAnalytics
  financial: FinancialImpact
  sharing: SharingAnalytics
}
```

### 7. API 介面規格

#### 7.1 後台API (Admin Panel)
```typescript
// 優惠券管理
GET /admin/api/coupons
POST /admin/api/coupons
GET /admin/api/coupons/:id
PUT /admin/api/coupons/:id
DELETE /admin/api/coupons/:id

// 疊加規則管理
GET /admin/api/coupon-stacking-rules
POST /admin/api/coupon-stacking-rules
PUT /admin/api/coupon-stacking-rules/:id

// 優惠券分發
POST /admin/api/coupons/:id/distribute
GET /admin/api/coupon-distributions
POST /admin/api/coupon-distributions/bulk

// 效果分析
GET /admin/api/coupons/:id/analytics
GET /admin/api/coupon-performance-report
POST /admin/api/coupons/export-usage-data
```

#### 7.2 前台API (Customer Site)
```typescript
// 用戶優惠券管理
GET /api/user/coupons
GET /api/user/coupons/:id
POST /api/user/coupons/:id/share
DELETE /api/user/coupons/expired/cleanup

// 優惠券使用
POST /api/cart/apply-coupon
POST /api/cart/calculate-stacked-discount
DELETE /api/cart/remove-coupon

// 優惠券兌換
POST /api/coupons/redeem-code
POST /api/coupons/claim-shared/:shareToken
```

### 8. 資料庫設計

#### 8.1 核心資料表
```sql
-- 優惠券表
CREATE TABLE coupons (
  id VARCHAR(36) PRIMARY KEY,
  code VARCHAR(100) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  type ENUM('fixed_amount', 'percentage', 'free_shipping', 'bogo', 'bundle_discount', 'member_exclusive', 'new_user_bonus', 'birthday_gift', 'cashback'),
  discount_config JSON NOT NULL,
  conditions JSON,
  limitations JSON,
  validity JSON NOT NULL,
  distribution_config JSON,
  stacking_rules JSON,
  sharing_config JSON,
  status ENUM('draft', 'active', 'paused', 'expired', 'depleted', 'cancelled') DEFAULT 'draft',
  metadata JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  INDEX idx_coupons_code (code),
  INDEX idx_coupons_type (type),
  INDEX idx_coupons_status (status)
);

-- 用戶優惠券表
CREATE TABLE user_coupons (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36) NOT NULL,
  coupon_id VARCHAR(36) NOT NULL,
  coupon_code VARCHAR(100) NOT NULL,
  status ENUM('available', 'used', 'expired', 'reserved', 'cancelled') DEFAULT 'available',
  obtained_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  used_at TIMESTAMP NULL,
  order_id VARCHAR(36) NULL,
  discount_amount DECIMAL(10,2) NULL,
  is_extended BOOLEAN DEFAULT FALSE,
  extension_count INT DEFAULT 0,
  source VARCHAR(100), -- 'manual', 'auto_issue', 'shared', 'redeemed'
  share_token VARCHAR(255) NULL,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (coupon_id) REFERENCES coupons(id) ON DELETE CASCADE,
  FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE SET NULL,
  
  INDEX idx_user_coupons_user (user_id),
  INDEX idx_user_coupons_coupon (coupon_id),
  INDEX idx_user_coupons_status (status),
  INDEX idx_user_coupons_expires (expires_at),
  INDEX idx_user_coupons_share_token (share_token)
);

-- 優惠券分享事件表
CREATE TABLE coupon_share_events (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36) NOT NULL,
  coupon_id VARCHAR(36) NOT NULL,
  share_type ENUM('direct_link', 'qr_code', 'social_media', 'referral_code', 'group_purchase'),
  share_token VARCHAR(255) UNIQUE NOT NULL,
  share_link VARCHAR(500) NOT NULL,
  clicks_count INT DEFAULT 0,
  conversions_count INT DEFAULT 0,
  status ENUM('active', 'expired', 'rewarded') DEFAULT 'active',
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (coupon_id) REFERENCES coupons(id) ON DELETE CASCADE,
  
  INDEX idx_share_events_user (user_id),
  INDEX idx_share_events_coupon (coupon_id),
  INDEX idx_share_events_token (share_token)
);

-- 優惠券使用記錄表
CREATE TABLE coupon_usage_history (
  id VARCHAR(36) PRIMARY KEY,
  user_coupon_id VARCHAR(36) NOT NULL,
  user_id VARCHAR(36) NOT NULL,
  coupon_id VARCHAR(36) NOT NULL,
  order_id VARCHAR(36) NOT NULL,
  discount_amount DECIMAL(10,2) NOT NULL,
  original_order_amount DECIMAL(12,2) NOT NULL,
  final_order_amount DECIMAL(12,2) NOT NULL,
  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  stacking_info JSON, -- 疊加使用資訊
  
  FOREIGN KEY (user_coupon_id) REFERENCES user_coupons(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (coupon_id) REFERENCES coupons(id) ON DELETE CASCADE,
  FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
  
  INDEX idx_usage_history_user (user_id),
  INDEX idx_usage_history_coupon (coupon_id),
  INDEX idx_usage_history_order (order_id),
  INDEX idx_usage_history_applied (applied_at)
);
```

## 整合規格

### 與節慶管理整合
- 節慶活動專屬優惠券自動發放
- 節慶期間的疊加優惠規則
- 節慶主題優惠券設計

### 與會員系統整合
- 會員等級專屬優惠券
- 會員生日優惠券自動發送
- 會員點數兌換優惠券

### 與行銷活動整合
- 行銷活動的優惠券配置
- 個人化優惠券推薦
- 活動效果的優惠券分析

### 與通知管理整合
- 優惠券到期提醒通知
- 優惠券分享成功通知
- 新優惠券獲得通知

### 與訂單系統整合
- 結帳時優惠券套用
- 訂單金額計算整合
- 退款時優惠券處理

## 效能考量

### 快取策略
- 優惠券基本資訊快取 (TTL: 2小時)
- 疊加規則計算結果快取 (TTL: 1小時)
- 用戶優惠券列表快取 (TTL: 30分鐘)

### 效能目標
- 優惠券驗證時間 < 100ms
- 疊加規則計算時間 < 200ms
- 優惠券列表載入時間 < 300ms
- 分享連結生成時間 < 150ms

### 可靠性設計
- 優惠券使用的原子性操作
- 疊加計算的一致性保證
- 分享獎勵的防重複機制
- 過期處理的定時任務

---

本模組確保優惠券管理的完整性和用戶體驗，提供靈活的疊加規則、社群分享功能，以及自動化的生命週期管理，同時在用戶介面中妥善處理過期優惠券的顯示。