# 庫存管理系統

## 系統概覽

完整的庫存管理系統，支援多倉庫管理、多種成本計算方法、階層式庫存展示、完整的入出庫單據流程、綠界物流整合，以及與18個後台模組的深度整合。

## 核心特性

- **多倉庫支援**: 支援動態新增倉庫，多倉庫庫存管理
- **多成本計算**: FIFO、LIFO、加權平均成本計算方法
- **階層式展示**: 商品/贈品收合列表，變體庫存自動加總
- **完整單據流程**: 入庫單、揀貨單、出貨單、質檢單
- **綠界物流整合**: 自動建立物流訂單、狀態同步
- **預售支援**: 支援預購功能，允許負庫存銷售
- **條碼掃描**: 支援QR Code/條碼掃描入出庫
- **智能警示**: 可設定的低庫存警示邏輯
- **18模組整合**: 與所有後台模組深度整合

## 資料庫設計

### warehouses 表 (倉庫資訊)
```sql
CREATE TABLE warehouses (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name VARCHAR(100) NOT NULL,              -- 倉庫名稱
  code VARCHAR(20) UNIQUE NOT NULL,        -- 倉庫代碼
  address TEXT,                            -- 倉庫地址
  manager_name VARCHAR(50),                -- 倉庫管理員
  contact_phone VARCHAR(20),               -- 聯絡電話
  is_active BOOLEAN DEFAULT TRUE,          -- 是否啟用
  is_default BOOLEAN DEFAULT FALSE,        -- 是否為預設倉庫
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### inventory 表 (庫存主表)
```sql
CREATE TABLE inventory (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,           -- 倉庫ID
  sku_id INTEGER NOT NULL,                 -- SKU ID (包含商品和贈品)
  current_stock INTEGER DEFAULT 0,         -- 當前庫存數量
  reserved_stock INTEGER DEFAULT 0,        -- 預留庫存 (購物車)
  available_stock INTEGER GENERATED ALWAYS AS (current_stock - reserved_stock) STORED, -- 可用庫存
  safe_stock INTEGER DEFAULT 0,            -- 安全庫存水位
  max_stock INTEGER DEFAULT 1000,          -- 最大庫存限制
  allow_negative_stock BOOLEAN DEFAULT FALSE, -- 是否允許負庫存(預售)
  
  -- 成本資訊
  total_cost DECIMAL(12,2) DEFAULT 0,      -- 總成本
  average_cost DECIMAL(10,2) DEFAULT 0,    -- 平均成本
  
  -- 狀態
  last_in_date DATETIME,                   -- 最後進貨日期
  last_out_date DATETIME,                  -- 最後出貨日期
  last_count_date DATETIME,                -- 最後盤點日期
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  UNIQUE(warehouse_id, sku_id)
);
```

### inventory_transactions 表 (庫存異動記錄)
```sql
CREATE TABLE inventory_transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  transaction_type ENUM(
    'in_purchase',      -- 採購入庫
    'in_return',        -- 退貨入庫
    'in_adjustment',    -- 盤點調增
    'in_transfer',      -- 調撥入庫
    'out_sale',         -- 銷售出庫
    'out_damaged',      -- 損耗出庫
    'out_adjustment',   -- 盤點調減
    'out_transfer',     -- 調撥出庫
    'reserve',          -- 預留庫存
    'release'           -- 釋放預留
  ) NOT NULL,
  
  quantity INTEGER NOT NULL,               -- 異動數量 (正數=入庫，負數=出庫)
  unit_cost DECIMAL(10,2),                -- 單位成本 (入庫時記錄)
  total_cost DECIMAL(12,2),               -- 總成本
  
  -- 關聯資訊
  reference_type VARCHAR(50),              -- 關聯類型 (order, purchase, inbound_order)
  reference_id INTEGER,                    -- 關聯ID
  
  -- 庫存狀態快照
  stock_before INTEGER NOT NULL,          -- 異動前庫存
  stock_after INTEGER NOT NULL,           -- 異動後庫存
  
  note TEXT,                              -- 備註
  operator_id INTEGER NOT NULL,           -- 操作人員ID
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  FOREIGN KEY (operator_id) REFERENCES admin_users(id)
);
```

### inventory_batches 表 (庫存批次管理)
```sql
CREATE TABLE inventory_batches (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  batch_number VARCHAR(50) NOT NULL,       -- 批次號
  
  -- 批次資訊
  original_quantity INTEGER NOT NULL,     -- 原始數量
  remaining_quantity INTEGER NOT NULL,    -- 剩餘數量
  unit_cost DECIMAL(10,2) NOT NULL,       -- 批次單位成本
  
  -- 日期資訊
  received_date DATETIME NOT NULL,        -- 到貨日期
  expiry_date DATETIME,                   -- 過期日期 (如適用)
  
  -- 關聯資訊
  purchase_order_id INTEGER,             -- 採購單ID
  supplier_id INTEGER,                   -- 供應商ID
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  UNIQUE(warehouse_id, sku_id, batch_number)
);
```

### cost_calculation_methods 表 (成本計算方法)
```sql
CREATE TABLE cost_calculation_methods (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER,                             -- NULL = 全倉庫預設
  method ENUM('fifo', 'lifo', 'weighted_average') NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  UNIQUE(warehouse_id, sku_id)
);
```

### inbound_orders 表 (入庫單)
```sql
CREATE TABLE inbound_orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  order_number VARCHAR(50) UNIQUE NOT NULL,    -- 入庫單號 (格式: IB20240301001)
  warehouse_id INTEGER NOT NULL,
  order_type ENUM('purchase', 'return', 'adjustment', 'transfer') NOT NULL,
  source_type VARCHAR(50),                     -- 來源類型 (purchase_order, return_request)
  source_id INTEGER,                          -- 來源ID
  
  -- 狀態控制
  status ENUM('draft', 'pending', 'approved', 'completed', 'cancelled') DEFAULT 'draft',
  total_quantity INTEGER DEFAULT 0,
  total_cost DECIMAL(12,2) DEFAULT 0,
  
  -- 審核資訊
  created_by INTEGER NOT NULL,
  approved_by INTEGER,
  completed_by INTEGER,
  
  -- 時間戳記
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  approved_at DATETIME,
  completed_at DATETIME,
  
  notes TEXT,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (created_by) REFERENCES admin_users(id),
  FOREIGN KEY (approved_by) REFERENCES admin_users(id),
  FOREIGN KEY (completed_by) REFERENCES admin_users(id)
);
```

### inbound_order_items 表 (入庫單明細)
```sql
CREATE TABLE inbound_order_items (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  inbound_order_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  batch_number VARCHAR(50) NOT NULL,
  
  planned_quantity INTEGER NOT NULL,           -- 計劃入庫數量
  actual_quantity INTEGER DEFAULT 0,          -- 實際入庫數量
  unit_cost DECIMAL(10,2) NOT NULL,
  total_cost DECIMAL(12,2) GENERATED ALWAYS AS (actual_quantity * unit_cost) STORED,
  
  -- 質檢資訊 (退貨入庫用)
  quality_check_status ENUM('pending', 'passed', 'failed', 'not_required') DEFAULT 'not_required',
  quality_check_by INTEGER,
  quality_check_at DATETIME,
  quality_notes TEXT,
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (inbound_order_id) REFERENCES inbound_orders(id) ON DELETE CASCADE,
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  FOREIGN KEY (quality_check_by) REFERENCES admin_users(id)
);
```

### picking_orders 表 (揀貨單)
```sql
CREATE TABLE picking_orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  picking_number VARCHAR(50) UNIQUE NOT NULL,  -- 揀貨單號 (格式: PK20240301001)
  warehouse_id INTEGER NOT NULL,
  order_id INTEGER NOT NULL,                  -- 關聯訂單ID
  
  status ENUM('pending', 'picking', 'completed', 'cancelled') DEFAULT 'pending',
  total_items INTEGER DEFAULT 0,
  picked_items INTEGER DEFAULT 0,
  
  -- 揀貨人員
  picker_id INTEGER,
  picking_started_at DATETIME,
  picking_completed_at DATETIME,
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  notes TEXT,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (picker_id) REFERENCES admin_users(id)
);
```

### picking_order_items 表 (揀貨單明細)
```sql
CREATE TABLE picking_order_items (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  picking_order_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  
  required_quantity INTEGER NOT NULL,         -- 需要揀貨數量
  picked_quantity INTEGER DEFAULT 0,         -- 已揀貨數量
  
  -- 掃碼記錄
  scanned_at DATETIME,
  scanned_by INTEGER,
  batch_numbers JSON,                         -- 掃描的批次號記錄
  
  FOREIGN KEY (picking_order_id) REFERENCES picking_orders(id) ON DELETE CASCADE,
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  FOREIGN KEY (scanned_by) REFERENCES admin_users(id)
);
```

### outbound_orders 表 (出貨單)
```sql
CREATE TABLE outbound_orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  outbound_number VARCHAR(50) UNIQUE NOT NULL, -- 出貨單號 (格式: OB20240301001)
  warehouse_id INTEGER NOT NULL,
  order_id INTEGER NOT NULL,
  picking_order_id INTEGER,
  
  status ENUM('pending', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
  
  -- 物流資訊
  logistics_provider VARCHAR(50) DEFAULT 'ecpay', -- 物流商 (ecpay)
  tracking_number VARCHAR(100),               -- 追蹤號碼
  shipping_method VARCHAR(50),                -- 配送方式
  
  -- 綠界物流整合
  ecpay_logistics_id VARCHAR(100),           -- 綠界物流單號
  ecpay_status VARCHAR(50),                  -- 綠界狀態
  last_sync_at DATETIME,                     -- 最後同步時間
  
  -- 收件資訊
  recipient_name VARCHAR(100),
  recipient_phone VARCHAR(20),
  shipping_address TEXT,
  
  -- 時間戳記
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  shipped_at DATETIME,
  delivered_at DATETIME,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (picking_order_id) REFERENCES picking_orders(id)
);
```

### inventory_alerts 表 (庫存警示)
```sql
CREATE TABLE inventory_alerts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  alert_type ENUM('low_stock', 'out_of_stock', 'overstock', 'expiry_warning') NOT NULL,
  current_stock INTEGER NOT NULL,
  threshold_value INTEGER,                -- 觸發閾值
  alert_message TEXT NOT NULL,
  is_resolved BOOLEAN DEFAULT FALSE,
  resolved_at DATETIME,
  resolved_by INTEGER,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  FOREIGN KEY (resolved_by) REFERENCES admin_users(id)
);
```

### inventory_counts 表 (盤點記錄)
```sql
CREATE TABLE inventory_counts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  count_date DATE NOT NULL,
  status ENUM('planning', 'in_progress', 'completed', 'cancelled') DEFAULT 'planning',
  total_skus INTEGER DEFAULT 0,           -- 盤點SKU總數
  completed_skus INTEGER DEFAULT 0,       -- 已完成SKU數
  discrepancy_count INTEGER DEFAULT 0,    -- 差異項目數
  
  -- 盤點設定
  is_blind_count BOOLEAN DEFAULT FALSE,   -- 是否盲盤 (系統設定)
  count_type ENUM('full', 'cycle', 'spot') DEFAULT 'full', -- 盤點類型
  
  -- 操作人員
  created_by INTEGER NOT NULL,
  started_by INTEGER,
  completed_by INTEGER,
  
  notes TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  started_at DATETIME,
  completed_at DATETIME,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (created_by) REFERENCES admin_users(id),
  FOREIGN KEY (started_by) REFERENCES admin_users(id),
  FOREIGN KEY (completed_by) REFERENCES admin_users(id)
);
```

### inventory_count_details 表 (盤點明細)
```sql
CREATE TABLE inventory_count_details (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  count_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  
  -- 盤點資料
  system_quantity INTEGER NOT NULL,       -- 系統庫存數量
  actual_quantity INTEGER,                -- 實際盤點數量
  difference_quantity INTEGER GENERATED ALWAYS AS (actual_quantity - system_quantity) STORED,
  
  -- 成本資訊
  unit_cost DECIMAL(10,2) NOT NULL,
  cost_difference DECIMAL(12,2) GENERATED ALWAYS AS (difference_quantity * unit_cost) STORED,
  
  -- 盤點狀態
  status ENUM('pending', 'counted', 'adjusted') DEFAULT 'pending',
  note TEXT,
  counted_by INTEGER,
  counted_at DATETIME,
  
  FOREIGN KEY (count_id) REFERENCES inventory_counts(id) ON DELETE CASCADE,
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  FOREIGN KEY (counted_by) REFERENCES admin_users(id),
  UNIQUE(count_id, sku_id)
);
```

## 核心業務邏輯

### 庫存管理器主類
```javascript
// services/InventoryManager.js
import { FIFOCalculator } from './cost-calculators/FIFOCalculator'
import { LIFOCalculator } from './cost-calculators/LIFOCalculator'
import { WeightedAverageCalculator } from './cost-calculators/WeightedAverageCalculator'
import { EcpayLogisticsService } from './EcpayLogisticsService'

export class InventoryManager {
  constructor(db) {
    this.db = db
    this.costCalculators = {
      'fifo': new FIFOCalculator(db),
      'lifo': new LIFOCalculator(db),
      'weighted_average': new WeightedAverageCalculator(db)
    }
    this.ecpayLogistics = new EcpayLogisticsService()
  }

  /**
   * 支援預售的庫存檢查
   */
  async checkStockAvailabilityForPreorder(skuId, quantity, warehouseId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    const inventory = await this.db.prepare(`
      SELECT 
        i.available_stock, 
        i.reserved_stock, 
        i.allow_negative_stock,
        ps.sku,
        CASE 
          WHEN ps.product_id IS NOT NULL THEN 'product'
          ELSE 'gift'
        END as item_type
      FROM inventory i
      LEFT JOIN product_skus ps ON i.sku_id = ps.id
      LEFT JOIN gift_skus gs ON i.sku_id = gs.id
      WHERE i.sku_id = ? AND i.warehouse_id = ?
    `).bind(skuId, warehouse.id).first()

    if (!inventory) {
      return { available: false, reason: 'SKU不存在於指定倉庫' }
    }

    // 支援預售：允許負庫存
    if (inventory.allow_negative_stock || inventory.available_stock >= quantity) {
      return { 
        available: true, 
        currentStock: inventory.available_stock,
        isPreorder: inventory.available_stock < quantity,
        itemType: inventory.item_type
      }
    }

    return {
      available: false,
      reason: '庫存不足且不允許預售',
      currentStock: inventory.available_stock
    }
  }

  /**
   * 預留庫存 (購物車加入商品時)
   * 預留時效由系統設定決定
   */
  async reserveStock(skuId, quantity, sessionId, warehouseId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    // 檢查庫存是否充足 (支援預售)
    const stockCheck = await this.checkStockAvailabilityForPreorder(skuId, quantity, warehouse.id)
    if (!stockCheck.available) {
      throw new Error(`無法預留庫存: ${stockCheck.reason}`)
    }

    const transaction = this.db.transaction(async () => {
      // 更新庫存預留數量
      await this.db.prepare(`
        UPDATE inventory 
        SET reserved_stock = reserved_stock + ?,
            updated_at = CURRENT_TIMESTAMP
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(quantity, skuId, warehouse.id).run()

      // 記錄異動
      await this.recordTransaction({
        warehouseId: warehouse.id,
        skuId,
        type: 'reserve',
        quantity: -quantity, // 負數表示預留
        referenceType: 'cart_session',
        referenceId: sessionId,
        note: `購物車預留庫存 (Session: ${sessionId})${stockCheck.isPreorder ? ' - 預售' : ''}`
      })

      // 檢查是否需要創建低庫存警示
      await this.checkAndCreateAlerts(warehouse.id, skuId)
    })

    await transaction()
    
    console.log(`✅ 庫存預留成功: SKU ${skuId}, 數量 ${quantity}${stockCheck.isPreorder ? ' (預售)' : ''}`)
    return { success: true, isPreorder: stockCheck.isPreorder }
  }

  /**
   * 根據設定的計算方法處理出庫成本
   */
  async processStockOutWithMethod(warehouseId, skuId, quantity) {
    // 獲取該SKU的成本計算方法 (SKU特定設定優先於倉庫預設)
    const method = await this.db.prepare(`
      SELECT method FROM cost_calculation_methods
      WHERE warehouse_id = ? AND (sku_id = ? OR sku_id IS NULL)
        AND is_active = TRUE
      ORDER BY sku_id DESC
      LIMIT 1
    `).bind(warehouseId, skuId).first()

    const calculationMethod = method?.method || 'fifo'
    const calculator = this.costCalculators[calculationMethod]
    
    console.log(`💰 使用 ${calculationMethod.toUpperCase()} 成本計算方法`)
    return await calculator.calculateStockOut(warehouseId, skuId, quantity)
  }

  /**
   * 建立入庫單 (從採購單自動轉換)
   */
  async createInboundOrderFromPurchase(purchaseOrderId, warehouseId, createdBy) {
    const transaction = this.db.transaction(async () => {
      // 生成入庫單號
      const orderNumber = await this.generateOrderNumber('IB')
      
      // 創建入庫單
      const inboundResult = await this.db.prepare(`
        INSERT INTO inbound_orders 
        (order_number, warehouse_id, order_type, source_type, source_id, status, created_by)
        VALUES (?, ?, 'purchase', 'purchase_order', ?, 'pending', ?)
      `).bind(orderNumber, warehouseId, purchaseOrderId, createdBy).run()

      const inboundOrderId = inboundResult.meta.last_row_id

      // 從採購單複製商品明細 (包含商品和贈品)
      const purchaseItems = await this.db.prepare(`
        SELECT sku_id, quantity, unit_cost, batch_number
        FROM purchase_order_items
        WHERE purchase_order_id = ?
      `).bind(purchaseOrderId).all()

      let totalQuantity = 0
      let totalCost = 0

      for (const item of purchaseItems) {
        await this.db.prepare(`
          INSERT INTO inbound_order_items
          (inbound_order_id, sku_id, batch_number, planned_quantity, unit_cost)
          VALUES (?, ?, ?, ?, ?)
        `).bind(
          inboundOrderId, item.sku_id, item.batch_number, 
          item.quantity, item.unit_cost
        ).run()

        totalQuantity += item.quantity
        totalCost += item.quantity * item.unit_cost
      }

      // 更新入庫單總計
      await this.db.prepare(`
        UPDATE inbound_orders
        SET total_quantity = ?, total_cost = ?
        WHERE id = ?
      `).bind(totalQuantity, totalCost, inboundOrderId).run()

      return { inboundOrderId, orderNumber }
    })

    return await transaction()
  }

  /**
   * 主管審核入庫單
   */
  async approveInboundOrder(inboundOrderId, approvedBy) {
    const transaction = this.db.transaction(async () => {
      // 檢查入庫單狀態
      const inboundOrder = await this.db.prepare(`
        SELECT * FROM inbound_orders WHERE id = ? AND status = 'pending'
      `).bind(inboundOrderId).first()

      if (!inboundOrder) {
        throw new Error('入庫單不存在或狀態不正確')
      }

      // 更新入庫單狀態
      await this.db.prepare(`
        UPDATE inbound_orders
        SET status = 'approved', approved_by = ?, approved_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(approvedBy, inboundOrderId).run()

      // 自動執行入庫
      await this.executeInboundOrder(inboundOrderId, approvedBy)
    })

    await transaction()
    console.log(`✅ 入庫單 ${inboundOrderId} 審核通過並已入庫`)
  }

  /**
   * 執行入庫操作
   */
  async executeInboundOrder(inboundOrderId, operatorId) {
    const inboundOrder = await this.db.prepare(`
      SELECT * FROM inbound_orders WHERE id = ?
    `).bind(inboundOrderId).first()

    const items = await this.db.prepare(`
      SELECT * FROM inbound_order_items 
      WHERE inbound_order_id = ?
        AND (quality_check_status = 'not_required' OR quality_check_status = 'passed')
    `).bind(inboundOrderId).all()

    const transaction = this.db.transaction(async () => {
      for (const item of items) {
        // 執行庫存入庫
        await this.stockIn(
          item.sku_id,
          item.planned_quantity,
          item.unit_cost,
          item.batch_number,
          inboundOrder.warehouse_id,
          'inbound_order',
          inboundOrderId
        )

        // 更新入庫單明細實際數量
        await this.db.prepare(`
          UPDATE inbound_order_items
          SET actual_quantity = planned_quantity
          WHERE id = ?
        `).bind(item.id).run()
      }

      // 更新入庫單狀態為已完成
      await this.db.prepare(`
        UPDATE inbound_orders
        SET status = 'completed', completed_by = ?, completed_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(operatorId, inboundOrderId).run()
    })

    await transaction()
    console.log(`📥 入庫單 ${inboundOrderId} 執行完成`)
  }

  /**
   * 從訂單自動建立揀貨單
   */
  async createPickingOrderFromOrder(orderId, warehouseId) {
    const transaction = this.db.transaction(async () => {
      const pickingNumber = await this.generateOrderNumber('PK')
      
      // 創建揀貨單
      const pickingResult = await this.db.prepare(`
        INSERT INTO picking_orders
        (picking_number, warehouse_id, order_id, status)
        VALUES (?, ?, ?, 'pending')
      `).bind(pickingNumber, warehouseId, orderId).run()

      const pickingOrderId = pickingResult.meta.last_row_id

      // 從訂單複製商品明細 (包含商品和贈品)
      const orderItems = await this.db.prepare(`
        SELECT sku_id, quantity FROM order_items WHERE order_id = ?
      `).bind(orderId).all()

      let totalItems = 0
      for (const item of orderItems) {
        await this.db.prepare(`
          INSERT INTO picking_order_items
          (picking_order_id, sku_id, required_quantity)
          VALUES (?, ?, ?)
        `).bind(pickingOrderId, item.sku_id, item.quantity).run()
        
        totalItems++
      }

      // 更新揀貨單總項目數
      await this.db.prepare(`
        UPDATE picking_orders SET total_items = ? WHERE id = ?
      `).bind(totalItems, pickingOrderId).run()

      return { pickingOrderId, pickingNumber }
    })

    return await transaction()
  }

  /**
   * 掃碼揀貨 (支援QR Code和條碼)
   */
  async scanPickingItem(pickingOrderId, skuId, scannedQuantity, scannedBy, batchNumbers = []) {
    const transaction = this.db.transaction(async () => {
      // 更新揀貨明細
      await this.db.prepare(`
        UPDATE picking_order_items
        SET picked_quantity = picked_quantity + ?,
            scanned_at = CURRENT_TIMESTAMP,
            scanned_by = ?,
            batch_numbers = ?
        WHERE picking_order_id = ? AND sku_id = ?
      `).bind(
        scannedQuantity, scannedBy, JSON.stringify(batchNumbers),
        pickingOrderId, skuId
      ).run()

      // 檢查是否所有商品都已揀貨完成
      const completionCheck = await this.db.prepare(`
        SELECT 
          COUNT(*) as total_items,
          COUNT(CASE WHEN picked_quantity >= required_quantity THEN 1 END) as completed_items
        FROM picking_order_items
        WHERE picking_order_id = ?
      `).bind(pickingOrderId).first()

      // 更新揀貨單進度
      await this.db.prepare(`
        UPDATE picking_orders
        SET picked_items = ?
        WHERE id = ?
      `).bind(completionCheck.completed_items, pickingOrderId).run()

      // 如果全部揀貨完成，更新狀態
      if (completionCheck.completed_items === completionCheck.total_items) {
        await this.db.prepare(`
          UPDATE picking_orders
          SET status = 'completed', picking_completed_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(pickingOrderId).run()

        return { completed: true }
      }

      return { completed: false, progress: `${completionCheck.completed_items}/${completionCheck.total_items}` }
    })

    return await transaction()
  }

  /**
   * 員工簽核揀貨單，自動轉出貨單並整合綠界物流
   */
  async confirmPickingAndCreateOutbound(pickingOrderId, employeeId) {
    const transaction = this.db.transaction(async () => {
      const pickingOrder = await this.db.prepare(`
        SELECT po.*, o.recipient_name, o.recipient_phone, o.shipping_address
        FROM picking_orders po
        JOIN orders o ON po.order_id = o.id
        WHERE po.id = ?
      `).bind(pickingOrderId).first()

      // 生成出貨單
      const outboundNumber = await this.generateOrderNumber('OB')
      
      const outboundResult = await this.db.prepare(`
        INSERT INTO outbound_orders
        (outbound_number, warehouse_id, order_id, picking_order_id, status, 
         recipient_name, recipient_phone, shipping_address)
        VALUES (?, ?, ?, ?, 'pending', ?, ?, ?)
      `).bind(
        outboundNumber, pickingOrder.warehouse_id, 
        pickingOrder.order_id, pickingOrderId,
        pickingOrder.recipient_name, pickingOrder.recipient_phone, pickingOrder.shipping_address
      ).run()

      const outboundOrderId = outboundResult.meta.last_row_id

      // 實際扣減庫存
      const pickingItems = await this.db.prepare(`
        SELECT sku_id, picked_quantity FROM picking_order_items
        WHERE picking_order_id = ?
      `).bind(pickingOrderId).all()

      for (const item of pickingItems) {
        await this.confirmStockOut(
          item.sku_id, item.picked_quantity, 
          pickingOrder.order_id, pickingOrder.warehouse_id
        )
      }

      // 傳送到綠界物流
      const ecpayResult = await this.ecpayLogistics.createShipment({
        outboundOrderId,
        recipientName: pickingOrder.recipient_name,
        recipientPhone: pickingOrder.recipient_phone,
        shippingAddress: pickingOrder.shipping_address,
        items: pickingItems
      })
      
      if (ecpayResult.success) {
        await this.db.prepare(`
          UPDATE outbound_orders
          SET ecpay_logistics_id = ?, 
              tracking_number = ?,
              ecpay_status = 'shipped',
              status = 'shipped',
              shipped_at = CURRENT_TIMESTAMP,
              last_sync_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(
          ecpayResult.logistics_id,
          ecpayResult.tracking_number,
          outboundOrderId
        ).run()

        // 同步更新訂單狀態
        await this.db.prepare(`
          UPDATE orders SET status = 'shipped', shipped_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(pickingOrder.order_id).run()
      }

      return { 
        outboundOrderId, 
        outboundNumber, 
        ecpayResult,
        trackingNumber: ecpayResult.tracking_number
      }
    })

    return await transaction()
  }

  /**
   * 確認出庫 (訂單成功時)
   */
  async confirmStockOut(skuId, quantity, orderId, warehouseId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    const transaction = this.db.transaction(async () => {
      // 先釋放預留，再執行實際出庫
      await this.db.prepare(`
        UPDATE inventory 
        SET current_stock = current_stock - ?,
            reserved_stock = GREATEST(0, reserved_stock - ?),
            last_out_date = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(quantity, quantity, skuId, warehouse.id).run()

      // 使用設定的方法計算成本並更新批次
      const totalCost = await this.processStockOutWithMethod(warehouse.id, skuId, quantity)

      // 記錄異動
      await this.recordTransaction({
        warehouseId: warehouse.id,
        skuId,
        type: 'out_sale',
        quantity: -quantity,
        totalCost,
        referenceType: 'order',
        referenceId: orderId,
        note: `訂單確認出庫 (訂單: ${orderId})`
      })

      // 檢查庫存警示
      await this.checkAndCreateAlerts(warehouse.id, skuId)
    })

    await transaction()
    console.log(`📦 庫存出庫確認: SKU ${skuId}, 數量 ${quantity}, 訂單 ${orderId}`)
  }

  /**
   * 庫存入庫
   */
  async stockIn(skuId, quantity, unitCost, batchNumber, warehouseId = null, referenceType = 'manual', referenceId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    const transaction = this.db.transaction(async () => {
      // 更新主庫存
      const currentInventory = await this.db.prepare(`
        SELECT current_stock, total_cost FROM inventory 
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(skuId, warehouse.id).first()

      if (currentInventory) {
        // 更新現有庫存
        const newTotalCost = currentInventory.total_cost + (quantity * unitCost)
        const newStock = currentInventory.current_stock + quantity
        const newAvgCost = newStock > 0 ? newTotalCost / newStock : 0

        await this.db.prepare(`
          UPDATE inventory 
          SET current_stock = ?,
              total_cost = ?,
              average_cost = ?,
              last_in_date = CURRENT_TIMESTAMP,
              updated_at = CURRENT_TIMESTAMP
          WHERE sku_id = ? AND warehouse_id = ?
        `).bind(newStock, newTotalCost, newAvgCost, skuId, warehouse.id).run()
      } else {
        // 創建新庫存記錄
        await this.db.prepare(`
          INSERT INTO inventory (warehouse_id, sku_id, current_stock, total_cost, average_cost, last_in_date)
          VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `).bind(warehouse.id, skuId, quantity, quantity * unitCost, unitCost).run()
      }

      // 創建批次記錄
      await this.db.prepare(`
        INSERT OR IGNORE INTO inventory_batches 
        (warehouse_id, sku_id, batch_number, original_quantity, remaining_quantity, unit_cost, received_date)
        VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      `).bind(warehouse.id, skuId, batchNumber, quantity, quantity, unitCost).run()

      // 記錄異動
      await this.recordTransaction({
        warehouseId: warehouse.id,
        skuId,
        type: 'in_purchase',
        quantity,
        unitCost,
        totalCost: quantity * unitCost,
        referenceType,
        referenceId,
        note: `批次入庫: ${batchNumber}`
      })

      // 檢查並解決庫存警示
      await this.resolveStockAlerts(warehouse.id, skuId)
    })

    await transaction()
    console.log(`📥 庫存入庫完成: SKU ${skuId}, 數量 ${quantity}, 批次 ${batchNumber}`)
  }

  /**
   * 記錄庫存異動
   */
  async recordTransaction({ warehouseId, skuId, type, quantity, unitCost = null, totalCost = null, referenceType = null, referenceId = null, note = '', operatorId = 1 }) {
    // 獲取當前庫存作為異動前快照
    const inventory = await this.db.prepare(`
      SELECT current_stock FROM inventory 
      WHERE warehouse_id = ? AND sku_id = ?
    `).bind(warehouseId, skuId).first()

    const stockBefore = inventory ? inventory.current_stock : 0
    const stockAfter = stockBefore + quantity

    await this.db.prepare(`
      INSERT INTO inventory_transactions 
      (warehouse_id, sku_id, transaction_type, quantity, unit_cost, total_cost,
       reference_type, reference_id, stock_before, stock_after, note, operator_id)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      warehouseId, skuId, type, quantity, unitCost, totalCost,
      referenceType, referenceId, stockBefore, stockAfter, note, operatorId
    ).run()
  }

  /**
   * 檢查並創建庫存警示 (基於系統設定)
   */
  async checkAndCreateAlerts(warehouseId, skuId) {
    const inventory = await this.db.prepare(`
      SELECT i.available_stock, i.safe_stock, i.max_stock, 
             ps.sku, p.name as product_name
      FROM inventory i
      LEFT JOIN product_skus ps ON i.sku_id = ps.id
      LEFT JOIN products p ON ps.product_id = p.id
      LEFT JOIN gift_skus gs ON i.sku_id = gs.id  
      LEFT JOIN gifts g ON gs.gift_id = g.id
      WHERE i.warehouse_id = ? AND i.sku_id = ?
    `).bind(warehouseId, skuId).first()

    if (!inventory) return

    const alerts = []

    // 檢查庫存不足
    if (inventory.available_stock <= 0) {
      alerts.push({
        type: 'out_of_stock',
        message: `商品 ${inventory.sku} 庫存已用盡`,
        currentStock: inventory.available_stock,
        threshold: 0
      })
    } else if (inventory.available_stock <= inventory.safe_stock) {
      alerts.push({
        type: 'low_stock',
        message: `商品 ${inventory.sku} 庫存偏低 (當前: ${inventory.available_stock}, 安全庫存: ${inventory.safe_stock})`,
        currentStock: inventory.available_stock,
        threshold: inventory.safe_stock
      })
    }

    // 檢查庫存過多
    if (inventory.available_stock > inventory.max_stock) {
      alerts.push({
        type: 'overstock',
        message: `商品 ${inventory.sku} 庫存過多 (當前: ${inventory.available_stock}, 上限: ${inventory.max_stock})`,
        currentStock: inventory.available_stock,
        threshold: inventory.max_stock
      })
    }

    // 創建警示記錄並發送通知
    for (const alert of alerts) {
      // 檢查是否已存在相同類型的未解決警示
      const existingAlert = await this.db.prepare(`
        SELECT id FROM inventory_alerts 
        WHERE warehouse_id = ? AND sku_id = ? AND alert_type = ? AND is_resolved = FALSE
      `).bind(warehouseId, skuId, alert.type).first()

      if (!existingAlert) {
        await this.db.prepare(`
          INSERT INTO inventory_alerts 
          (warehouse_id, sku_id, alert_type, current_stock, threshold_value, alert_message)
          VALUES (?, ?, ?, ?, ?, ?)
        `).bind(warehouseId, skuId, alert.type, alert.currentStock, alert.threshold, alert.message).run()
        
        // 發送通知 (整合通知管理模組)
        await this.sendInventoryAlert(alert, inventory)
        
        console.log(`🚨 庫存警示: ${alert.message}`)
      }
    }
  }

  /**
   * 發送庫存警示通知 (整合通知管理)
   */
  async sendInventoryAlert(alert, inventory) {
    // 這裡整合通知管理模組，發送郵件/簡訊
    // 實現將在通知管理模組中定義
    console.log(`📧 發送庫存警示通知: ${alert.message}`)
  }

  /**
   * 生成單據號碼
   */
  async generateOrderNumber(prefix) {
    const today = new Date().toISOString().split('T')[0].replace(/-/g, '')
    const sequence = await this.getNextSequence(prefix, today)
    return `${prefix}${today}${sequence.toString().padStart(4, '0')}`
  }

  /**
   * 獲取序號
   */
  async getNextSequence(prefix, date) {
    const result = await this.db.prepare(`
      SELECT COALESCE(MAX(CAST(SUBSTR(order_number, -4) AS INTEGER)), 0) + 1 as next_seq
      FROM (
        SELECT order_number FROM inbound_orders WHERE order_number LIKE ?
        UNION ALL
        SELECT picking_number as order_number FROM picking_orders WHERE picking_number LIKE ?
        UNION ALL  
        SELECT outbound_number as order_number FROM outbound_orders WHERE outbound_number LIKE ?
      )
    `).bind(`${prefix}${date}%`, `${prefix}${date}%`, `${prefix}${date}%`).first()
    
    return result.next_seq
  }

  /**
   * 獲取預設倉庫
   */
  async getDefaultWarehouse() {
    const warehouse = await this.db.prepare(`
      SELECT * FROM warehouses WHERE is_default = TRUE AND is_active = TRUE LIMIT 1
    `).first()

    if (!warehouse) {
      throw new Error('未設定預設倉庫')
    }

    return warehouse
  }

  /**
   * 清理過期的購物車預留庫存 (時效由系統設定決定)
   */
  async cleanupExpiredReservations() {
    // 獲取預留庫存時效設定 (預設30分鐘)
    const maxAgeMinutes = await this.getSystemSetting('cart_reservation_timeout', 30)
    const cutoffTime = new Date(Date.now() - maxAgeMinutes * 60 * 1000)
    
    const expiredReservations = await this.db.prepare(`
      SELECT DISTINCT it.sku_id, it.warehouse_id, SUM(ABS(it.quantity)) as total_quantity
      FROM inventory_transactions it
      WHERE it.transaction_type = 'reserve'
        AND it.created_at < ?
        AND NOT EXISTS (
          SELECT 1 FROM inventory_transactions it2 
          WHERE it2.reference_type = it.reference_type 
            AND it2.reference_id = it.reference_id
            AND it2.transaction_type = 'release'
            AND it2.sku_id = it.sku_id
        )
      GROUP BY it.sku_id, it.warehouse_id
    `).bind(cutoffTime.toISOString()).all()

    for (const reservation of expiredReservations) {
      await this.db.prepare(`
        UPDATE inventory 
        SET reserved_stock = GREATEST(0, reserved_stock - ?),
            updated_at = CURRENT_TIMESTAMP
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(reservation.total_quantity, reservation.sku_id, reservation.warehouse_id).run()

      console.log(`🧹 清理過期預留: SKU ${reservation.sku_id}, 數量 ${reservation.total_quantity}`)
    }

    return expiredReservations.length
  }

  /**
   * 獲取系統設定 (整合系統設定模組)
   */
  async getSystemSetting(key, defaultValue) {
    // 這裡整合系統設定模組
    // 實現將在系統設定模組中定義
    return defaultValue
  }
}

// 創建全域庫存管理實例
export const inventoryManager = new InventoryManager(db)
```

### 成本計算器實現

#### FIFO成本計算器
```javascript
// services/cost-calculators/FIFOCalculator.js
export class FIFOCalculator {
  constructor(db) {
    this.db = db
  }

  async calculateStockOut(warehouseId, skuId, quantity) {
    // 獲取該SKU的批次 (按接收日期排序 - FIFO)
    const batches = await this.db.prepare(`
      SELECT id, remaining_quantity, unit_cost, batch_number, received_date
      FROM inventory_batches
      WHERE warehouse_id = ? AND sku_id = ? AND remaining_quantity > 0
      ORDER BY received_date ASC
    `).bind(warehouseId, skuId).all()

    let remainingQuantity = quantity
    let totalCost = 0

    for (const batch of batches) {
      if (remainingQuantity <= 0) break

      const useQuantity = Math.min(remainingQuantity, batch.remaining_quantity)
      const batchCost = useQuantity * batch.unit_cost

      // 更新批次剩餘數量
      await this.db.prepare(`
        UPDATE inventory_batches 
        SET remaining_quantity = remaining_quantity - ?,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(useQuantity, batch.id).run()

      totalCost += batchCost
      remainingQuantity -= useQuantity

      console.log(`💰 FIFO批次消耗: ${batch.batch_number} (${batch.received_date}), 數量: ${useQuantity}, 成本: $${batchCost}`)
    }

    if (remainingQuantity > 0) {
      console.warn(`⚠️ 警告: 庫存批次不足，剩餘需求 ${remainingQuantity} 未能分配`)
    }

    return totalCost
  }
}
```

#### LIFO成本計算器
```javascript
// services/cost-calculators/LIFOCalculator.js
export class LIFOCalculator {
  constructor(db) {
    this.db = db
  }

  async calculateStockOut(warehouseId, skuId, quantity) {
    // 獲取該SKU的批次 (按接收日期倒序 - LIFO)
    const batches = await this.db.prepare(`
      SELECT id, remaining_quantity, unit_cost, batch_number, received_date
      FROM inventory_batches
      WHERE warehouse_id = ? AND sku_id = ? AND remaining_quantity > 0
      ORDER BY received_date DESC
    `).bind(warehouseId, skuId).all()

    let remainingQuantity = quantity
    let totalCost = 0

    for (const batch of batches) {
      if (remainingQuantity <= 0) break

      const useQuantity = Math.min(remainingQuantity, batch.remaining_quantity)
      const batchCost = useQuantity * batch.unit_cost

      // 更新批次剩餘數量
      await this.db.prepare(`
        UPDATE inventory_batches 
        SET remaining_quantity = remaining_quantity - ?,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(useQuantity, batch.id).run()

      totalCost += batchCost
      remainingQuantity -= useQuantity

      console.log(`💰 LIFO批次消耗: ${batch.batch_number} (${batch.received_date}), 數量: ${useQuantity}, 成本: $${batchCost}`)
    }

    return totalCost
  }
}
```

#### 加權平均成本計算器
```javascript
// services/cost-calculators/WeightedAverageCalculator.js
export class WeightedAverageCalculator {
  constructor(db) {
    this.db = db
  }

  async calculateStockOut(warehouseId, skuId, quantity) {
    // 獲取當前平均成本
    const inventory = await this.db.prepare(`
      SELECT average_cost, current_stock FROM inventory
      WHERE warehouse_id = ? AND sku_id = ?
    `).bind(warehouseId, skuId).first()

    if (!inventory || inventory.current_stock <= 0) {
      console.warn(`⚠️ 庫存不足或平均成本未設定`)
      return 0
    }

    const totalCost = quantity * inventory.average_cost
    
    console.log(`💰 加權平均成本計算: 數量 ${quantity} × 平均成本 $${inventory.average_cost} = $${totalCost}`)
    
    return totalCost
  }
}
```

### 綠界物流整合服務
```javascript
// services/EcpayLogisticsService.js
export class EcpayLogisticsService {
  constructor() {
    this.baseUrl = process.env.ECPAY_LOGISTICS_URL
    this.merchantId = process.env.ECPAY_MERCHANT_ID
    this.hashKey = process.env.ECPAY_HASH_KEY
    this.hashIV = process.env.ECPAY_HASH_IV
  }

  /**
   * 建立綠界物流訂單
   */
  async createShipment({ outboundOrderId, recipientName, recipientPhone, shippingAddress, items }) {
    try {
      const shipmentData = {
        MerchantID: this.merchantId,
        MerchantTradeNo: `OB${outboundOrderId}${Date.now()}`,
        LogisticsType: 'CVS', // 便利商店取貨
        LogisticsSubType: 'FAMI', // 全家便利商店
        GoodsAmount: this.calculateGoodsAmount(items),
        CollectionAmount: 0, // 代收金額
        IsCollection: 'N',
        GoodsName: this.formatGoodsName(items),
        SenderName: '米奇美妝店',
        ReceiverName: recipientName,
        ReceiverCellPhone: recipientPhone,
        ReceiverStoreID: this.parseStoreId(shippingAddress),
        TradeDesc: '商品配送'
      }

      // 生成檢查碼
      shipmentData.CheckMacValue = this.generateCheckMac(shipmentData)

      const response = await fetch(`${this.baseUrl}/logistics/map`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams(shipmentData)
      })

      const result = await response.text()
      const parsedResult = this.parseEcpayResponse(result)

      if (parsedResult.RtnCode === '1') {
        return {
          success: true,
          logistics_id: parsedResult.AllPayLogisticsID,
          tracking_number: parsedResult.CVSPaymentNo,
          cvs_store_id: parsedResult.CVSStoreID
        }
      } else {
        throw new Error(parsedResult.RtnMsg)
      }

    } catch (error) {
      console.error('綠界物流建立訂單失敗:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * 同步物流狀態
   */
  async syncShipmentStatus(ecpayLogisticsId) {
    try {
      const queryData = {
        MerchantID: this.merchantId,
        AllPayLogisticsID: ecpayLogisticsId,
        TimeStamp: Math.floor(Date.now() / 1000)
      }

      queryData.CheckMacValue = this.generateCheckMac(queryData)

      const response = await fetch(`${this.baseUrl}/logistics/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams(queryData)
      })

      const result = await response.text()
      const parsedResult = this.parseEcpayResponse(result)

      return {
        success: parsedResult.RtnCode === '1',
        status: parsedResult.LogisticsStatus,
        statusDescription: this.getStatusDescription(parsedResult.LogisticsStatus),
        updateTime: parsedResult.UpdateStatusDate
      }

    } catch (error) {
      console.error('綠界物流狀態查詢失敗:', error)
      return { success: false, error: error.message }
    }
  }

  /**
   * 綠界物流狀態描述
   */
  getStatusDescription(status) {
    const statusMap = {
      '300': '新建物流訂單/訂單處理中',
      '301': '商品已送達物流中心',
      '302': '商品已送達門市/已送達',
      '303': '顧客已取貨',
      '304': '顧客取貨逾時，退回物流中心',
      '305': '商品已退回物流中心',
      '306': '商品已送回商家',
      '2030': '逆物流訂單成立'
    }
    return statusMap[status] || '未知狀態'
  }

  /**
   * 生成檢查碼
   */
  generateCheckMac(data) {
    // 實現綠界檢查碼生成邏輯
    // 這裡需要根據綠界文件實現
    const sortedData = Object.keys(data).sort().reduce((result, key) => {
      if (key !== 'CheckMacValue') {
        result[key] = data[key]
      }
      return result
    }, {})
    
    // 產生檢查碼的具體實現
    return 'GENERATED_CHECK_MAC'
  }

  /**
   * 解析綠界回應
   */
  parseEcpayResponse(response) {
    // 解析綠界的回應格式
    const params = new URLSearchParams(response)
    return Object.fromEntries(params)
  }

  calculateGoodsAmount(items) {
    return items.reduce((sum, item) => sum + (item.quantity * 100), 0) // 假設單價100
  }

  formatGoodsName(items) {
    return items.map(item => `商品${item.sku_id}`).join('#').substring(0, 60)
  }

  parseStoreId(address) {
    // 從地址解析店舖ID
    return 'STORE001' // 預設店舖
  }
}
```

## API 端點設計

### 階層式庫存查詢
```javascript
// GET /admin/inventory/hierarchical - 階層式庫存查詢
app.get('/admin/inventory/hierarchical', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { 
    warehouse_id, 
    search, 
    expand_all = false,
    item_type, // 'product', 'gift', 'all'
    stock_status, // 'low_stock', 'out_of_stock', 'normal', 'overstock'
    page = 1,
    limit = 50
  } = request.query
  
  let productQuery = `
    SELECT 
      p.id as product_id,
      JSON_EXTRACT(p.name, '$.zh-TW') as product_name,
      p.sku_prefix,
      'product' as item_type,
      COALESCE(SUM(i.current_stock), 0) as total_current_stock,
      COALESCE(SUM(i.reserved_stock), 0) as total_reserved_stock,
      COALESCE(SUM(i.available_stock), 0) as total_available_stock,
      COUNT(ps.id) as variant_count,
      MIN(CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END) as worst_status,
      MAX(i.updated_at) as last_updated
    FROM products p
    LEFT JOIN product_skus ps ON p.id = ps.product_id AND ps.is_active = TRUE
    LEFT JOIN inventory i ON ps.id = i.sku_id AND i.warehouse_id = ?
    WHERE p.status = 'active'
  `

  let giftQuery = `
    SELECT 
      g.id as product_id,
      JSON_EXTRACT(g.name, '$.zh-TW') as product_name,
      g.sku_prefix,
      'gift' as item_type,
      COALESCE(SUM(i.current_stock), 0) as total_current_stock,
      COALESCE(SUM(i.reserved_stock), 0) as total_reserved_stock,
      COALESCE(SUM(i.available_stock), 0) as total_available_stock,
      COUNT(gs.id) as variant_count,
      MIN(CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END) as worst_status,
      MAX(i.updated_at) as last_updated
    FROM gifts g
    LEFT JOIN gift_skus gs ON g.id = gs.gift_id AND gs.is_active = TRUE
    LEFT JOIN inventory i ON gs.id = i.sku_id AND i.warehouse_id = ?
    WHERE g.status = 'active'
  `

  const params = [warehouse_id]
  
  // 搜尋條件
  if (search) {
    const searchCondition = ` AND JSON_EXTRACT(name, '$.zh-TW') LIKE ?`
    productQuery += searchCondition
    giftQuery += searchCondition
    params.push(`%${search}%`)
  }

  let finalQuery = ''
  
  // 項目類型篩選
  if (item_type === 'product') {
    finalQuery = productQuery
  } else if (item_type === 'gift') {
    finalQuery = giftQuery
    params[0] = warehouse_id // 調整參數
  } else {
    finalQuery = `(${productQuery}) UNION ALL (${giftQuery})`
    params.push(warehouse_id) // gift query 需要額外的 warehouse_id
    if (search) {
      params.push(`%${search}%`) // gift query 的搜尋參數
    }
  }

  finalQuery += ` GROUP BY product_id, item_type HAVING variant_count > 0`

  // 庫存狀態篩選
  if (stock_status) {
    finalQuery += ` HAVING worst_status = ?`
    params.push(stock_status)
  }

  finalQuery += ` ORDER BY last_updated DESC`

  // 分頁
  finalQuery += ` LIMIT ? OFFSET ?`
  params.push(limit, (page - 1) * limit)

  const products = await db.prepare(finalQuery).bind(...params).all()

  // 如果需要展開全部或有搜尋條件，載入變體資料
  if (expand_all === 'true' || search) {
    for (const product of products) {
      const variantQuery = product.item_type === 'product' ? `
        SELECT 
          i.*,
          ps.sku,
          ps.variant_path,
          (SELECT GROUP_CONCAT(
            JSON_EXTRACT(pv.option_name, '$.zh-TW'), 
            '-'
           ) 
           FROM product_variants pv 
           WHERE pv.id IN (
             SELECT value FROM json_each(ps.variant_path)
           )
           ORDER BY pv.level
          ) as variant_display_name,
          CASE 
            WHEN i.available_stock <= 0 THEN 'out_of_stock'
            WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
            WHEN i.available_stock > i.max_stock THEN 'overstock'
            ELSE 'normal'
          END as stock_status
        FROM inventory i
        JOIN product_skus ps ON i.sku_id = ps.id
        WHERE ps.product_id = ? AND i.warehouse_id = ?
        ORDER BY ps.sku
      ` : `
        SELECT 
          i.*,
          gs.sku,
          gs.variant_path,
          'gift_variant' as variant_display_name,
          CASE 
            WHEN i.available_stock <= 0 THEN 'out_of_stock'
            WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
            WHEN i.available_stock > i.max_stock THEN 'overstock'
            ELSE 'normal'
          END as stock_status
        FROM inventory i
        JOIN gift_skus gs ON i.sku_id = gs.id
        WHERE gs.gift_id = ? AND i.warehouse_id = ?
        ORDER BY gs.sku
      `
      
      const variants = await db.prepare(variantQuery).bind(product.product_id, warehouse_id).all()
      product.variants = variants
    }
  }

  return {
    products,
    expandAll: expand_all === 'true' || !!search,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit),
      total: products.length
    }
  }
})

// GET /admin/inventory/:product_id/variants - 獲取商品變體庫存
app.get('/admin/inventory/:product_id/variants', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { product_id } = request.params
  const { warehouse_id, item_type = 'product' } = request.query

  const variantQuery = item_type === 'product' ? `
    SELECT 
      i.*,
      ps.sku,
      ps.variant_path,
      (SELECT GROUP_CONCAT(
        JSON_EXTRACT(pv.option_name, '$.zh-TW'), 
        '-'
       ) 
       FROM product_variants pv 
       WHERE pv.id IN (
         SELECT value FROM json_each(ps.variant_path)
       )
       ORDER BY pv.level
      ) as variant_display_name,
      CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END as stock_status
    FROM inventory i
    JOIN product_skus ps ON i.sku_id = ps.id
    WHERE ps.product_id = ? AND i.warehouse_id = ?
    ORDER BY ps.sku
  ` : `
    SELECT 
      i.*,
      gs.sku,
      'gift_variant' as variant_display_name,
      CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END as stock_status
    FROM inventory i
    JOIN gift_skus gs ON i.sku_id = gs.id
    WHERE gs.gift_id = ? AND i.warehouse_id = ?
    ORDER BY gs.sku
  `

  const variants = await db.prepare(variantQuery).bind(product_id, warehouse_id).all()

  return { variants }
})
```

### 入庫管理API
```javascript
// POST /admin/inventory/inbound-orders - 創建入庫單
app.post('/admin/inventory/inbound-orders', authenticateAdmin, requirePermission('inventory', 'create'), async (request) => {
  const data = await request.json()
  const adminId = request.auth.userId
  
  const {
    warehouse_id,
    order_type, // 'purchase', 'return', 'adjustment'
    source_type,
    source_id,
    items, // [{ sku_id, quantity, unit_cost, batch_number }]
    notes
  } = data

  try {
    const result = await inventoryManager.db.transaction(async () => {
      const orderNumber = await inventoryManager.generateOrderNumber('IB')
      
      // 創建入庫單
      const inboundResult = await inventoryManager.db.prepare(`
        INSERT INTO inbound_orders 
        (order_number, warehouse_id, order_type, source_type, source_id, status, created_by, notes)
        VALUES (?, ?, ?, ?, ?, 'pending', ?, ?)
      `).bind(orderNumber, warehouse_id, order_type, source_type, source_id, adminId, notes).run()

      const inboundOrderId = inboundResult.meta.last_row_id

      // 添加入庫單明細
      let totalQuantity = 0
      let totalCost = 0

      for (const item of items) {
        await inventoryManager.db.prepare(`
          INSERT INTO inbound_order_items
          (inbound_order_id, sku_id, batch_number, planned_quantity, unit_cost, quality_check_status)
          VALUES (?, ?, ?, ?, ?, ?)
        `).bind(
          inboundOrderId, item.sku_id, item.batch_number, 
          item.quantity, item.unit_cost,
          order_type === 'return' ? 'pending' : 'not_required'
        ).run()

        totalQuantity += item.quantity
        totalCost += item.quantity * item.unit_cost
      }

      // 更新入庫單總計
      await inventoryManager.db.prepare(`
        UPDATE inbound_orders SET total_quantity = ?, total_cost = ? WHERE id = ?
      `).bind(totalQuantity, totalCost, inboundOrderId).run()

      return { inboundOrderId, orderNumber }
    })

    return {
      success: true,
      message: '入庫單創建成功',
      inbound_order_id: result.inboundOrderId,
      order_number: result.orderNumber
    }

  } catch (error) {
    console.error('創建入庫單失敗:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// PUT /admin/inventory/inbound-orders/:id/approve - 主管審核入庫單
app.put('/admin/inventory/inbound-orders/:id/approve', authenticateAdmin, requirePermission('inventory', 'approve'), async (request) => {
  const { id } = request.params
  const adminId = request.auth.userId

  try {
    await inventoryManager.approveInboundOrder(id, adminId)
    return { success: true, message: '入庫單審核通過並已執行入庫' }
  } catch (error) {
    console.error('審核入庫單失敗:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// PUT /admin/inventory/inbound-orders/:id/items/:item_id/quality-check - 質檢
app.put('/admin/inventory/inbound-orders/:id/items/:item_id/quality-check', authenticateAdmin, requirePermission('inventory', 'quality_check'), async (request) => {
  const { id, item_id } = request.params
  const { status, notes } = await request.json() // 'passed', 'failed'
  const adminId = request.auth.userId

  try {
    await inventoryManager.db.prepare(`
      UPDATE inbound_order_items
      SET quality_check_status = ?,
          quality_check_by = ?,
          quality_check_at = CURRENT_TIMESTAMP,
          quality_notes = ?
      WHERE id = ? AND inbound_order_id = ?
    `).bind(status, adminId, notes, item_id, id).run()

    return { success: true, message: '質檢記錄更新成功' }
  } catch (error) {
    console.error('質檢記錄失敗:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})
```

### 出庫管理API
```javascript
// GET /admin/inventory/picking-orders - 揀貨單列表
app.get('/admin/inventory/picking-orders', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { 
    warehouse_id, 
    status,
    picker_id,
    page = 1, 
    limit = 20 
  } = request.query

  let query = `
    SELECT 
      po.*,
      o.order_number as related_order_number,
      au.name as picker_name,
      w.name as warehouse_name
    FROM picking_orders po
    LEFT JOIN orders o ON po.order_id = o.id
    LEFT JOIN admin_users au ON po.picker_id = au.id
    LEFT JOIN warehouses w ON po.warehouse_id = w.id
    WHERE 1=1
  `

  const params = []

  if (warehouse_id) {
    query += ` AND po.warehouse_id = ?`
    params.push(warehouse_id)
  }

  if (status) {
    query += ` AND po.status = ?`
    params.push(status)
  }

  if (picker_id) {
    query += ` AND po.picker_id = ?`
    params.push(picker_id)
  }

  query += ` ORDER BY po.created_at DESC LIMIT ? OFFSET ?`
  params.push(limit, (page - 1) * limit)

  const pickingOrders = await db.prepare(query).bind(...params).all()

  return {
    picking_orders: pickingOrders,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit)
    }
  }
})

// POST /admin/inventory/picking-orders/:id/scan - 掃碼揀貨
app.post('/admin/inventory/picking-orders/:id/scan', authenticateAdmin, requirePermission('inventory', 'picking'), async (request) => {
  const { id } = request.params
  const { sku_id, quantity, batch_numbers } = await request.json()
  const adminId = request.auth.userId

  try {
    const result = await inventoryManager.scanPickingItem(
      id, sku_id, quantity, adminId, batch_numbers
    )

    return {
      success: true,
      message: '掃碼揀貨記錄成功',
      completed: result.completed,
      progress: result.progress
    }
  } catch (error) {
    console.error('掃碼揀貨失敗:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// POST /admin/inventory/picking-orders/:id/confirm - 員工簽核揀貨單
app.post('/admin/inventory/picking-orders/:id/confirm', authenticateAdmin, requirePermission('inventory', 'picking'), async (request) => {
  const { id } = request.params
  const adminId = request.auth.userId

  try {
    const result = await inventoryManager.confirmPickingAndCreateOutbound(id, adminId)

    return {
      success: true,
      message: '揀貨單簽核成功，已建立出貨單並送至綠界物流',
      outbound_order_id: result.outboundOrderId,
      outbound_number: result.outboundNumber,
      tracking_number: result.trackingNumber,
      ecpay_success: result.ecpayResult.success
    }
  } catch (error) {
    console.error('揀貨單簽核失敗:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})
```

### 綠界物流同步API
```javascript
// POST /admin/inventory/outbound-orders/:id/sync-logistics - 同步綠界物流狀態
app.post('/admin/inventory/outbound-orders/:id/sync-logistics', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { id } = request.params

  try {
    const outboundOrder = await db.prepare(`
      SELECT * FROM outbound_orders WHERE id = ?
    `).bind(id).first()

    if (!outboundOrder || !outboundOrder.ecpay_logistics_id) {
      return new Response(JSON.stringify({ 
        error: '出貨單不存在或未建立綠界物流訂單' 
      }), { status: 400 })
    }

    const ecpayService = new EcpayLogisticsService()
    const syncResult = await ecpayService.syncShipmentStatus(outboundOrder.ecpay_logistics_id)

    if (syncResult.success) {
      // 更新出貨單狀態
      let newStatus = outboundOrder.status
      if (syncResult.status === '303') { // 顧客已取貨
        newStatus = 'delivered'
      } else if (syncResult.status === '302') { // 已送達門市
        newStatus = 'shipped'
      }

      await db.prepare(`
        UPDATE outbound_orders
        SET ecpay_status = ?,
            status = ?,
            last_sync_at = CURRENT_TIMESTAMP
            ${newStatus === 'delivered' ? ', delivered_at = CURRENT_TIMESTAMP' : ''}
        WHERE id = ?
      `).bind(syncResult.status, newStatus, id).run()

      // 同步更新訂單狀態
      if (newStatus === 'delivered') {
        await db.prepare(`
          UPDATE orders SET status = 'completed', completed_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(outboundOrder.order_id).run()
      }

      return {
        success: true,
        message: '物流狀態同步成功',
        status: syncResult.status,
        description: syncResult.statusDescription,
        order_status: newStatus
      }
    } else {
      return new Response(JSON.stringify({ 
        error: syncResult.error 
      }), { status: 500 })
    }

  } catch (error) {
    console.error('同步綠界物流狀態失敗:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// 定時任務：批量同步所有未完成的物流訂單
export const syncAllPendingLogistics = async () => {
  console.log('🚚 開始批量同步物流狀態...')

  const pendingOrders = await db.prepare(`
    SELECT * FROM outbound_orders 
    WHERE ecpay_logistics_id IS NOT NULL 
      AND status IN ('shipped') 
      AND (last_sync_at IS NULL OR last_sync_at < datetime('now', '-1 hour'))
    ORDER BY shipped_at DESC
    LIMIT 50
  `).all()

  const ecpayService = new EcpayLogisticsService()
  let synced = 0
  let errors = 0

  for (const order of pendingOrders) {
    try {
      const syncResult = await ecpayService.syncShipmentStatus(order.ecpay_logistics_id)
      
      if (syncResult.success) {
        let newStatus = order.status
        if (syncResult.status === '303') { // 顧客已取貨
          newStatus = 'delivered'
        }

        await db.prepare(`
          UPDATE outbound_orders
          SET ecpay_status = ?,
              status = ?,
              last_sync_at = CURRENT_TIMESTAMP
              ${newStatus === 'delivered' ? ', delivered_at = CURRENT_TIMESTAMP' : ''}
          WHERE id = ?
        `).bind(syncResult.status, newStatus, order.id).run()

        // 同步更新訂單狀態
        if (newStatus === 'delivered') {
          await db.prepare(`
            UPDATE orders SET status = 'completed', completed_at = CURRENT_TIMESTAMP
            WHERE id = ?
          `).bind(order.order_id).run()
        }

        synced++
      } else {
        errors++
      }

      // 防止過於頻繁的API請求
      await new Promise(resolve => setTimeout(resolve, 200))

    } catch (error) {
      console.error(`同步物流訂單 ${order.id} 失敗:`, error)
      errors++
    }
  }

  console.log(`✅ 物流狀態批量同步完成: ${synced} 成功, ${errors} 失敗`)
}
```

## 階層式前端組件

### 階層式庫存表格
```jsx
// admin/src/components/HierarchicalInventoryTable.jsx
import React, { useState, useEffect } from 'react'
import { 
  Table, Button, Space, Tag, Input, Select, Switch, 
  InputNumber, Modal, Form, message, Tooltip 
} from 'antd'
import { 
  DownOutlined, RightOutlined, PlusOutlined, 
  MinusOutlined, SettingOutlined, EyeOutlined,
  ScanOutlined, ExportOutlined
} from '@ant-design/icons'

const { Search } = Input
const { Option } = Select

const HierarchicalInventoryTable = () => {
  const [expandedRows, setExpandedRows] = useState(new Set())
  const [inventoryData, setInventoryData] = useState([])
  const [loading, setLoading] = useState(false)
  const [filters, setFilters] = useState({
    warehouse_id: null,
    item_type: 'all',
    stock_status: null,
    search: ''
  })
  const [warehouses, setWarehouses] = useState([])
  const [selectedWarehouse, setSelectedWarehouse] = useState(null)

  useEffect(() => {
    loadWarehouses()
  }, [])

  useEffect(() => {
    if (selectedWarehouse) {
      loadInventoryData()
    }
  }, [selectedWarehouse, filters])

  const loadWarehouses = async () => {
    try {
      const response = await fetch('/admin/warehouses')
      const result = await response.json()
      setWarehouses(result.warehouses)
      
      // 設定預設倉庫
      const defaultWarehouse = result.warehouses.find(w => w.is_default)
      if (defaultWarehouse) {
        setSelectedWarehouse(defaultWarehouse.id)
        setFilters(prev => ({ ...prev, warehouse_id: defaultWarehouse.id }))
      }
    } catch (error) {
      message.error('載入倉庫列表失敗')
    }
  }

  const loadInventoryData = async () => {
    if (!selectedWarehouse) return

    setLoading(true)
    try {
      const queryParams = new URLSearchParams({
        warehouse_id: selectedWarehouse,
        expand_all: filters.search ? 'true' : 'false',
        ...filters
      })

      const response = await fetch(`/admin/inventory/hierarchical?${queryParams}`)
      const result = await response.json()
      
      setInventoryData(result.products)
      
      // 如果有搜尋，自動展開所有項目
      if (result.expandAll) {
        const allProductIds = result.products.map(p => p.product_id)
        setExpandedRows(new Set(allProductIds))
      }

    } catch (error) {
      message.error('載入庫存資料失敗')
    } finally {
      setLoading(false)
    }
  }

  const toggleRow = async (productId, itemType) => {
    const newExpanded = new Set(expandedRows)
    
    if (newExpanded.has(productId)) {
      newExpanded.delete(productId)
    } else {
      newExpanded.add(productId)
      
      // 如果該商品還沒載入變體，則載入
      const product = inventoryData.find(p => p.product_id === productId)
      if (!product.variants) {
        try {
          const response = await fetch(
            `/admin/inventory/${productId}/variants?warehouse_id=${selectedWarehouse}&item_type=${itemType}`
          )
          const result = await response.json()
          
          // 更新該商品的變體資料
          setInventoryData(prev => prev.map(p => 
            p.product_id === productId 
              ? { ...p, variants: result.variants }
              : p
          ))
        } catch (error) {
          message.error('載入變體資料失敗')
        }
      }
    }
    
    setExpandedRows(newExpanded)
  }

  const getStockStatusColor = (status) => {
    const statusConfig = {
      'out_of_stock': 'red',
      'low_stock': 'orange', 
      'normal': 'green',
      'overstock': 'purple'
    }
    return statusConfig[status] || 'default'
  }

  const getStockStatusText = (status, variantCount = 0) => {
    const statusText = {
      'out_of_stock': '缺貨',
      'low_stock': '低庫存',
      'normal': '正常',
      'overstock': '庫存過多'
    }
    
    const text = statusText[status] || '未知'
    return variantCount > 0 ? `${text} (${variantCount}種變體)` : text
  }

  const handleQuickStock = async (skuId, action, quantity = 1) => {
    try {
      const endpoint = action === 'in' ? '/admin/inventory/stock-in' : '/admin/inventory/stock-out'
      
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sku_id: skuId,
          warehouse_id: selectedWarehouse,
          quantity,
          unit_cost: action === 'in' ? 100 : undefined, // 預設成本
          batch_number: action === 'in' ? `BATCH${Date.now()}` : undefined,
          reason: action === 'out' ? 'manual' : undefined
        })
      })

      const result = await response.json()
      
      if (result.success) {
        message.success(`${action === 'in' ? '入庫' : '出庫'}成功`)
        loadInventoryData() // 重新載入資料
      } else {
        message.error(result.error)
      }
    } catch (error) {
      message.error(`${action === 'in' ? '入庫' : '出庫'}失敗`)
    }
  }

  const columns = [
    {
      title: '商品/贈品',
      dataIndex: 'product_name',
      width: 300,
      render: (name, record) => (
        <div style={{ 
          paddingLeft: record.isVariant ? 24 : 0,
          display: 'flex',
          alignItems: 'center'
        }}>
          {!record.isVariant && (
            <Button 
              type="text" 
              size="small"
              icon={expandedRows.has(record.product_id) ? 
                <DownOutlined /> : <RightOutlined />
              }
              onClick={() => toggleRow(record.product_id, record.item_type)}
              style={{ marginRight: 8 }}
            />
          )}
          
          <span style={{ marginRight: 8 }}>
            {record.item_type === 'gift' || record.isGift ? '🎁' : '📦'}
          </span>
          
          <span style={{ 
            fontWeight: record.isVariant ? 'normal' : 'bold',
            fontSize: record.isVariant ? '14px' : '16px'
          }}>
            {name}
          </span>
          
          {record.isVariant && (
            <Tag color="blue" style={{ marginLeft: 8 }}>
              {record.sku}
            </Tag>
          )}
          
          {!record.isVariant && record.sku_prefix && (
            <Tag color="geekblue" style={{ marginLeft: 8 }}>
              {record.sku_prefix}*
            </Tag>
          )}
        </div>
      )
    },
    {
      title: '當前庫存',
      dataIndex: 'current_stock',
      width: 100,
      render: (stock, record) => (
        <span style={{ 
          fontWeight: record.isVariant ? 'normal' : 'bold',
          fontSize: record.isVariant ? '14px' : '16px',
          color: record.isVariant && stock <= 0 ? '#f50' : 'inherit'
        }}>
          {stock || 0}
        </span>
      )
    },
    {
      title: '預留庫存', 
      dataIndex: 'reserved_stock',
      width: 100,
      render: (stock, record) => (
        <span style={{ 
          color: stock > 0 ? '#f50' : '#999',
          fontSize: record.isVariant ? '14px' : '16px'
        }}>
          {stock > 0 ? `-${stock}` : '0'}
        </span>
      )
    },
    {
      title: '可用庫存',
      dataIndex: 'available_stock',
      width: 100,
      render: (stock, record) => {
        let color = '#52c41a' // 正常綠色
        if (stock <= 0) color = '#f50' // 缺貨紅色
        else if (stock <= record.safe_stock) color = '#fa8c16' // 低庫存橙色
        
        return (
          <span style={{ 
            fontWeight: record.isVariant ? 'normal' : 'bold',
            fontSize: record.isVariant ? '14px' : '16px',
            color
          }}>
            {stock || 0}
          </span>
        )
      }
    },
    {
      title: '庫存狀態',
      dataIndex: 'stock_status',
      width: 150,
      render: (status, record) => (
        <Tag color={getStockStatusColor(status)}>
          {getStockStatusText(
            status, 
            record.isVariant ? 0 : record.variant_count
          )}
        </Tag>
      )
    },
    {
      title: '成本/均價',
      width: 100,
      render: (_, record) => {
        if (!record.isVariant) return '-'
        
        return (
          <div>
            <div style={{ fontSize: '12px', color: '#999' }}>
              均價: ${record.average_cost?.toFixed(2) || '0.00'}
            </div>
          </div>
        )
      }
    },
    {
      title: '操作',
      width: 200,
      render: (_, record) => (
        <Space size="small">
          {record.isVariant ? (
            <>
              <Tooltip title="快速入庫">
                <Button 
                  size="small" 
                  icon={<PlusOutlined />}
                  onClick={() => handleQuickStock(record.sku_id, 'in')}
                />
              </Tooltip>
              
              <Tooltip title="快速出庫">
                <Button 
                  size="small" 
                  icon={<MinusOutlined />}
                  onClick={() => handleQuickStock(record.sku_id, 'out')}
                  disabled={record.available_stock <= 0}
                />
              </Tooltip>
              
              <Tooltip title="掃碼操作">
                <Button 
                  size="small" 
                  icon={<ScanOutlined />}
                  onClick={() => openScanModal(record)}
                />
              </Tooltip>
              
              <Tooltip title="庫存設定">
                <Button 
                  size="small" 
                  icon={<SettingOutlined />}
                  onClick={() => openSettingsModal(record)}
                />
              </Tooltip>
            </>
          ) : (
            <>
              <Button 
                size="small" 
                icon={<EyeOutlined />}
                onClick={() => viewProductDetails(record)}
              >
                查看詳情
              </Button>
              
              <Button 
                size="small" 
                icon={<ExportOutlined />}
                onClick={() => exportProductInventory(record)}
              >
                匯出
              </Button>
            </>
          )}
        </Space>
      )
    }
  ]

  // 處理展開的資料結構
  const getTableData = () => {
    const result = []
    
    inventoryData.forEach(product => {
      // 添加商品/贈品主項目
      result.push({
        key: `product-${product.product_id}`,
        ...product,
        current_stock: product.total_current_stock,
        reserved_stock: product.total_reserved_stock,
        available_stock: product.total_available_stock,
        stock_status: product.worst_status,
        isVariant: false
      })
      
      // 如果該商品已展開，添加變體子項目
      if (expandedRows.has(product.product_id) && product.variants) {
        product.variants.forEach(variant => {
          result.push({
            key: `variant-${variant.sku_id}`,
            ...variant,
            product_id: product.product_id,
            product_name: variant.variant_display_name || variant.sku,
            isVariant: true,
            isGift: product.item_type === 'gift'
          })
        })
      }
    })
    
    return result
  }

  const openScanModal = (record) => {
    // 實現掃碼模態框
    console.log('開啟掃碼操作:', record)
  }

  const openSettingsModal = (record) => {
    // 實現庫存設定模態框
    console.log('開啟庫存設定:', record)
  }

  const viewProductDetails = (record) => {
    // 跳轉到商品詳情頁
    window.open(`/admin/inventory/products/${record.product_id}/details`)
  }

  const exportProductInventory = (record) => {
    // 實現庫存匯出功能
    console.log('匯出商品庫存:', record)
  }

  return (
    <div className="hierarchical-inventory-table">
      {/* 篩選器 */}
      <div className="inventory-filters" style={{ 
        marginBottom: 16, 
        padding: 16, 
        background: '#fafafa', 
        borderRadius: 6 
      }}>
        <Space wrap>
          <Select
            placeholder="選擇倉庫"
            style={{ width: 180 }}
            value={selectedWarehouse}
            onChange={(value) => {
              setSelectedWarehouse(value)
              setFilters(prev => ({ ...prev, warehouse_id: value }))
            }}
          >
            {warehouses.map(warehouse => (
              <Option key={warehouse.id} value={warehouse.id}>
                {warehouse.name} {warehouse.is_default && <Tag size="small">預設</Tag>}
              </Option>
            ))}
          </Select>

          <Select
            placeholder="項目類型"
            style={{ width: 120 }}
            value={filters.item_type}
            onChange={(value) => setFilters(prev => ({ ...prev, item_type: value }))}
          >
            <Option value="all">全部</Option>
            <Option value="product">📦 商品</Option>
            <Option value="gift">🎁 贈品</Option>
          </Select>

          <Select
            placeholder="庫存狀態"
            style={{ width: 120 }}
            value={filters.stock_status}
            onChange={(value) => setFilters(prev => ({ ...prev, stock_status: value }))}
            allowClear
          >
            <Option value="out_of_stock">缺貨</Option>
            <Option value="low_stock">低庫存</Option>
            <Option value="normal">正常</Option>
            <Option value="overstock">庫存過多</Option>
          </Select>

          <Search
            placeholder="搜尋商品名稱或SKU"
            style={{ width: 250 }}
            value={filters.search}
            onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
            onSearch={() => loadInventoryData()}
            enterButton
          />

          <Button 
            onClick={loadInventoryData}
            loading={loading}
          >
            重新載入
          </Button>

          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => window.open('/admin/inventory/inbound-orders/create')}
          >
            建立入庫單
          </Button>
        </Space>
      </div>

      {/* 庫存表格 */}
      <Table
        columns={columns}
        dataSource={getTableData()}
        loading={loading}
        pagination={{
          showSizeChanger: true,
          showQuickJumper: true,
          showTotal: (total, range) => 
            `顯示 ${range[0]}-${range[1]} 項，共 ${total} 項`,
          pageSize: 50,
          pageSizeOptions: ['20', '50', '100', '200']
        }}
        size="middle"
        scroll={{ x: 1200 }}
        expandable={false} // 使用自定義展開邏輯
      />
    </div>
  )
}

export default HierarchicalInventoryTable
```

## 與18個模組的整合設計

### 1. 採購管理整合
- **自動轉入庫單**: 採購驗收後自動建立入庫單
- **批次管理**: 採購批次自動轉為庫存批次
- **成本同步**: 採購成本自動更新為庫存成本

### 2. 訂單管理整合  
- **自動建立揀貨單**: 訂單確認後自動建立揀貨單
- **庫存預留**: 下單時自動預留庫存
- **預售支援**: 支援庫存不足時的預售功能

### 3. 物流管理整合
- **綠界物流API**: 出貨單自動傳送綠界
- **狀態同步**: 持續同步物流狀態更新訂單
- **追蹤號碼**: 自動獲取並記錄追蹤號碼

### 4. 系統設定整合
- **參數設定**: 預留時效、警示邏輯、盤點設定
- **成本方法設定**: FIFO/LIFO/加權平均選擇  
- **呆滯庫存標準**: 可設定的呆滯庫存判定條件

### 5. 會計處理整合
- **成本結轉**: 銷售成本自動計算與結轉
- **庫存評價**: 期末庫存價值自動計算
- **週轉率設定**: 會計期間設定影響週轉率計算

### 6. 數據分析整合
- **庫存報表**: 5大類庫存報表在數據分析中展示
  - 庫存明細表
  - 庫存異動表  
  - 庫存週轉分析表
  - 呆滯庫存報表
  - 庫存成本分析表

### 7. 通知管理整合
- **庫存警示通知**: 低庫存/缺貨郵件簡訊通知
- **審核通知**: 入庫單、盤點審核通知
- **物流通知**: 出貨、到貨狀態通知

### 8. 管理員管理整合
- **權限控制**: 細分的庫存操作權限
- **審核流程**: 不同角色的審核權限設定
- **操作記錄**: 完整的操作人員記錄

### 9. 商品管理整合
- **SKU同步**: 新商品自動創建庫存記錄
- **變體支援**: 完整支援商品變體庫存管理
- **狀態同步**: 零庫存商品可設定自動下架

### 10. 贈品管理整合
- **贈品庫存**: 贈品與商品統一庫存管理
- **促銷扣減**: 贈品發放自動扣減庫存
- **階層展示**: 贈品在庫存列表中獨立展示

## 定時任務設計

### 庫存相關定時任務
```javascript
// schedules/inventory-tasks.js
import { inventoryManager } from '../services/InventoryManager'
import { syncAllPendingLogistics } from '../api/inventory-api'

// 每30分鐘清理過期的購物車預留庫存
export const cleanupExpiredReservations = {
  schedule: '0 */30 * * * *', // 每30分鐘
  task: async () => {
    try {
      const cleaned = await inventoryManager.cleanupExpiredReservations()
      console.log(`✅ 清理過期預留庫存: ${cleaned} 筆記錄`)
    } catch (error) {
      console.error('❌ 清理過期預留庫存失敗:', error)
    }
  }
}

// 每小時同步綠界物流狀態
export const syncLogisticsStatus = {
  schedule: '0 0 * * * *', // 每小時
  task: async () => {
    try {
      await syncAllPendingLogistics()
    } catch (error) {
      console.error('❌ 批量同步物流狀態失敗:', error)
    }
  }
}

// 每日檢查低庫存並發送警示
export const dailyLowStockCheck = {
  schedule: '0 0 9 * * *', // 每天上午9點
  task: async () => {
    try {
      const warehouses = await inventoryManager.db.prepare(`
        SELECT id FROM warehouses WHERE is_active = TRUE
      `).all()

      for (const warehouse of warehouses) {
        const lowStockItems = await inventoryManager.db.prepare(`
          SELECT i.*, ps.sku FROM inventory i
          JOIN product_skus ps ON i.sku_id = ps.id
          WHERE i.warehouse_id = ? AND i.available_stock <= i.safe_stock
        `).bind(warehouse.id).all()

        for (const item of lowStockItems) {
          await inventoryManager.checkAndCreateAlerts(warehouse.id, item.sku_id)
        }
      }

      console.log('✅ 每日低庫存檢查完成')
    } catch (error) {
      console.error('❌ 每日低庫存檢查失敗:', error)
    }
  }
}

// 每週生成庫存週轉報告
export const weeklyTurnoverReport = {
  schedule: '0 0 6 * * 1', // 每週一上午6點
  task: async () => {
    try {
      // 生成庫存週轉率報告
      // 實現將與數據分析模組整合
      console.log('✅ 每週庫存週轉報告生成完成')
    } catch (error) {
      console.error('❌ 每週庫存週轉報告生成失敗:', error)
    }
  }
}
```

## 系統配置

### 環境變數設定
```bash
# .env - 庫存管理相關環境變數

# 綠界物流API設定
ECPAY_LOGISTICS_URL=https://logistics-stage.ecpay.com.tw
ECPAY_MERCHANT_ID=your_merchant_id
ECPAY_HASH_KEY=your_hash_key
ECPAY_HASH_IV=your_hash_iv

# 庫存管理設定
INVENTORY_RESERVATION_TIMEOUT=30  # 購物車預留時效（分鐘）
INVENTORY_LOW_STOCK_THRESHOLD=10  # 預設低庫存閾值
INVENTORY_BATCH_SYNC_LIMIT=50     # 批量同步限制

# 通知設定
INVENTORY_ALERT_EMAIL=admin@example.com
INVENTORY_ALERT_SMS=+886912345678
```

### 權限設定
```javascript
// 庫存管理權限定義
const inventoryPermissions = {
  'inventory.read': '查看庫存資訊',
  'inventory.create': '建立入庫單、調整庫存',
  'inventory.update': '修改庫存設定',
  'inventory.delete': '刪除庫存記錄',
  'inventory.approve': '審核入庫單',
  'inventory.picking': '執行揀貨操作',
  'inventory.quality_check': '執行質檢操作',
  'inventory.count': '執行庫存盤點',
  'inventory.export': '匯出庫存資料'
}
```

## 總結

這個庫存管理系統提供了：

1. **完整的單據流程** - 入庫單、揀貨單、出貨單、質檢單
2. **多倉庫支援** - 動態新增倉庫，多倉庫統一管理
3. **階層式展示** - 商品/贈品收合列表，變體庫存自動加總
4. **多種成本方法** - FIFO、LIFO、加權平均成本計算
5. **綠界物流整合** - 自動建立物流訂單，持續狀態同步
6. **預售支援** - 支援負庫存銷售，預購功能完整
7. **智能警示** - 可設定的庫存警示邏輯
8. **18模組整合** - 與所有後台模組深度整合
9. **條碼掃描** - 完整的QR Code/條碼掃描支援
10. **權限控制** - 細分的操作權限和審核機制

所有功能都已詳細設計，可直接根據此文檔開發完整的庫存管理系統。