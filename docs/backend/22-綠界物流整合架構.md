# 綠界物流整合架構 (ECPay Logistics Integration Architecture)

## 1. 概述

綠界物流整合架構負責與綠界科技物流服務的完整整合，提供超商取貨、宅配到府、郵局寄送等多種物流方式，並處理物流狀態追蹤、費用計算、地址驗證等功能。

### 1.1 支援的物流服務
- 超商取貨付款（7-ELEVEN、全家、萊爾富、OK mart）
- 超商取貨不付款
- 黑貓宅急便
- 新竹貨運
- 郵局配送
- 自取服務

### 1.2 核心功能
- 物流方式選擇與費用計算
- 電子地圖選擇超商門市
- 物流訂單建立與管理
- 物流狀態即時追蹤
- 退貨逆物流處理
- 異常狀況處理

## 2. 系統架構設計

### 2.1 架構層級
```
┌─────────────────────────────────────┐
│          前台使用者介面              │
│   (物流方式選擇、超商選擇、追蹤)     │
└─────────────────────────────────────┘
                    │
┌─────────────────────────────────────┐
│        物流整合服務層                │
│  (物流 API、狀態管理、費用計算)      │
└─────────────────────────────────────┘
                    │
┌─────────────────────────────────────┐
│        綠界物流 API 介接層           │
│   (API 封裝、加密驗證、重試機制)     │
└─────────────────────────────────────┘
                    │
┌─────────────────────────────────────┐
│         綠界科技物流服務              │
│    (超商、宅配、郵局等物流商)        │
└─────────────────────────────────────┘
```

### 2.2 核心元件
```typescript
// 物流整合核心元件
interface LogisticsComponents {
  // API 介接
  ecpayLogisticsAPI: ECPayLogisticsAPI;
  
  // 物流管理
  logisticsManager: LogisticsManager;
  shippingCalculator: ShippingCalculator;
  storeSelector: ConvenienceStoreSelector;
  
  // 狀態追蹤
  trackingService: LogisticsTrackingService;
  statusSynchronizer: LogisticsStatusSynchronizer;
  
  // 異常處理
  exceptionHandler: LogisticsExceptionHandler;
  retryService: LogisticsRetryService;
  
  // 逆物流
  returnLogistics: ReturnLogisticsService;
}
```

## 3. 綠界物流 API 整合

### 3.1 API 設定
```typescript
interface ECPayLogisticsConfig {
  // 基本設定
  merchantId: string;
  hashKey: string;
  hashIV: string;
  serverReplyURL: string;
  clientReplyURL: string;
  logisticsReplyURL: string;
  
  // 環境設定
  isTestMode: boolean;
  testURL: string;
  productionURL: string;
  
  // 超時設定
  apiTimeout: number;
  maxRetryAttempts: number;
  retryDelay: number;
}

class ECPayLogisticsAPI {
  private config: ECPayLogisticsConfig;
  private httpClient: HttpClient;
  
  constructor(config: ECPayLogisticsConfig) {
    this.config = config;
    this.httpClient = new HttpClient({
      timeout: config.apiTimeout,
      maxRetries: config.maxRetryAttempts
    });
  }

  // 產生檢查碼
  private generateCheckMacValue(params: Record<string, any>): string {
    // 1. 移除 CheckMacValue 參數
    const filteredParams = { ...params };
    delete filteredParams.CheckMacValue;
    
    // 2. 依照 Key 值排序
    const sortedKeys = Object.keys(filteredParams).sort();
    
    // 3. 組合字串
    let checkString = `HashKey=${this.config.hashKey}`;
    sortedKeys.forEach(key => {
      if (filteredParams[key] !== null && filteredParams[key] !== undefined) {
        checkString += `&${key}=${filteredParams[key]}`;
      }
    });
    checkString += `&HashIV=${this.config.hashIV}`;
    
    // 4. URL Encode
    checkString = encodeURIComponent(checkString).toLowerCase();
    
    // 5. 產生 MD5 雜湊值
    return crypto.createHash('md5').update(checkString).digest('hex').toUpperCase();
  }

  // 建立物流訂單
  async createLogisticsOrder(orderData: LogisticsOrderData): Promise<LogisticsOrderResponse> {
    const params = {
      MerchantID: this.config.merchantId,
      MerchantTradeNo: orderData.merchantTradeNo,
      MerchantTradeDate: orderData.merchantTradeDate,
      LogisticsType: orderData.logisticsType,
      LogisticsSubType: orderData.logisticsSubType,
      GoodsAmount: orderData.goodsAmount,
      CollectionAmount: orderData.collectionAmount,
      IsCollection: orderData.isCollection,
      GoodsName: orderData.goodsName,
      SenderName: orderData.senderName,
      SenderPhone: orderData.senderPhone,
      SenderCellPhone: orderData.senderCellPhone,
      ReceiverName: orderData.receiverName,
      ReceiverPhone: orderData.receiverPhone,
      ReceiverCellPhone: orderData.receiverCellPhone,
      ReceiverEmail: orderData.receiverEmail,
      TradeDesc: orderData.tradeDesc,
      ServerReplyURL: this.config.serverReplyURL,
      LogisticsC2CReplyURL: this.config.logisticsReplyURL,
      Remark: orderData.remark,
      PlatformID: orderData.platformID
    };

    // 加入地址資訊（依據物流類型）
    if (orderData.logisticsType === 'CVS') {
      // 超商取貨
      params.ReceiverStoreID = orderData.receiverStoreID;
      params.ReturnStoreID = orderData.returnStoreID;
    } else if (orderData.logisticsType === 'HOME') {
      // 宅配
      params.ReceiverAddress = orderData.receiverAddress;
      params.SenderZipCode = orderData.senderZipCode;
      params.SenderAddress = orderData.senderAddress;
      params.Temperature = orderData.temperature;
      params.Distance = orderData.distance;
      params.Specification = orderData.specification;
      params.ScheduledPickupTime = orderData.scheduledPickupTime;
      params.ScheduledDeliveryTime = orderData.scheduledDeliveryTime;
    }

    // 產生檢查碼
    params.CheckMacValue = this.generateCheckMacValue(params);

    try {
      const response = await this.httpClient.post(
        `${this.getBaseURL()}/Express/Create`,
        params
      );

      return this.parseLogisticsResponse(response);
    } catch (error) {
      throw new LogisticsAPIError(`建立物流訂單失敗: ${error.message}`, error);
    }
  }

  // 查詢物流狀態
  async queryLogisticsInfo(merchantTradeNo: string): Promise<LogisticsStatusResponse> {
    const params = {
      MerchantID: this.config.merchantId,
      MerchantTradeNo: merchantTradeNo,
      TimeStamp: Math.floor(Date.now() / 1000)
    };

    params.CheckMacValue = this.generateCheckMacValue(params);

    try {
      const response = await this.httpClient.post(
        `${this.getBaseURL()}/Helper/QueryLogisticsTradeInfo/V3`,
        params
      );

      return this.parseLogisticsStatusResponse(response);
    } catch (error) {
      throw new LogisticsAPIError(`查詢物流狀態失敗: ${error.message}`, error);
    }
  }

  // 產生超商地圖
  async generateCVSMap(logisticsSubType: CVSType, isCollection: boolean = false): Promise<string> {
    const params = {
      MerchantID: this.config.merchantId,
      MerchantTradeNo: this.generateTempTradeNo(),
      LogisticsType: 'CVS',
      LogisticsSubType: logisticsSubType,
      IsCollection: isCollection ? 'Y' : 'N',
      ServerReplyURL: this.config.serverReplyURL,
      ExtraData: JSON.stringify({ tempOrder: true }),
      Device: 0 // 0:PC, 1:Mobile
    };

    params.CheckMacValue = this.generateCheckMacValue(params);

    // 產生 HTML 表單用於開啟地圖
    const formHTML = this.generateMapFormHTML(params);
    return formHTML;
  }

  // 列印託運單
  async printTradeDocument(
    merchantTradeNo: string, 
    logisticsSubType: string
  ): Promise<PrintDocumentResponse> {
    const params = {
      MerchantID: this.config.merchantId,
      MerchantTradeNo: merchantTradeNo,
      LogisticsSubType: logisticsSubType
    };

    params.CheckMacValue = this.generateCheckMacValue(params);

    try {
      const response = await this.httpClient.post(
        `${this.getBaseURL()}/helper/printTradeDocument`,
        params
      );

      return this.parsePrintDocumentResponse(response);
    } catch (error) {
      throw new LogisticsAPIError(`列印託運單失敗: ${error.message}`, error);
    }
  }

  private getBaseURL(): string {
    return this.config.isTestMode ? this.config.testURL : this.config.productionURL;
  }

  private generateTempTradeNo(): string {
    return `TEMP${Date.now()}`;
  }

  private generateMapFormHTML(params: Record<string, any>): string {
    let formHTML = `
      <form id="ecpayForm" action="${this.getBaseURL()}/Express/map" method="post">
    `;
    
    Object.keys(params).forEach(key => {
      formHTML += `<input type="hidden" name="${key}" value="${params[key]}" />`;
    });
    
    formHTML += `
      </form>
      <script>
        document.getElementById('ecpayForm').submit();
      </script>
    `;
    
    return formHTML;
  }
}
```

### 3.2 物流類型定義
```typescript
enum LogisticsType {
  CVS = 'CVS',        // 超商取貨
  HOME = 'HOME',      // 宅配
  POST = 'POST'       // 郵局
}

enum CVSType {
  SEVEN = 'SEVEN',    // 7-ELEVEN
  FAMILY = 'FAMILY',  // 全家
  HILIFE = 'HILIFE',  // 萊爾富
  OKMART = 'OKMART'   // OK mart
}

enum HomeDeliveryType {
  TCAT = 'TCAT',      // 黑貓宅急便
  ECAN = 'ECAN'       // 宅配通
}

enum PostType {
  POST = 'POST'       // 中華郵政
}

interface LogisticsOrderData {
  // 基本資訊
  merchantTradeNo: string;
  merchantTradeDate: string;
  logisticsType: LogisticsType;
  logisticsSubType: string;
  
  // 金額資訊
  goodsAmount: number;
  collectionAmount: number;
  isCollection: boolean;
  
  // 商品資訊
  goodsName: string;
  tradeDesc: string;
  
  // 寄件人資訊
  senderName: string;
  senderPhone?: string;
  senderCellPhone: string;
  senderZipCode?: string;
  senderAddress?: string;
  
  // 收件人資訊
  receiverName: string;
  receiverPhone?: string;
  receiverCellPhone: string;
  receiverEmail: string;
  receiverAddress?: string;
  
  // 超商資訊
  receiverStoreID?: string;
  returnStoreID?: string;
  
  // 宅配專用
  temperature?: Temperature;
  distance?: Distance;
  specification?: Specification;
  scheduledPickupTime?: ScheduledTime;
  scheduledDeliveryTime?: ScheduledTime;
  
  // 其他
  remark?: string;
  platformID?: string;
}

enum Temperature {
  ROOM = '0001',      // 常溫
  REFRIGERATED = '0002', // 冷藏
  FROZEN = '0003'     // 冷凍
}

enum Distance {
  SAME_COUNTY = '00',    // 同縣市
  REMOTE_AREA = '01',    // 外島
  OTHER_COUNTY = '02'    // 其他縣市
}

enum Specification {
  SIZE_60 = '0001',   // 60cm
  SIZE_90 = '0002',   // 90cm  
  SIZE_120 = '0003',  // 120cm
  SIZE_150 = '0004'   // 150cm
}

enum ScheduledTime {
  UNLIMITED = '1',    // 不限時
  MORNING = '2',      // 上午(9~12)
  AFTERNOON = '3',    // 下午(12~17)
  EVENING = '4'       // 晚上(17~20)
}
```

## 4. 物流管理服務

### 4.1 物流管理核心
```typescript
class LogisticsManager {
  private ecpayAPI: ECPayLogisticsAPI;
  private shippingCalculator: ShippingCalculator;
  private storeSelector: ConvenienceStoreSelector;

  // 建立物流訂單
  async createShippingOrder(order: Order, shippingInfo: ShippingInfo): Promise<ShippingOrder> {
    try {
      // 1. 驗證物流資訊
      await this.validateShippingInfo(shippingInfo);

      // 2. 計算運費
      const shippingFee = await this.shippingCalculator.calculateFee(order, shippingInfo);

      // 3. 準備綠界 API 參數
      const logisticsData = await this.prepareLogisticsData(order, shippingInfo);

      // 4. 呼叫綠界 API 建立物流訂單
      const ecpayResponse = await this.ecpayAPI.createLogisticsOrder(logisticsData);

      // 5. 建立內部物流訂單記錄
      const shippingOrder: ShippingOrder = {
        shippingOrderId: generateId(),
        orderId: order.orderId,
        merchantTradeNo: logisticsData.merchantTradeNo,
        ecpayTradeNo: ecpayResponse.allPayLogisticsID,
        logisticsType: shippingInfo.logisticsType,
        logisticsSubType: shippingInfo.logisticsSubType,
        status: ShippingStatus.CREATED,
        shippingFee: shippingFee,
        isCollection: shippingInfo.paymentMethod === 'cod',
        collectionAmount: shippingInfo.paymentMethod === 'cod' ? order.totalAmount : 0,
        senderInfo: this.getDefaultSenderInfo(),
        receiverInfo: shippingInfo.receiverInfo,
        storeInfo: shippingInfo.storeInfo,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      // 6. 保存物流訂單
      await this.shippingOrderRepository.save(shippingOrder);

      // 7. 更新訂單物流狀態
      await this.orderService.updateShippingStatus(order.orderId, ShippingStatus.CREATED);

      // 8. 發送通知
      await this.notificationService.sendShippingOrderCreated(order, shippingOrder);

      return shippingOrder;

    } catch (error) {
      await this.handleShippingOrderError(order.orderId, error);
      throw error;
    }
  }

  // 取消物流訂單
  async cancelShippingOrder(shippingOrderId: string, reason: string): Promise<void> {
    const shippingOrder = await this.shippingOrderRepository.findById(shippingOrderId);
    
    if (!shippingOrder) {
      throw new Error('物流訂單不存在');
    }

    if (![ShippingStatus.CREATED, ShippingStatus.WAITING_PICKUP].includes(shippingOrder.status)) {
      throw new Error('物流訂單狀態不允許取消');
    }

    try {
      // 呼叫綠界取消 API（如果支援）
      // 注意: 綠界某些物流類型不支援取消，需要聯繫客服
      
      // 更新內部狀態
      shippingOrder.status = ShippingStatus.CANCELLED;
      shippingOrder.cancelReason = reason;
      shippingOrder.cancelledAt = new Date();
      
      await this.shippingOrderRepository.save(shippingOrder);
      
      // 通知相關方
      await this.notificationService.sendShippingOrderCancelled(shippingOrder);
      
    } catch (error) {
      throw new LogisticsError(`取消物流訂單失敗: ${error.message}`);
    }
  }

  // 準備綠界物流資料
  private async prepareLogisticsData(order: Order, shippingInfo: ShippingInfo): Promise<LogisticsOrderData> {
    const merchantTradeNo = this.generateMerchantTradeNo(order.orderId);
    const senderInfo = this.getDefaultSenderInfo();
    
    const logisticsData: LogisticsOrderData = {
      merchantTradeNo,
      merchantTradeDate: this.formatDate(new Date()),
      logisticsType: shippingInfo.logisticsType,
      logisticsSubType: shippingInfo.logisticsSubType,
      goodsAmount: order.totalAmount,
      collectionAmount: shippingInfo.paymentMethod === 'cod' ? order.totalAmount : 0,
      isCollection: shippingInfo.paymentMethod === 'cod',
      goodsName: this.formatGoodsName(order.orderItems),
      tradeDesc: `MickeyShop訂單 ${order.orderNumber}`,
      senderName: senderInfo.name,
      senderCellPhone: senderInfo.cellPhone,
      senderPhone: senderInfo.phone,
      receiverName: shippingInfo.receiverInfo.name,
      receiverCellPhone: shippingInfo.receiverInfo.cellPhone,
      receiverPhone: shippingInfo.receiverInfo.phone,
      receiverEmail: shippingInfo.receiverInfo.email || order.customerEmail,
      remark: shippingInfo.notes
    };

    // 根據物流類型加入特定資訊
    if (shippingInfo.logisticsType === LogisticsType.CVS) {
      logisticsData.receiverStoreID = shippingInfo.storeInfo.storeId;
      logisticsData.returnStoreID = shippingInfo.storeInfo.storeId; // 預設退貨到同一門市
    } else if (shippingInfo.logisticsType === LogisticsType.HOME) {
      logisticsData.receiverAddress = shippingInfo.receiverInfo.address;
      logisticsData.senderZipCode = senderInfo.zipCode;
      logisticsData.senderAddress = senderInfo.address;
      logisticsData.temperature = this.determineTemperature(order.orderItems);
      logisticsData.specification = this.determineSpecification(order);
      logisticsData.scheduledDeliveryTime = shippingInfo.scheduledDeliveryTime || ScheduledTime.UNLIMITED;
    }

    return logisticsData;
  }

  // 產生商家訂單編號
  private generateMerchantTradeNo(orderId: string): string {
    return `MS${orderId.replace(/-/g, '').substring(0, 15)}`;
  }

  // 格式化商品名稱
  private formatGoodsName(orderItems: OrderItem[]): string {
    if (orderItems.length === 1) {
      return orderItems[0].productName.substring(0, 60);
    } else {
      const firstItem = orderItems[0].productName.substring(0, 30);
      return `${firstItem}等${orderItems.length}項商品`;
    }
  }

  // 判斷溫層
  private determineTemperature(orderItems: OrderItem[]): Temperature {
    // 檢查是否有冷凍商品
    const hasFrozen = orderItems.some(item => 
      item.product?.storageCondition === 'frozen'
    );
    if (hasFrozen) return Temperature.FROZEN;

    // 檢查是否有冷藏商品
    const hasRefrigerated = orderItems.some(item => 
      item.product?.storageCondition === 'refrigerated'
    );
    if (hasRefrigerated) return Temperature.REFRIGERATED;

    return Temperature.ROOM;
  }

  // 判斷規格
  private determineSpecification(order: Order): Specification {
    const totalVolume = order.orderItems.reduce((total, item) => {
      return total + (item.product?.volume || 0) * item.quantity;
    }, 0);

    if (totalVolume <= 60) return Specification.SIZE_60;
    if (totalVolume <= 90) return Specification.SIZE_90;
    if (totalVolume <= 120) return Specification.SIZE_120;
    return Specification.SIZE_150;
  }
}

interface ShippingOrder {
  shippingOrderId: string;
  orderId: string;
  merchantTradeNo: string;
  ecpayTradeNo?: string;
  cvsMerchantTradeNo?: string;
  cvsValidationNo?: string;
  
  // 物流資訊
  logisticsType: LogisticsType;
  logisticsSubType: string;
  status: ShippingStatus;
  trackingNumber?: string;
  
  // 費用資訊
  shippingFee: number;
  isCollection: boolean;
  collectionAmount: number;
  
  // 寄件人資訊
  senderInfo: SenderInfo;
  
  // 收件人資訊
  receiverInfo: ReceiverInfo;
  
  // 超商資訊（超商取貨專用）
  storeInfo?: StoreInfo;
  
  // 宅配資訊
  deliveryInfo?: DeliveryInfo;
  
  // 時間記錄
  createdAt: Date;
  updatedAt: Date;
  shippedAt?: Date;
  deliveredAt?: Date;
  cancelledAt?: Date;
  
  // 其他資訊
  notes?: string;
  cancelReason?: string;
  returnTrackingNumber?: string;
}

enum ShippingStatus {
  CREATED = 'created',                    // 已建立
  WAITING_PICKUP = 'waiting_pickup',      // 待取件
  PICKED_UP = 'picked_up',               // 已取件
  IN_TRANSIT = 'in_transit',             // 配送中
  OUT_FOR_DELIVERY = 'out_for_delivery',  // 派送中
  DELIVERED = 'delivered',               // 已送達
  FAILED_DELIVERY = 'failed_delivery',    // 配送失敗
  RETURNED = 'returned',                 // 已退回
  CANCELLED = 'cancelled',               // 已取消
  EXCEPTION = 'exception'                // 異常
}
```

### 4.2 運費計算服務
```typescript
class ShippingCalculator {
  private rateRepository: ShippingRateRepository;
  private settingService: SystemSettingService;

  // 計算運費
  async calculateFee(order: Order, shippingInfo: ShippingInfo): Promise<number> {
    // 1. 檢查免運費條件
    const freeShippingThreshold = await this.settingService.getValue(
      'order', 
      'free_shipping_threshold'
    ) as number;

    if (order.subtotalAmount >= freeShippingThreshold) {
      return 0;
    }

    // 2. 根據物流類型計算運費
    let baseFee = 0;
    
    switch (shippingInfo.logisticsType) {
      case LogisticsType.CVS:
        baseFee = await this.calculateCVSFee(order, shippingInfo);
        break;
      case LogisticsType.HOME:
        baseFee = await this.calculateHomeFee(order, shippingInfo);
        break;
      case LogisticsType.POST:
        baseFee = await this.calculatePostFee(order, shippingInfo);
        break;
    }

    // 3. 應用優惠券運費折扣
    if (order.appliedCoupons) {
      const shippingDiscount = this.calculateShippingDiscount(
        baseFee, 
        order.appliedCoupons
      );
      baseFee = Math.max(0, baseFee - shippingDiscount);
    }

    return baseFee;
  }

  // 計算超商運費
  private async calculateCVSFee(order: Order, shippingInfo: ShippingInfo): Promise<number> {
    const rate = await this.rateRepository.findCVSRate(
      shippingInfo.logisticsSubType as CVSType,
      shippingInfo.paymentMethod === 'cod'
    );

    if (!rate) {
      throw new Error(`找不到 ${shippingInfo.logisticsSubType} 的運費設定`);
    }

    // 檢查重量限制
    const totalWeight = this.calculateTotalWeight(order.orderItems);
    if (totalWeight > rate.maxWeight) {
      throw new Error(`商品總重量 ${totalWeight}g 超過 ${shippingInfo.logisticsSubType} 限重 ${rate.maxWeight}g`);
    }

    // 檢查尺寸限制
    const maxDimension = this.calculateMaxDimension(order.orderItems);
    if (maxDimension > rate.maxDimension) {
      throw new Error(`商品尺寸超過 ${shippingInfo.logisticsSubType} 限制`);
    }

    return rate.baseFee;
  }

  // 計算宅配運費
  private async calculateHomeFee(order: Order, shippingInfo: ShippingInfo): Promise<number> {
    const rate = await this.rateRepository.findHomeDeliveryRate(
      shippingInfo.logisticsSubType as HomeDeliveryType,
      shippingInfo.temperature || Temperature.ROOM,
      shippingInfo.distance || Distance.SAME_COUNTY
    );

    if (!rate) {
      throw new Error(`找不到宅配運費設定`);
    }

    let fee = rate.baseFee;

    // 根據重量加收費用
    const totalWeight = this.calculateTotalWeight(order.orderItems);
    if (totalWeight > rate.freeWeightLimit) {
      const extraWeight = Math.ceil((totalWeight - rate.freeWeightLimit) / rate.weightUnit);
      fee += extraWeight * rate.extraWeightFee;
    }

    // 根據尺寸加收費用
    const specification = this.determineSpecification(order);
    if (specification !== Specification.SIZE_60) {
      fee += rate.sizeUpcharge || 0;
    }

    return fee;
  }

  // 計算郵局運費
  private async calculatePostFee(order: Order, shippingInfo: ShippingInfo): Promise<number> {
    const rate = await this.rateRepository.findPostRate();
    
    if (!rate) {
      throw new Error('找不到郵局運費設定');
    }

    // 郵局運費通常依據重量計算
    const totalWeight = this.calculateTotalWeight(order.orderItems);
    const weightLevel = Math.ceil(totalWeight / rate.weightUnit);
    
    return rate.baseFee * weightLevel;
  }

  private calculateTotalWeight(orderItems: OrderItem[]): number {
    return orderItems.reduce((total, item) => {
      return total + (item.product?.weight || 0) * item.quantity;
    }, 0);
  }

  private calculateMaxDimension(orderItems: OrderItem[]): number {
    return Math.max(...orderItems.map(item => 
      Math.max(
        item.product?.length || 0,
        item.product?.width || 0,
        item.product?.height || 0
      )
    ));
  }
}

// 運費設定資料結構
interface ShippingRate {
  rateId: string;
  name: string;
  logisticsType: LogisticsType;
  logisticsSubType: string;
  isActive: boolean;
  
  // 基本費用
  baseFee: number;
  
  // 重量限制
  maxWeight: number;
  freeWeightLimit: number;
  weightUnit: number;
  extraWeightFee: number;
  
  // 尺寸限制
  maxDimension: number;
  sizeUpcharge?: number;
  
  // 特殊條件
  supportsCOD: boolean;
  supportsCold: boolean;
  minAmount?: number;
  maxAmount?: number;
  
  // 地區限制
  availableAreas: string[];
  excludedAreas: string[];
  
  createdAt: Date;
  updatedAt: Date;
}
```

## 5. 超商門市選擇服務

### 5.1 門市選擇服務
```typescript
class ConvenienceStoreSelector {
  private ecpayAPI: ECPayLogisticsAPI;
  private storeRepository: StoreRepository;

  // 產生超商地圖
  async generateStoreMap(
    cvsType: CVSType, 
    isCollection: boolean = false,
    userAddress?: string
  ): Promise<StoreMapResponse> {
    try {
      // 產生綠界超商地圖
      const mapHTML = await this.ecpayAPI.generateCVSMap(cvsType, isCollection);
      
      // 如果有使用者地址，獲取附近門市
      let nearbyStores: StoreInfo[] = [];
      if (userAddress) {
        nearbyStores = await this.findNearbyStores(cvsType, userAddress);
      }

      return {
        mapHTML,
        nearbyStores,
        cvsType,
        isCollection
      };

    } catch (error) {
      throw new LogisticsError(`產生超商地圖失敗: ${error.message}`);
    }
  }

  // 處理門市選擇回調
  async handleStoreSelection(selectionData: StoreSelectionData): Promise<StoreInfo> {
    // 驗證門市選擇資料
    if (!this.validateStoreSelection(selectionData)) {
      throw new Error('門市選擇資料無效');
    }

    const storeInfo: StoreInfo = {
      storeId: selectionData.CVSStoreID,
      storeName: selectionData.CVSStoreName,
      storeAddress: selectionData.CVSAddress,
      storeTelephone: selectionData.CVSTelephone,
      cvsType: this.parseCVSType(selectionData.LogisticsSubType),
      
      // 解析額外資訊
      zipCode: this.parseZipCode(selectionData.CVSAddress),
      district: this.parseDistrict(selectionData.CVSAddress),
      city: this.parseCity(selectionData.CVSAddress),
      
      // 營業時間等資訊需要另外查詢或預設
      businessHours: this.getDefaultBusinessHours(selectionData.LogisticsSubType),
      
      // 記錄時間
      selectedAt: new Date()
    };

    // 儲存門市資訊到資料庫（可選）
    await this.storeRepository.upsert(storeInfo);

    return storeInfo;
  }

  // 搜尋附近門市
  async findNearbyStores(cvsType: CVSType, address: string, limit: number = 10): Promise<StoreInfo[]> {
    try {
      // 將地址轉換為座標
      const coordinates = await this.geocodingService.geocode(address);
      
      // 搜尋附近門市
      const stores = await this.storeRepository.findNearby(
        cvsType,
        coordinates.latitude,
        coordinates.longitude,
        5000, // 5公里內
        limit
      );

      return stores;

    } catch (error) {
      // 如果地理編碼失敗，返回熱門門市
      return await this.getPopularStores(cvsType, limit);
    }
  }

  // 驗證門市營業狀態
  async validateStoreStatus(storeId: string, cvsType: CVSType): Promise<boolean> {
    try {
      const storeInfo = await this.storeRepository.findByStoreId(storeId, cvsType);
      
      if (!storeInfo) {
        return false;
      }

      // 檢查門市是否停業
      if (storeInfo.status === 'closed') {
        return false;
      }

      // 檢查是否支援取貨服務
      if (!storeInfo.supportPickup) {
        return false;
      }

      return true;

    } catch (error) {
      // 如果查詢失敗，假設門市可用
      return true;
    }
  }

  private validateStoreSelection(data: StoreSelectionData): boolean {
    const requiredFields = [
      'CVSStoreID',
      'CVSStoreName', 
      'CVSAddress',
      'LogisticsSubType'
    ];

    return requiredFields.every(field => 
      data[field] && data[field].toString().trim().length > 0
    );
  }

  private parseCVSType(logisticsSubType: string): CVSType {
    switch (logisticsSubType) {
      case 'SEVEN': return CVSType.SEVEN;
      case 'FAMILY': return CVSType.FAMILY;
      case 'HILIFE': return CVSType.HILIFE;
      case 'OKMART': return CVSType.OKMART;
      default: throw new Error(`不支援的超商類型: ${logisticsSubType}`);
    }
  }

  private parseZipCode(address: string): string {
    const match = address.match(/^(\d{3,5})/);
    return match ? match[1] : '';
  }

  private parseCity(address: string): string {
    const match = address.match(/^(\d{3,5})(.+?)[市縣]/);
    return match ? match[2] + (address.includes('市') ? '市' : '縣') : '';
  }

  private parseDistrict(address: string): string {
    const match = address.match(/[市縣](.+?)[區鎮鄉市]/);
    return match ? match[1] + (address.includes('區') ? '區' : 
                              address.includes('鎮') ? '鎮' : 
                              address.includes('鄉') ? '鄉' : '市') : '';
  }

  private getDefaultBusinessHours(cvsType: string): string {
    // 一般超商營業時間
    const defaultHours = {
      'SEVEN': '24小時',
      'FAMILY': '24小時', 
      'HILIFE': '06:00-24:00',
      'OKMART': '06:00-24:00'
    };

    return defaultHours[cvsType] || '06:00-24:00';
  }
}

interface StoreSelectionData {
  MerchantID: string;
  MerchantTradeNo: string;
  LogisticsSubType: string;
  CVSStoreID: string;
  CVSStoreName: string;
  CVSAddress: string;
  CVSTelephone: string;
  ExtraData?: string;
}

interface StoreInfo {
  storeId: string;
  storeName: string;
  storeAddress: string;
  storeTelephone?: string;
  cvsType: CVSType;
  
  // 地址解析
  zipCode: string;
  city: string;
  district: string;
  
  // 營業資訊
  businessHours: string;
  status?: 'open' | 'closed' | 'temporarily_closed';
  supportPickup?: boolean;
  supportCOD?: boolean;
  
  // 地理資訊
  latitude?: number;
  longitude?: number;
  distance?: number; // 距離使用者的公尺數
  
  // 時間資訊
  selectedAt?: Date;
  lastUpdated?: Date;
}

interface StoreMapResponse {
  mapHTML: string;
  nearbyStores: StoreInfo[];
  cvsType: CVSType;
  isCollection: boolean;
}
```

## 6. 物流狀態追蹤服務

### 6.1 狀態追蹤服務
```typescript
class LogisticsTrackingService {
  private ecpayAPI: ECPayLogisticsAPI;
  private statusSynchronizer: LogisticsStatusSynchronizer;

  // 查詢物流狀態
  async trackShippingOrder(shippingOrderId: string): Promise<TrackingInfo> {
    const shippingOrder = await this.shippingOrderRepository.findById(shippingOrderId);
    
    if (!shippingOrder) {
      throw new Error('物流訂單不存在');
    }

    try {
      // 查詢綠界物流狀態
      const ecpayStatus = await this.ecpayAPI.queryLogisticsInfo(
        shippingOrder.merchantTradeNo
      );

      // 更新內部狀態
      await this.statusSynchronizer.syncStatus(shippingOrder, ecpayStatus);

      // 組合追蹤資訊
      const trackingInfo: TrackingInfo = {
        shippingOrderId,
        merchantTradeNo: shippingOrder.merchantTradeNo,
        ecpayTradeNo: shippingOrder.ecpayTradeNo,
        status: shippingOrder.status,
        statusText: this.getStatusText(shippingOrder.status),
        trackingNumber: shippingOrder.trackingNumber,
        
        // 時間軸
        timeline: await this.buildStatusTimeline(shippingOrder),
        
        // 物流商資訊
        logisticsProvider: this.getLogisticsProviderInfo(shippingOrder),
        
        // 預估送達時間
        estimatedDeliveryTime: await this.calculateEstimatedDelivery(shippingOrder),
        
        // 最後更新時間
        lastUpdated: new Date()
      };

      return trackingInfo;

    } catch (error) {
      throw new LogisticsError(`查詢物流狀態失敗: ${error.message}`);
    }
  }

  // 批次更新物流狀態
  async batchUpdateStatus(): Promise<BatchUpdateResult> {
    // 取得需要更新的物流訂單
    const pendingOrders = await this.shippingOrderRepository.findPendingOrders();
    
    const results: BatchUpdateResult = {
      total: pendingOrders.length,
      success: 0,
      failed: 0,
      errors: []
    };

    for (const order of pendingOrders) {
      try {
        await this.trackShippingOrder(order.shippingOrderId);
        results.success++;
      } catch (error) {
        results.failed++;
        results.errors.push({
          shippingOrderId: order.shippingOrderId,
          error: error.message
        });
      }
    }

    return results;
  }

  // 建立狀態時間軸
  private async buildStatusTimeline(shippingOrder: ShippingOrder): Promise<TimelineItem[]> {
    const timeline: TimelineItem[] = [];

    // 訂單建立
    timeline.push({
      status: ShippingStatus.CREATED,
      statusText: '物流訂單已建立',
      timestamp: shippingOrder.createdAt,
      description: '已向物流商建立配送訂單'
    });

    // 如果已取件
    if (shippingOrder.pickedUpAt) {
      timeline.push({
        status: ShippingStatus.PICKED_UP,
        statusText: '商品已取件',
        timestamp: shippingOrder.pickedUpAt,
        description: '物流商已從賣家取件'
      });
    }

    // 如果在運輸中
    if (shippingOrder.status === ShippingStatus.IN_TRANSIT) {
      timeline.push({
        status: ShippingStatus.IN_TRANSIT,
        statusText: '商品配送中',
        timestamp: new Date(),
        description: '商品正在配送途中'
      });
    }

    // 如果已送達
    if (shippingOrder.deliveredAt) {
      timeline.push({
        status: ShippingStatus.DELIVERED,
        statusText: '商品已送達',
        timestamp: shippingOrder.deliveredAt,
        description: this.getDeliveryDescription(shippingOrder)
      });
    }

    return timeline.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
  }

  private getStatusText(status: ShippingStatus): string {
    const statusTexts = {
      [ShippingStatus.CREATED]: '已建立物流訂單',
      [ShippingStatus.WAITING_PICKUP]: '等待取件',
      [ShippingStatus.PICKED_UP]: '已取件',
      [ShippingStatus.IN_TRANSIT]: '配送中',
      [ShippingStatus.OUT_FOR_DELIVERY]: '派送中',
      [ShippingStatus.DELIVERED]: '已送達',
      [ShippingStatus.FAILED_DELIVERY]: '配送失敗',
      [ShippingStatus.RETURNED]: '已退回',
      [ShippingStatus.CANCELLED]: '已取消',
      [ShippingStatus.EXCEPTION]: '異常'
    };

    return statusTexts[status] || '未知狀態';
  }

  private getLogisticsProviderInfo(shippingOrder: ShippingOrder): LogisticsProvider {
    const providers = {
      [CVSType.SEVEN]: {
        name: '7-ELEVEN',
        phone: '0800-008-711',
        website: 'https://www.7-11.com.tw'
      },
      [CVSType.FAMILY]: {
        name: '全家便利商店',
        phone: '0800-030-899',
        website: 'https://www.family.com.tw'
      },
      [HomeDeliveryType.TCAT]: {
        name: '黑貓宅急便',
        phone: '0800-010-199',
        website: 'https://www.t-cat.com.tw'
      },
      [HomeDeliveryType.ECAN]: {
        name: '宅配通',
        phone: '0800-200-777',
        website: 'https://www.e-can.com.tw'
      }
    };

    return providers[shippingOrder.logisticsSubType] || {
      name: '物流商',
      phone: '',
      website: ''
    };
  }

  private async calculateEstimatedDelivery(shippingOrder: ShippingOrder): Promise<Date | null> {
    // 根據物流類型和目前狀態估算送達時間
    const now = new Date();
    let estimatedHours = 0;

    switch (shippingOrder.logisticsType) {
      case LogisticsType.CVS:
        // 超商取貨通常 1-2 工作天
        estimatedHours = shippingOrder.status === ShippingStatus.CREATED ? 48 : 24;
        break;
      case LogisticsType.HOME:
        // 宅配通常當天或隔天
        estimatedHours = shippingOrder.status === ShippingStatus.CREATED ? 24 : 8;
        break;
      case LogisticsType.POST:
        // 郵局 2-3 工作天
        estimatedHours = 72;
        break;
    }

    if (estimatedHours === 0) return null;

    const estimated = new Date(now.getTime() + estimatedHours * 60 * 60 * 1000);
    return estimated;
  }

  private getDeliveryDescription(shippingOrder: ShippingOrder): string {
    if (shippingOrder.logisticsType === LogisticsType.CVS) {
      return `商品已送達 ${shippingOrder.storeInfo?.storeName} 門市，請持證件取貨`;
    } else {
      return '商品已送達指定地址';
    }
  }
}

interface TrackingInfo {
  shippingOrderId: string;
  merchantTradeNo: string;
  ecpayTradeNo?: string;
  status: ShippingStatus;
  statusText: string;
  trackingNumber?: string;
  timeline: TimelineItem[];
  logisticsProvider: LogisticsProvider;
  estimatedDeliveryTime?: Date;
  lastUpdated: Date;
}

interface TimelineItem {
  status: ShippingStatus;
  statusText: string;
  timestamp: Date;
  description: string;
  location?: string;
}

interface LogisticsProvider {
  name: string;
  phone: string;
  website: string;
  trackingUrl?: string;
}

interface BatchUpdateResult {
  total: number;
  success: number;
  failed: number;
  errors: Array<{
    shippingOrderId: string;
    error: string;
  }>;
}
```

### 6.2 狀態同步器
```typescript
class LogisticsStatusSynchronizer {
  // 同步物流狀態
  async syncStatus(
    shippingOrder: ShippingOrder, 
    ecpayStatus: LogisticsStatusResponse
  ): Promise<void> {
    const oldStatus = shippingOrder.status;
    const newStatus = this.mapECPayStatus(ecpayStatus.LogisticsStatus);

    // 如果狀態無變化，不需要處理
    if (oldStatus === newStatus) {
      return;
    }

    // 更新物流訂單狀態
    shippingOrder.status = newStatus;
    shippingOrder.updatedAt = new Date();

    // 更新特定狀態的時間戳記
    switch (newStatus) {
      case ShippingStatus.PICKED_UP:
        shippingOrder.pickedUpAt = new Date();
        break;
      case ShippingStatus.DELIVERED:
        shippingOrder.deliveredAt = new Date();
        break;
    }

    // 更新追蹤號碼
    if (ecpayStatus.BookingNote) {
      shippingOrder.trackingNumber = ecpayStatus.BookingNote;
    }

    // 儲存更新
    await this.shippingOrderRepository.save(shippingOrder);

    // 更新主訂單狀態
    await this.updateOrderStatus(shippingOrder);

    // 發送狀態變更通知
    await this.sendStatusChangeNotification(shippingOrder, oldStatus, newStatus);

    // 記錄狀態變更歷史
    await this.logStatusChange(shippingOrder, oldStatus, newStatus, ecpayStatus);
  }

  // 對映綠界狀態到內部狀態
  private mapECPayStatus(ecpayStatus: string): ShippingStatus {
    const statusMapping = {
      '300': ShippingStatus.CREATED,          // 訂單處理中
      '2030': ShippingStatus.WAITING_PICKUP,  // 商品已到達物流商
      '2001': ShippingStatus.PICKED_UP,       // 商品已被取件
      '3003': ShippingStatus.IN_TRANSIT,      // 商品配送中
      '2067': ShippingStatus.OUT_FOR_DELIVERY, // 商品派送中
      '2073': ShippingStatus.DELIVERED,       // 商品已送達
      '2074': ShippingStatus.DELIVERED,       // 超商已取貨
      '2065': ShippingStatus.FAILED_DELIVERY, // 配送異常
      '2068': ShippingStatus.RETURNED,        // 商品已退回
      '2064': ShippingStatus.EXCEPTION        // 其他異常
    };

    return statusMapping[ecpayStatus] || ShippingStatus.EXCEPTION;
  }

  // 更新主訂單狀態
  private async updateOrderStatus(shippingOrder: ShippingOrder): Promise<void> {
    const order = await this.orderRepository.findById(shippingOrder.orderId);
    
    if (!order) return;

    let newOrderStatus = order.status;

    switch (shippingOrder.status) {
      case ShippingStatus.PICKED_UP:
        if (order.status === OrderStatus.CONFIRMED) {
          newOrderStatus = OrderStatus.SHIPPED;
        }
        break;
      case ShippingStatus.DELIVERED:
        if ([OrderStatus.CONFIRMED, OrderStatus.SHIPPED].includes(order.status)) {
          newOrderStatus = OrderStatus.DELIVERED;
        }
        break;
    }

    if (newOrderStatus !== order.status) {
      await this.orderService.updateStatus(order.orderId, newOrderStatus);
    }
  }

  // 發送狀態變更通知
  private async sendStatusChangeNotification(
    shippingOrder: ShippingOrder,
    oldStatus: ShippingStatus,
    newStatus: ShippingStatus
  ): Promise<void> {
    const order = await this.orderRepository.findById(shippingOrder.orderId);
    
    if (!order) return;

    const notificationEvents = {
      [ShippingStatus.PICKED_UP]: 'shipping_picked_up',
      [ShippingStatus.OUT_FOR_DELIVERY]: 'shipping_out_for_delivery',
      [ShippingStatus.DELIVERED]: 'shipping_delivered',
      [ShippingStatus.FAILED_DELIVERY]: 'shipping_failed',
      [ShippingStatus.RETURNED]: 'shipping_returned'
    };

    const eventType = notificationEvents[newStatus];
    if (eventType) {
      await this.notificationService.sendNotification({
        eventType,
        recipientId: order.customerId,
        data: {
          orderId: order.orderId,
          orderNumber: order.orderNumber,
          shippingOrder,
          trackingInfo: await this.trackingService.trackShippingOrder(
            shippingOrder.shippingOrderId
          )
        }
      });
    }
  }

  // 記錄狀態變更歷史
  private async logStatusChange(
    shippingOrder: ShippingOrder,
    oldStatus: ShippingStatus,
    newStatus: ShippingStatus,
    ecpayResponse: LogisticsStatusResponse
  ): Promise<void> {
    const statusLog: ShippingStatusLog = {
      logId: generateId(),
      shippingOrderId: shippingOrder.shippingOrderId,
      fromStatus: oldStatus,
      toStatus: newStatus,
      changedAt: new Date(),
      source: 'ecpay_sync',
      rawData: ecpayResponse,
      notes: `狀態從 ${this.getStatusText(oldStatus)} 變更為 ${this.getStatusText(newStatus)}`
    };

    await this.shippingStatusLogRepository.save(statusLog);
  }

  private getStatusText(status: ShippingStatus): string {
    // 與 TrackingService 中的相同實作
    const statusTexts = {
      [ShippingStatus.CREATED]: '已建立',
      [ShippingStatus.WAITING_PICKUP]: '等待取件',
      [ShippingStatus.PICKED_UP]: '已取件',
      [ShippingStatus.IN_TRANSIT]: '配送中',
      [ShippingStatus.OUT_FOR_DELIVERY]: '派送中',
      [ShippingStatus.DELIVERED]: '已送達',
      [ShippingStatus.FAILED_DELIVERY]: '配送失敗',
      [ShippingStatus.RETURNED]: '已退回',
      [ShippingStatus.CANCELLED]: '已取消',
      [ShippingStatus.EXCEPTION]: '異常'
    };

    return statusTexts[status] || '未知';
  }
}

interface ShippingStatusLog {
  logId: string;
  shippingOrderId: string;
  fromStatus: ShippingStatus;
  toStatus: ShippingStatus;
  changedAt: Date;
  source: 'ecpay_sync' | 'manual' | 'system';
  rawData?: any;
  notes?: string;
}
```

## 7. 退貨逆物流服務

### 7.1 退貨物流管理
```typescript
class ReturnLogisticsService {
  private ecpayAPI: ECPayLogisticsAPI;
  private returnOrderRepository: ReturnOrderRepository;

  // 建立退貨物流
  async createReturnShipping(returnOrder: ReturnOrder): Promise<ReturnShippingOrder> {
    const originalShipping = await this.shippingOrderRepository.findByOrderId(
      returnOrder.originalOrderId
    );

    if (!originalShipping) {
      throw new Error('找不到原始物流訂單');
    }

    try {
      let returnShipping: ReturnShippingOrder;

      if (originalShipping.logisticsType === LogisticsType.CVS) {
        // 超商退貨
        returnShipping = await this.createCVSReturnShipping(returnOrder, originalShipping);
      } else {
        // 宅配退貨
        returnShipping = await this.createHomeReturnShipping(returnOrder, originalShipping);
      }

      // 保存退貨物流記錄
      await this.returnShippingOrderRepository.save(returnShipping);

      // 更新退貨單狀態
      await this.returnOrderService.updateStatus(
        returnOrder.returnOrderId,
        ReturnStatus.RETURN_SHIPPING_CREATED
      );

      return returnShipping;

    } catch (error) {
      throw new LogisticsError(`建立退貨物流失敗: ${error.message}`);
    }
  }

  // 建立超商退貨物流
  private async createCVSReturnShipping(
    returnOrder: ReturnOrder,
    originalShipping: ShippingOrder
  ): Promise<ReturnShippingOrder> {
    // 超商退貨通常使用原門市
    const returnStoreId = originalShipping.storeInfo?.storeId;
    
    if (!returnStoreId) {
      throw new Error('無法確定退貨門市');
    }

    // 產生退貨物流單號
    const returnMerchantTradeNo = this.generateReturnTradeNo(returnOrder.returnOrderId);

    const logisticsData: LogisticsOrderData = {
      merchantTradeNo: returnMerchantTradeNo,
      merchantTradeDate: this.formatDate(new Date()),
      logisticsType: originalShipping.logisticsType,
      logisticsSubType: originalShipping.logisticsSubType,
      goodsAmount: returnOrder.refundAmount,
      collectionAmount: 0, // 退貨不代收
      isCollection: false,
      goodsName: this.formatReturnGoodsName(returnOrder.returnItems),
      tradeDesc: `退貨單 ${returnOrder.returnOrderNumber}`,
      
      // 寄件人（客戶）資訊
      senderName: returnOrder.customerInfo.name,
      senderCellPhone: returnOrder.customerInfo.cellPhone,
      senderPhone: returnOrder.customerInfo.phone,
      
      // 收件人（公司）資訊  
      receiverName: this.getCompanyInfo().name,
      receiverCellPhone: this.getCompanyInfo().cellPhone,
      receiverPhone: this.getCompanyInfo().phone,
      receiverEmail: this.getCompanyInfo().email,
      
      // 門市資訊
      receiverStoreID: returnStoreId,
      
      remark: `退貨原因: ${returnOrder.reason}`
    };

    // 呼叫綠界 API 建立退貨物流
    const ecpayResponse = await this.ecpayAPI.createLogisticsOrder(logisticsData);

    return {
      returnShippingId: generateId(),
      returnOrderId: returnOrder.returnOrderId,
      originalShippingOrderId: originalShipping.shippingOrderId,
      merchantTradeNo: returnMerchantTradeNo,
      ecpayTradeNo: ecpayResponse.allPayLogisticsID,
      logisticsType: originalShipping.logisticsType,
      logisticsSubType: originalShipping.logisticsSubType,
      status: ReturnShippingStatus.CREATED,
      returnStoreInfo: originalShipping.storeInfo,
      customerInfo: returnOrder.customerInfo,
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  // 建立宅配退貨物流
  private async createHomeReturnShipping(
    returnOrder: ReturnOrder,
    originalShipping: ShippingOrder
  ): Promise<ReturnShippingOrder> {
    const returnMerchantTradeNo = this.generateReturnTradeNo(returnOrder.returnOrderId);
    const companyInfo = this.getCompanyInfo();

    const logisticsData: LogisticsOrderData = {
      merchantTradeNo: returnMerchantTradeNo,
      merchantTradeDate: this.formatDate(new Date()),
      logisticsType: LogisticsType.HOME,
      logisticsSubType: originalShipping.logisticsSubType,
      goodsAmount: returnOrder.refundAmount,
      collectionAmount: 0,
      isCollection: false,
      goodsName: this.formatReturnGoodsName(returnOrder.returnItems),
      tradeDesc: `退貨單 ${returnOrder.returnOrderNumber}`,
      
      // 寄件人（客戶）資訊
      senderName: returnOrder.customerInfo.name,
      senderCellPhone: returnOrder.customerInfo.cellPhone,
      senderAddress: returnOrder.customerInfo.address,
      senderZipCode: this.parseZipCode(returnOrder.customerInfo.address),
      
      // 收件人（公司）資訊
      receiverName: companyInfo.name,
      receiverCellPhone: companyInfo.cellPhone,
      receiverAddress: companyInfo.address,
      receiverEmail: companyInfo.email,
      
      // 宅配設定
      temperature: Temperature.ROOM,
      specification: Specification.SIZE_60,
      scheduledPickupTime: ScheduledTime.UNLIMITED,
      
      remark: `退貨原因: ${returnOrder.reason}`
    };

    const ecpayResponse = await this.ecpayAPI.createLogisticsOrder(logisticsData);

    return {
      returnShippingId: generateId(),
      returnOrderId: returnOrder.returnOrderId,
      originalShippingOrderId: originalShipping.shippingOrderId,
      merchantTradeNo: returnMerchantTradeNo,
      ecpayTradeNo: ecpayResponse.allPayLogisticsID,
      logisticsType: LogisticsType.HOME,
      logisticsSubType: originalShipping.logisticsSubType,
      status: ReturnShippingStatus.CREATED,
      customerInfo: returnOrder.customerInfo,
      companyAddress: companyInfo.address,
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  // 處理退貨送達
  async handleReturnDelivered(returnShippingId: string): Promise<void> {
    const returnShipping = await this.returnShippingOrderRepository.findById(returnShippingId);
    
    if (!returnShipping) {
      throw new Error('退貨物流訂單不存在');
    }

    // 更新退貨物流狀態
    returnShipping.status = ReturnShippingStatus.DELIVERED;
    returnShipping.deliveredAt = new Date();
    returnShipping.updatedAt = new Date();
    
    await this.returnShippingOrderRepository.save(returnShipping);

    // 更新退貨單狀態
    await this.returnOrderService.updateStatus(
      returnShipping.returnOrderId,
      ReturnStatus.RETURNED_TO_WAREHOUSE
    );

    // 觸發質檢流程
    await this.qualityInspectionService.startInspection(returnShipping.returnOrderId);

    // 發送通知
    await this.notificationService.sendReturnDeliveredNotification(returnShipping);
  }

  private generateReturnTradeNo(returnOrderId: string): string {
    return `RTN${returnOrderId.replace(/-/g, '').substring(0, 12)}`;
  }

  private formatReturnGoodsName(returnItems: ReturnItem[]): string {
    if (returnItems.length === 1) {
      return `退貨-${returnItems[0].productName}`.substring(0, 60);
    } else {
      return `退貨商品等${returnItems.length}項`;
    }
  }

  private getCompanyInfo(): CompanyInfo {
    return {
      name: 'MickeyShop Beauty',
      cellPhone: '0900-000-000',
      phone: '02-0000-0000',
      email: 'service@mickeyshop.com',
      address: '台北市信義區信義路五段7號',
      zipCode: '11049'
    };
  }
}

interface ReturnShippingOrder {
  returnShippingId: string;
  returnOrderId: string;
  originalShippingOrderId: string;
  merchantTradeNo: string;
  ecpayTradeNo?: string;
  trackingNumber?: string;
  
  logisticsType: LogisticsType;
  logisticsSubType: string;
  status: ReturnShippingStatus;
  
  // 客戶資訊
  customerInfo: CustomerInfo;
  
  // 門市資訊（超商退貨）
  returnStoreInfo?: StoreInfo;
  
  // 公司地址（宅配退貨）
  companyAddress?: string;
  
  // 時間記錄
  createdAt: Date;
  updatedAt: Date;
  pickedUpAt?: Date;
  deliveredAt?: Date;
  
  // 其他資訊
  notes?: string;
}

enum ReturnShippingStatus {
  CREATED = 'created',
  WAITING_PICKUP = 'waiting_pickup',
  PICKED_UP = 'picked_up',
  IN_TRANSIT = 'in_transit',
  DELIVERED = 'delivered',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

interface CompanyInfo {
  name: string;
  cellPhone: string;
  phone: string;
  email: string;
  address: string;
  zipCode: string;
}
```

## 8. 異常處理與重試機制

### 8.1 異常處理服務
```typescript
class LogisticsExceptionHandler {
  private retryService: LogisticsRetryService;
  private alertService: AlertService;

  // 處理物流異常
  async handleException(exception: LogisticsException): Promise<void> {
    // 記錄異常
    await this.logException(exception);

    // 根據異常類型處理
    switch (exception.type) {
      case LogisticsExceptionType.API_TIMEOUT:
        await this.handleAPITimeout(exception);
        break;
      case LogisticsExceptionType.API_ERROR:
        await this.handleAPIError(exception);
        break;
      case LogisticsExceptionType.STATUS_SYNC_FAILED:
        await this.handleStatusSyncFailed(exception);
        break;
      case LogisticsExceptionType.DELIVERY_FAILED:
        await this.handleDeliveryFailed(exception);
        break;
      case LogisticsExceptionType.STORE_NOT_AVAILABLE:
        await this.handleStoreNotAvailable(exception);
        break;
      default:
        await this.handleUnknownException(exception);
    }
  }

  // 處理 API 超時
  private async handleAPITimeout(exception: LogisticsException): Promise<void> {
    const shippingOrder = await this.getShippingOrder(exception.shippingOrderId);
    
    // 如果是建立物流訂單超時，嘗試重試
    if (exception.operation === 'createLogisticsOrder') {
      await this.retryService.scheduleRetry(
        exception.shippingOrderId,
        exception.operation,
        exception.requestData,
        3 // 最多重試 3 次
      );
    }

    // 如果是查詢狀態超時，降低查詢頻率
    if (exception.operation === 'queryLogisticsInfo') {
      await this.adjustQueryFrequency(exception.shippingOrderId, 'decrease');
    }
  }

  // 處理 API 錯誤
  private async handleAPIError(exception: LogisticsException): Promise<void> {
    const errorCode = exception.errorCode;
    
    switch (errorCode) {
      case '10400003': // 物流單號重複
        await this.handleDuplicateTradeNo(exception);
        break;
      case '10400004': // 門市暫停服務
        await this.handleStoreTemporarilyClosed(exception);
        break;
      case '10400005': // 商品超重
        await this.handleOverweight(exception);
        break;
      default:
        await this.handleGenericAPIError(exception);
    }
  }

  // 處理配送失敗
  private async handleDeliveryFailed(exception: LogisticsException): Promise<void> {
    const shippingOrder = await this.getShippingOrder(exception.shippingOrderId);
    
    // 記錄配送失敗
    shippingOrder.status = ShippingStatus.FAILED_DELIVERY;
    shippingOrder.failureReason = exception.message;
    shippingOrder.failedAt = new Date();
    
    await this.shippingOrderRepository.save(shippingOrder);

    // 通知客戶
    await this.notificationService.sendDeliveryFailedNotification(shippingOrder);

    // 根據失敗原因決定後續處理
    if (this.isRetryableFailure(exception)) {
      // 可重試的失敗，安排重新配送
      await this.scheduleRedelivery(shippingOrder);
    } else {
      // 不可重試的失敗，聯繫客服處理
      await this.escalateToCustomerService(shippingOrder, exception);
    }
  }

  // 處理門市不可用
  private async handleStoreNotAvailable(exception: LogisticsException): Promise<void> {
    const shippingOrder = await this.getShippingOrder(exception.shippingOrderId);
    
    if (!shippingOrder || shippingOrder.logisticsType !== LogisticsType.CVS) {
      return;
    }

    // 標記門市為不可用
    await this.markStoreUnavailable(
      shippingOrder.storeInfo.storeId,
      shippingOrder.storeInfo.cvsType
    );

    // 尋找替代門市
    const alternativeStores = await this.findAlternativeStores(
      shippingOrder.storeInfo,
      shippingOrder.receiverInfo.address
    );

    if (alternativeStores.length > 0) {
      // 通知客戶選擇替代門市
      await this.notificationService.sendStoreAlternativeNotification(
        shippingOrder,
        alternativeStores
      );
    } else {
      // 沒有替代門市，建議改用宅配
      await this.notificationService.sendSuggestHomeDeliveryNotification(shippingOrder);
    }
  }

  // 處理重複訂單號
  private async handleDuplicateTradeNo(exception: LogisticsException): Promise<void> {
    const shippingOrder = await this.getShippingOrder(exception.shippingOrderId);
    
    // 產生新的訂單號
    const newTradeNo = this.generateNewTradeNo(shippingOrder.merchantTradeNo);
    shippingOrder.merchantTradeNo = newTradeNo;
    
    await this.shippingOrderRepository.save(shippingOrder);

    // 重新建立物流訂單
    await this.retryService.scheduleRetry(
      exception.shippingOrderId,
      'createLogisticsOrder',
      exception.requestData,
      1
    );
  }

  // 檢查是否為可重試的失敗
  private isRetryableFailure(exception: LogisticsException): boolean {
    const retryableReasons = [
      '收件人不在',
      '地址錯誤',
      '聯絡不上收件人',
      '拒收'
    ];

    return retryableReasons.some(reason => 
      exception.message.includes(reason)
    );
  }

  // 安排重新配送
  private async scheduleRedelivery(shippingOrder: ShippingOrder): Promise<void> {
    // 更新狀態為等待重新配送
    shippingOrder.status = ShippingStatus.WAITING_PICKUP;
    shippingOrder.redeliveryAttempts = (shippingOrder.redeliveryAttempts || 0) + 1;
    shippingOrder.nextDeliveryTime = this.calculateNextDeliveryTime();
    
    await this.shippingOrderRepository.save(shippingOrder);

    // 通知客戶重新配送時間
    await this.notificationService.sendRedeliveryScheduledNotification(shippingOrder);
  }

  // 升級到客服處理
  private async escalateToCustomerService(
    shippingOrder: ShippingOrder,
    exception: LogisticsException
  ): Promise<void> {
    const ticket = await this.customerServiceService.createTicket({
      type: 'logistics_issue',
      priority: 'high',
      orderId: shippingOrder.orderId,
      shippingOrderId: shippingOrder.shippingOrderId,
      title: '物流配送異常',
      description: `物流訂單 ${shippingOrder.merchantTradeNo} 配送失敗: ${exception.message}`,
      assignedTo: 'logistics_team'
    });

    // 發送內部通知
    await this.alertService.sendAlert({
      type: 'logistics_escalation',
      severity: 'high',
      message: `物流異常已升級處理，工單號: ${ticket.ticketId}`,
      data: { shippingOrder, exception, ticket }
    });
  }

  private calculateNextDeliveryTime(): Date {
    // 安排 1-2 工作天後重新配送
    const now = new Date();
    const nextDay = new Date(now.getTime() + 24 * 60 * 60 * 1000);
    
    // 如果是週五或週六，延到週一
    if (nextDay.getDay() === 0 || nextDay.getDay() === 6) {
      nextDay.setDate(nextDay.getDate() + (8 - nextDay.getDay()));
    }
    
    return nextDay;
  }

  private generateNewTradeNo(originalTradeNo: string): string {
    const timestamp = Date.now().toString().slice(-6);
    return `${originalTradeNo.substring(0, 14)}${timestamp}`;
  }
}

interface LogisticsException {
  exceptionId: string;
  shippingOrderId: string;
  type: LogisticsExceptionType;
  operation: string;
  errorCode?: string;
  message: string;
  requestData?: any;
  responseData?: any;
  timestamp: Date;
  retryCount: number;
  resolved: boolean;
}

enum LogisticsExceptionType {
  API_TIMEOUT = 'api_timeout',
  API_ERROR = 'api_error',
  STATUS_SYNC_FAILED = 'status_sync_failed',
  DELIVERY_FAILED = 'delivery_failed',
  STORE_NOT_AVAILABLE = 'store_not_available',
  OVERWEIGHT = 'overweight',
  INVALID_ADDRESS = 'invalid_address',
  PAYMENT_FAILED = 'payment_failed',
  UNKNOWN = 'unknown'
}
```

### 8.2 重試服務
```typescript
class LogisticsRetryService {
  private retryQueue: RetryQueue;

  // 安排重試
  async scheduleRetry(
    shippingOrderId: string,
    operation: string,
    requestData: any,
    maxRetries: number = 3
  ): Promise<void> {
    const retryJob: RetryJob = {
      jobId: generateId(),
      shippingOrderId,
      operation,
      requestData,
      maxRetries,
      currentAttempt: 0,
      nextRetryTime: this.calculateRetryTime(0),
      status: RetryJobStatus.PENDING,
      createdAt: new Date()
    };

    await this.retryJobRepository.save(retryJob);
    await this.retryQueue.add(retryJob);
  }

  // 執行重試
  async executeRetry(jobId: string): Promise<void> {
    const job = await this.retryJobRepository.findById(jobId);
    
    if (!job || job.status !== RetryJobStatus.PENDING) {
      return;
    }

    job.currentAttempt++;
    job.status = RetryJobStatus.RUNNING;
    job.lastAttemptAt = new Date();
    
    await this.retryJobRepository.save(job);

    try {
      // 執行重試操作
      await this.executeOperation(job);
      
      // 重試成功
      job.status = RetryJobStatus.COMPLETED;
      job.completedAt = new Date();
      
      await this.retryJobRepository.save(job);

    } catch (error) {
      job.lastError = error.message;
      
      if (job.currentAttempt >= job.maxRetries) {
        // 達到最大重試次數，標記為失敗
        job.status = RetryJobStatus.FAILED;
        job.failedAt = new Date();
        
        // 升級處理
        await this.escalateFailedRetry(job);
        
      } else {
        // 安排下次重試
        job.nextRetryTime = this.calculateRetryTime(job.currentAttempt);
        job.status = RetryJobStatus.PENDING;
        
        await this.retryQueue.add(job, job.nextRetryTime);
      }
      
      await this.retryJobRepository.save(job);
    }
  }

  // 執行操作
  private async executeOperation(job: RetryJob): Promise<void> {
    switch (job.operation) {
      case 'createLogisticsOrder':
        await this.logisticsManager.createShippingOrder(
          job.requestData.order,
          job.requestData.shippingInfo
        );
        break;
      case 'queryLogisticsInfo':
        await this.trackingService.trackShippingOrder(job.shippingOrderId);
        break;
      case 'cancelLogisticsOrder':
        await this.logisticsManager.cancelShippingOrder(
          job.shippingOrderId,
          job.requestData.reason
        );
        break;
      default:
        throw new Error(`不支援的重試操作: ${job.operation}`);
    }
  }

  // 計算重試時間（指數退避）
  private calculateRetryTime(attemptNumber: number): Date {
    const baseDelayMs = 60000; // 1 分鐘
    const maxDelayMs = 1800000; // 30 分鐘
    const delayMs = Math.min(baseDelayMs * Math.pow(2, attemptNumber), maxDelayMs);
    
    return new Date(Date.now() + delayMs);
  }

  // 升級失敗的重試
  private async escalateFailedRetry(job: RetryJob): Promise<void> {
    await this.alertService.sendAlert({
      type: 'retry_failed',
      severity: 'high',
      message: `物流操作重試失敗: ${job.operation}`,
      data: {
        jobId: job.jobId,
        shippingOrderId: job.shippingOrderId,
        operation: job.operation,
        attempts: job.currentAttempt,
        lastError: job.lastError
      }
    });

    // 建立客服工單
    await this.customerServiceService.createTicket({
      type: 'logistics_retry_failed',
      priority: 'high',
      title: '物流操作重試失敗',
      description: `物流操作 ${job.operation} 重試 ${job.currentAttempt} 次仍失敗，需要人工處理`,
      data: job
    });
  }
}

interface RetryJob {
  jobId: string;
  shippingOrderId: string;
  operation: string;
  requestData: any;
  maxRetries: number;
  currentAttempt: number;
  nextRetryTime: Date;
  status: RetryJobStatus;
  lastError?: string;
  createdAt: Date;
  lastAttemptAt?: Date;
  completedAt?: Date;
  failedAt?: Date;
}

enum RetryJobStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}
```

## 9. API 介面設計

### 9.1 物流管理 API
```typescript
// 建立物流訂單
// POST /api/logistics/shipping-orders
interface CreateShippingOrderRequest {
  orderId: string;
  shippingInfo: {
    logisticsType: LogisticsType;
    logisticsSubType: string;
    paymentMethod: 'online' | 'cod';
    receiverInfo: ReceiverInfo;
    storeInfo?: StoreInfo;
    scheduledDeliveryTime?: ScheduledTime;
    notes?: string;
  };
}

interface CreateShippingOrderResponse {
  shippingOrderId: string;
  merchantTradeNo: string;
  status: ShippingStatus;
  estimatedDeliveryTime?: Date;
}

// 取消物流訂單
// POST /api/logistics/shipping-orders/:id/cancel
interface CancelShippingOrderRequest {
  reason: string;
}

// 查詢物流狀態
// GET /api/logistics/shipping-orders/:id/tracking
interface TrackingResponse {
  trackingInfo: TrackingInfo;
}

// 批次更新物流狀態
// POST /api/logistics/batch-update-status
interface BatchUpdateStatusResponse {
  result: BatchUpdateResult;
}
```

### 9.2 超商門市 API
```typescript
// 產生超商地圖
// POST /api/logistics/cvs/generate-map
interface GenerateCVSMapRequest {
  cvsType: CVSType;
  isCollection: boolean;
  userAddress?: string;
}

interface GenerateCVSMapResponse {
  mapURL: string;
  mapHTML: string;
  nearbyStores: StoreInfo[];
}

// 處理門市選擇
// POST /api/logistics/cvs/store-selection
interface StoreSelectionRequest extends StoreSelectionData {}

interface StoreSelectionResponse {
  storeInfo: StoreInfo;
  isValid: boolean;
}

// 搜尋附近門市
// GET /api/logistics/cvs/nearby-stores
interface NearbyStoresRequest {
  cvsType: CVSType;
  address: string;
  limit?: number;
}

interface NearbyStoresResponse {
  stores: StoreInfo[];
  total: number;
}
```

### 9.3 退貨物流 API
```typescript
// 建立退貨物流
// POST /api/logistics/return-shipping
interface CreateReturnShippingRequest {
  returnOrderId: string;
}

interface CreateReturnShippingResponse {
  returnShippingId: string;
  merchantTradeNo: string;
  status: ReturnShippingStatus;
  printURL?: string;
}

// 查詢退貨物流狀態
// GET /api/logistics/return-shipping/:id/tracking
interface ReturnTrackingResponse {
  returnShipping: ReturnShippingOrder;
  trackingInfo: TrackingInfo;
}
```

### 9.4 綠界回調 API
```typescript
// 物流狀態通知
// POST /api/logistics/ecpay/logistics-callback
interface ECPayLogisticsCallback {
  MerchantID: string;
  MerchantTradeNo: string;
  RtnCode: string;
  RtnMsg: string;
  AllPayLogisticsID?: string;
  LogisticsType?: string;
  LogisticsSubType?: string;
  GoodsAmount?: number;
  UpdateStatusDate?: string;
  ReceiverName?: string;
  ReceiverPhone?: string;
  ReceiverCellPhone?: string;
  ReceiverEmail?: string;
  ReceiverAddress?: string;
  CVSPaymentNo?: string;
  CVSValidationNo?: string;
  BookingNote?: string;
  CheckMacValue: string;
}

// 門市選擇回調
// POST /api/logistics/ecpay/store-callback
interface ECPayStoreCallback extends StoreSelectionData {
  CheckMacValue: string;
}
```

## 10. 資料庫設計

### 10.1 物流訂單表
```sql
-- 物流訂單表
CREATE TABLE shipping_orders (
    shipping_order_id VARCHAR(50) PRIMARY KEY,
    order_id VARCHAR(50) NOT NULL,
    merchant_trade_no VARCHAR(50) NOT NULL UNIQUE,
    ecpay_trade_no VARCHAR(50),
    cvs_merchant_trade_no VARCHAR(50),
    cvs_validation_no VARCHAR(50),
    
    -- 物流資訊
    logistics_type VARCHAR(20) NOT NULL,
    logistics_subtype VARCHAR(20) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'created',
    tracking_number VARCHAR(100),
    
    -- 費用資訊
    shipping_fee DECIMAL(10,2) NOT NULL DEFAULT 0,
    is_collection BOOLEAN DEFAULT FALSE,
    collection_amount DECIMAL(10,2) DEFAULT 0,
    
    -- 寄件人資訊 (JSON)
    sender_info JSON NOT NULL,
    
    -- 收件人資訊 (JSON)
    receiver_info JSON NOT NULL,
    
    -- 超商資訊 (JSON，超商取貨專用)
    store_info JSON,
    
    -- 宅配資訊 (JSON)
    delivery_info JSON,
    
    -- 時間記錄
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    shipped_at DATETIME,
    delivered_at DATETIME,
    cancelled_at DATETIME,
    picked_up_at DATETIME,
    failed_at DATETIME,
    
    -- 重新配送資訊
    redelivery_attempts INT DEFAULT 0,
    next_delivery_time DATETIME,
    
    -- 其他資訊
    notes TEXT,
    cancel_reason VARCHAR(500),
    failure_reason VARCHAR(500),
    return_tracking_number VARCHAR(100),
    
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,
    INDEX idx_merchant_trade_no (merchant_trade_no),
    INDEX idx_ecpay_trade_no (ecpay_trade_no),
    INDEX idx_status (status),
    INDEX idx_tracking_number (tracking_number),
    INDEX idx_created_at (created_at)
);

-- 物流狀態歷史表
CREATE TABLE shipping_status_logs (
    log_id VARCHAR(50) PRIMARY KEY,
    shipping_order_id VARCHAR(50) NOT NULL,
    from_status VARCHAR(50),
    to_status VARCHAR(50) NOT NULL,
    changed_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    source VARCHAR(20) NOT NULL, -- 'ecpay_sync', 'manual', 'system'
    raw_data JSON,
    notes TEXT,
    
    FOREIGN KEY (shipping_order_id) REFERENCES shipping_orders(shipping_order_id) ON DELETE CASCADE,
    INDEX idx_shipping_order_id (shipping_order_id),
    INDEX idx_changed_at (changed_at),
    INDEX idx_source (source)
);
```

### 10.2 運費設定表
```sql
-- 運費設定表
CREATE TABLE shipping_rates (
    rate_id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    logistics_type VARCHAR(20) NOT NULL,
    logistics_subtype VARCHAR(20) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    
    -- 基本費用
    base_fee DECIMAL(10,2) NOT NULL,
    
    -- 重量限制
    max_weight INT, -- 公克
    free_weight_limit INT DEFAULT 0,
    weight_unit INT DEFAULT 100, -- 計費重量單位
    extra_weight_fee DECIMAL(10,2) DEFAULT 0,
    
    -- 尺寸限制
    max_dimension INT, -- 公分
    size_upcharge DECIMAL(10,2),
    
    -- 特殊條件
    supports_cod BOOLEAN DEFAULT FALSE,
    supports_cold BOOLEAN DEFAULT FALSE,
    min_amount DECIMAL(10,2),
    max_amount DECIMAL(10,2),
    
    -- 地區設定 (JSON)
    available_areas JSON,
    excluded_areas JSON,
    
    -- 溫層設定
    temperature VARCHAR(20), -- 'room', 'refrigerated', 'frozen'
    distance VARCHAR(20), -- 'same_county', 'other_county', 'remote_area'
    
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_logistics_type (logistics_type, logistics_subtype),
    INDEX idx_is_active (is_active)
);
```

### 10.3 門市資訊表
```sql
-- 超商門市表
CREATE TABLE cvs_stores (
    store_id VARCHAR(20) NOT NULL,
    cvs_type VARCHAR(20) NOT NULL,
    store_name VARCHAR(200) NOT NULL,
    store_address VARCHAR(500) NOT NULL,
    store_telephone VARCHAR(50),
    
    -- 地址解析
    zip_code VARCHAR(10),
    city VARCHAR(50),
    district VARCHAR(50),
    
    -- 營業資訊
    business_hours VARCHAR(100),
    status VARCHAR(20) DEFAULT 'open', -- 'open', 'closed', 'temporarily_closed'
    support_pickup BOOLEAN DEFAULT TRUE,
    support_cod BOOLEAN DEFAULT TRUE,
    
    -- 地理資訊
    latitude DECIMAL(10,8),
    longitude DECIMAL(11,8),
    
    -- 統計資訊
    usage_count INT DEFAULT 0,
    last_used_at DATETIME,
    
    -- 時間資訊
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    PRIMARY KEY (store_id, cvs_type),
    INDEX idx_cvs_type (cvs_type),
    INDEX idx_status (status),
    INDEX idx_city_district (city, district),
    INDEX idx_location (latitude, longitude),
    INDEX idx_usage_count (usage_count)
);
```

### 10.4 退貨物流表
```sql
-- 退貨物流訂單表
CREATE TABLE return_shipping_orders (
    return_shipping_id VARCHAR(50) PRIMARY KEY,
    return_order_id VARCHAR(50) NOT NULL,
    original_shipping_order_id VARCHAR(50) NOT NULL,
    merchant_trade_no VARCHAR(50) NOT NULL UNIQUE,
    ecpay_trade_no VARCHAR(50),
    tracking_number VARCHAR(100),
    
    -- 物流資訊
    logistics_type VARCHAR(20) NOT NULL,
    logistics_subtype VARCHAR(20) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'created',
    
    -- 客戶資訊 (JSON)
    customer_info JSON NOT NULL,
    
    -- 門市資訊 (JSON，超商退貨專用)
    return_store_info JSON,
    
    -- 公司地址（宅配退貨專用）
    company_address VARCHAR(500),
    
    -- 時間記錄
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    picked_up_at DATETIME,
    delivered_at DATETIME,
    
    -- 其他資訊
    notes TEXT,
    
    FOREIGN KEY (return_order_id) REFERENCES return_orders(return_order_id) ON DELETE CASCADE,
    FOREIGN KEY (original_shipping_order_id) REFERENCES shipping_orders(shipping_order_id),
    INDEX idx_return_order_id (return_order_id),
    INDEX idx_original_shipping (original_shipping_order_id),
    INDEX idx_merchant_trade_no (merchant_trade_no),
    INDEX idx_status (status)
);
```

### 10.5 重試任務表
```sql
-- 重試任務表
CREATE TABLE retry_jobs (
    job_id VARCHAR(50) PRIMARY KEY,
    shipping_order_id VARCHAR(50) NOT NULL,
    operation VARCHAR(50) NOT NULL,
    request_data JSON NOT NULL,
    max_retries INT NOT NULL DEFAULT 3,
    current_attempt INT DEFAULT 0,
    next_retry_time DATETIME NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    last_error TEXT,
    
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_attempt_at DATETIME,
    completed_at DATETIME,
    failed_at DATETIME,
    
    FOREIGN KEY (shipping_order_id) REFERENCES shipping_orders(shipping_order_id) ON DELETE CASCADE,
    INDEX idx_status (status),
    INDEX idx_next_retry_time (next_retry_time),
    INDEX idx_operation (operation)
);
```

## 11. 監控與告警

### 11.1 物流監控服務
```typescript
class LogisticsMonitoringService {
  // 監控物流 API 健康狀態
  async monitorAPIHealth(): Promise<void> {
    const healthChecks = [
      this.checkECPayAPIHealth(),
      this.checkDatabaseHealth(),
      this.checkCacheHealth()
    ];

    const results = await Promise.allSettled(healthChecks);
    
    results.forEach((result, index) => {
      if (result.status === 'rejected') {
        this.handleHealthCheckFailure(index, result.reason);
      }
    });
  }

  // 監控物流效能指標
  async monitorPerformanceMetrics(): Promise<void> {
    const metrics = await this.collectMetrics();

    // 檢查 API 響應時間
    if (metrics.averageApiResponseTime > 5000) { // 5秒
      await this.sendAlert({
        type: 'slow_api_response',
        severity: 'warning',
        message: `物流 API 平均響應時間: ${metrics.averageApiResponseTime}ms`
      });
    }

    // 檢查物流訂單建立失敗率
    if (metrics.orderCreationFailureRate > 0.05) { // 5%
      await this.sendAlert({
        type: 'high_failure_rate',
        severity: 'critical',
        message: `物流訂單建立失敗率: ${metrics.orderCreationFailureRate * 100}%`
      });
    }

    // 檢查配送延遲率
    if (metrics.deliveryDelayRate > 0.1) { // 10%
      await this.sendAlert({
        type: 'high_delay_rate',
        severity: 'high',
        message: `配送延遲率: ${metrics.deliveryDelayRate * 100}%`
      });
    }
  }

  // 監控異常情況
  async monitorExceptions(): Promise<void> {
    const recentExceptions = await this.getRecentExceptions(24); // 最近24小時
    
    // 檢查異常數量
    if (recentExceptions.length > 50) {
      await this.sendAlert({
        type: 'high_exception_count',
        severity: 'high',
        message: `24小時內物流異常: ${recentExceptions.length} 次`
      });
    }

    // 檢查重複異常模式
    const exceptionPatterns = this.analyzeExceptionPatterns(recentExceptions);
    for (const pattern of exceptionPatterns) {
      if (pattern.count > 10) {
        await this.sendAlert({
          type: 'recurring_exception',
          severity: 'medium',
          message: `重複異常模式: ${pattern.type} (${pattern.count} 次)`
        });
      }
    }
  }

  private async collectMetrics(): Promise<LogisticsMetrics> {
    const endTime = new Date();
    const startTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000); // 24小時

    return {
      averageApiResponseTime: await this.calculateAverageApiResponseTime(startTime, endTime),
      orderCreationFailureRate: await this.calculateOrderCreationFailureRate(startTime, endTime),
      deliveryDelayRate: await this.calculateDeliveryDelayRate(startTime, endTime),
      activeOrdersCount: await this.getActiveOrdersCount(),
      pendingRetriesCount: await this.getPendingRetriesCount()
    };
  }
}

interface LogisticsMetrics {
  averageApiResponseTime: number; // 毫秒
  orderCreationFailureRate: number; // 0-1
  deliveryDelayRate: number; // 0-1
  activeOrdersCount: number;
  pendingRetriesCount: number;
}
```

綠界物流整合架構提供了完整的電商物流解決方案，支援多種配送方式、即時狀態追蹤、異常處理和退貨逆物流，確保 MickeyShop Beauty 能夠提供優質的物流服務體驗。

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "設計系統設定模組功能規格", "status": "completed", "activeForm": "設計系統設定模組功能規格"}, {"content": "設計完整的单據流程", "status": "completed", "activeForm": "設計完整的单據流程"}, {"content": "設計綠界物流整合架構", "status": "completed", "activeForm": "設計綠界物流整合架構"}, {"content": "完善前台與後台API整合規格", "status": "in_progress", "activeForm": "完善前台與後台API整合規格"}, {"content": "確認架構設計完整性", "status": "pending", "activeForm": "確認架構設計完整性"}]