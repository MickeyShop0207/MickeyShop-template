# 模組 18: 採購管理模組 (Procurement Management Module)

## 模組概述

採購管理模組負責從庫存警報到商品入庫的完整採購生命週期管理。整合供應商管理、通知管理、會計管理等模組，提供自動化的補貨提醒、智能採購建議、多類型採購單管理、履約追蹤，以及完整的成本控制與財務整合功能。

## 核心功能架構

### 1. 採購流程管理

#### 1.1 採購流程狀態定義
```typescript
enum PurchaseOrderStatus {
  DRAFT = 'draft',                     // 草稿
  PENDING_APPROVAL = 'pending_approval', // 待審核
  APPROVED = 'approved',               // 已審核
  SENT_TO_SUPPLIER = 'sent_to_supplier', // 已發送供應商
  CONFIRMED = 'confirmed',             // 供應商確認
  IN_PRODUCTION = 'in_production',     // 生產中
  SHIPPED = 'shipped',                 // 已出貨
  DELIVERED = 'delivered',             // 已到貨
  UNDER_INSPECTION = 'under_inspection', // 驗收中
  RECEIVED = 'received',               // 已驗收
  PARTIALLY_RECEIVED = 'partially_received', // 部分驗收
  CANCELLED = 'cancelled',             // 已取消
  REJECTED = 'rejected'                // 已拒絕
}

interface PurchaseOrderWorkflow {
  currentStatus: PurchaseOrderStatus
  statusHistory: StatusHistoryEntry[]
  nextPossibleStatuses: PurchaseOrderStatus[]
  requiredActions: WorkflowAction[]
  assignedTo?: string
  dueDate?: Date
}

interface StatusHistoryEntry {
  status: PurchaseOrderStatus
  timestamp: Date
  changedBy: string
  notes?: string
  attachments?: string[]
}

interface WorkflowAction {
  action: 'approve' | 'reject' | 'modify' | 'send' | 'receive' | 'inspect'
  description: string
  requiredRole: string[]
  isRequired: boolean
}
```

#### 1.2 自動化流程引擎
```typescript
class PurchaseOrderWorkflowEngine {
  // 庫存觸發採購流程
  async triggerPurchaseFromInventory(inventoryAlert: InventoryAlert): Promise<void> {
    // 1. 發送LINE通知給管理員
    await this.notificationService.sendLineNotification({
      templateId: 'inventory_low_stock_alert',
      recipients: await this.getInventoryManagers(),
      variables: {
        'product.name': inventoryAlert.productName,
        'product.currentStock': inventoryAlert.currentStock,
        'product.safetyStock': inventoryAlert.safetyStockLevel,
        'supplier.recommended': await this.getRecommendedSupplier(inventoryAlert.productId)
      }
    })

    // 2. 建立採購建議
    const purchaseSuggestion = await this.generatePurchaseSuggestion(inventoryAlert)
    
    // 3. 記錄觸發歷程
    await this.logPurchaseTrigger(inventoryAlert, purchaseSuggestion)
  }

  // 採購單狀態自動轉換
  async transitionStatus(
    purchaseOrderId: string, 
    newStatus: PurchaseOrderStatus,
    context: StatusTransitionContext
  ): Promise<void> {
    const purchaseOrder = await this.purchaseOrderRepository.findById(purchaseOrderId)
    
    // 驗證狀態轉換的有效性
    await this.validateStatusTransition(purchaseOrder.status, newStatus)
    
    // 執行狀態前置操作
    await this.executePreStatusActions(purchaseOrder, newStatus, context)
    
    // 更新狀態
    await this.updatePurchaseOrderStatus(purchaseOrderId, newStatus, context)
    
    // 執行狀態後置操作
    await this.executePostStatusActions(purchaseOrder, newStatus, context)
    
    // 自動觸發下一階段
    await this.triggerNextStageIfApplicable(purchaseOrderId, newStatus)
  }

  // 自動審核到訂單追蹤
  private async executePostStatusActions(
    purchaseOrder: PurchaseOrder,
    newStatus: PurchaseOrderStatus,
    context: StatusTransitionContext
  ): Promise<void> {
    switch (newStatus) {
      case PurchaseOrderStatus.APPROVED:
        // 自動轉到訂單追蹤
        await this.scheduleOrderTracking(purchaseOrder)
        break
        
      case PurchaseOrderStatus.DELIVERED:
        // 自動轉到驗收入庫
        await this.initiateInspectionProcess(purchaseOrder)
        break
        
      case PurchaseOrderStatus.RECEIVED:
        // 自動更新庫存
        await this.updateInventoryFromReceipt(purchaseOrder)
        break
    }
  }
}
```

### 2. 採購單類型管理

#### 2.1 採購單類型定義
```typescript
enum PurchaseOrderType {
  PRODUCT_PROCUREMENT = 'product_procurement',     // 商品採購
  GIFT_PROCUREMENT = 'gift_procurement',           // 贈品採購
  EMERGENCY_PROCUREMENT = 'emergency_procurement', // 緊急採購
  CAMPAIGN_PROCUREMENT = 'campaign_procurement'    // 活動採購
}

interface PurchaseOrder {
  id: string
  orderNumber: string
  type: PurchaseOrderType
  supplierId: string
  supplierName: string
  status: PurchaseOrderStatus
  priority: PurchasePriority
  items: PurchaseOrderItem[]
  
  // 財務資訊
  subtotal: number
  shippingCost: number
  taxAmount: number
  exchangeFee?: number            // 匯費
  creditCardFee?: number          // 刷卡手續費
  totalAmount: number
  currency: string
  
  // 付款資訊
  paymentMethod: string
  paymentAccountingSubject: string // 會計科目
  paymentTerms: string
  paymentDueDate: Date
  
  // 交期資訊
  expectedDeliveryDate: Date
  actualDeliveryDate?: Date
  leadTimeDays: number
  
  // 其他資訊
  notes?: string
  attachments: PurchaseAttachment[]
  createdBy: string
  approvedBy?: string
  createdAt: Date
  updatedAt: Date
}

interface PurchaseOrderItem {
  id: string
  productId?: string              // 商品採購
  giftId?: string                 // 贈品採購
  itemName: string
  itemCode: string
  specification?: string
  quantity: number
  unitPrice: number
  subtotal: number
  deliveryDate?: Date
  notes?: string
}

enum PurchasePriority {
  LOW = 'low',
  NORMAL = 'normal', 
  HIGH = 'high',
  URGENT = 'urgent'
}
```

#### 2.2 採購類型管理器
```typescript
class PurchaseTypeManager {
  // 商品採購處理
  async createProductProcurement(request: ProductProcurementRequest): Promise<PurchaseOrder> {
    const suppliers = await this.supplierService.getProductSuppliers(request.productId)
    const bestSupplier = await this.selectBestSupplier(suppliers, request.criteria)
    
    return await this.createPurchaseOrder({
      type: PurchaseOrderType.PRODUCT_PROCUREMENT,
      supplierId: bestSupplier.id,
      items: [{
        productId: request.productId,
        itemName: request.productName,
        itemCode: request.productSku,
        quantity: request.quantity,
        unitPrice: bestSupplier.price
      }],
      priority: this.calculatePriority(request),
      expectedDeliveryDate: this.calculateDeliveryDate(bestSupplier.leadTimeDays)
    })
  }

  // 贈品採購處理
  async createGiftProcurement(request: GiftProcurementRequest): Promise<PurchaseOrder> {
    const suppliers = await this.supplierService.getGiftSuppliers(request.giftId)
    const selectedSupplier = await this.selectGiftSupplier(suppliers, request)
    
    return await this.createPurchaseOrder({
      type: PurchaseOrderType.GIFT_PROCUREMENT,
      supplierId: selectedSupplier.id,
      items: [{
        giftId: request.giftId,
        itemName: request.giftName,
        quantity: request.quantity,
        unitPrice: selectedSupplier.cost,
        specification: request.customization,
        deliveryDate: request.requiredDate
      }],
      priority: PurchasePriority.HIGH, // 贈品通常較急
      expectedDeliveryDate: request.requiredDate
    })
  }

  // 緊急採購處理
  async createEmergencyProcurement(request: EmergencyProcurementRequest): Promise<PurchaseOrder> {
    const suppliers = await this.supplierService.findEmergencyCapableSuppliers(request.productId)
    
    if (suppliers.length === 0) {
      throw new Error('No suppliers available for emergency procurement')
    }
    
    const fastestSupplier = suppliers.sort((a, b) => a.leadTimeDays - b.leadTimeDays)[0]
    
    return await this.createPurchaseOrder({
      type: PurchaseOrderType.EMERGENCY_PROCUREMENT,
      supplierId: fastestSupplier.id,
      items: request.items,
      priority: PurchasePriority.URGENT,
      expectedDeliveryDate: this.calculateEmergencyDeliveryDate(fastestSupplier.leadTimeDays),
      notes: `緊急採購原因: ${request.reason}`
    })
  }

  // 活動採購處理
  async createCampaignProcurement(request: CampaignProcurementRequest): Promise<PurchaseOrder> {
    const campaign = await this.campaignService.findById(request.campaignId)
    const suppliers = await this.findCampaignSuppliers(request.items, campaign)
    
    const purchaseOrders: PurchaseOrder[] = []
    
    // 可能需要多個供應商
    for (const supplierGroup of this.groupItemsBySupplier(request.items, suppliers)) {
      const po = await this.createPurchaseOrder({
        type: PurchaseOrderType.CAMPAIGN_PROCUREMENT,
        supplierId: supplierGroup.supplierId,
        items: supplierGroup.items,
        priority: PurchasePriority.HIGH,
        expectedDeliveryDate: this.calculateCampaignDeliveryDate(campaign.startDate),
        notes: `活動採購: ${campaign.name}`
      })
      purchaseOrders.push(po)
    }
    
    return purchaseOrders[0] // 返回第一個，實際可能返回數組
  }
}
```

### 3. 供應商整合與比價系統

#### 3.1 供應商選擇引擎
```typescript
class SupplierSelectionEngine {
  // 根據商品關聯供應商
  async getProductSuppliers(productId: string): Promise<SupplierOption[]> {
    const supplierProducts = await this.supplierProductRepository.findByProductId(productId)
    
    return Promise.all(supplierProducts.map(async (sp) => {
      const supplier = await this.supplierRepository.findById(sp.supplierId)
      const performance = await this.supplierPerformanceService.getMetrics(sp.supplierId)
      
      return {
        supplierId: supplier.id,
        supplierName: supplier.companyName,
        price: sp.supplierPrice,
        currency: sp.currency,
        minOrderQuantity: sp.minOrderQuantity,
        leadTimeDays: sp.leadTimeDays,
        availability: sp.availability,
        
        // 績效指標
        onTimeDeliveryRate: performance.onTimeDeliveryRate,
        qualityRating: performance.qualityRating,
        serviceRating: performance.serviceRating,
        
        // 總體評分
        overallScore: this.calculateSupplierScore(sp, performance),
        
        // 付款方式
        paymentMethods: await this.getSupplierPaymentMethods(supplier.id),
        paymentTerms: await this.getSupplierPaymentTerms(supplier.id)
      }
    }))
  }

  // 多供應商價格對比
  async compareSupplierPrices(
    productId: string,
    quantity: number,
    requirements: ProcurementRequirements
  ): Promise<SupplierComparison> {
    
    const suppliers = await this.getProductSuppliers(productId)
    const comparisons: SupplierComparisonItem[] = []
    
    for (const supplier of suppliers) {
      // 計算總成本
      const unitPrice = supplier.price
      const subtotal = unitPrice * quantity
      const shippingCost = await this.calculateShippingCost(supplier.supplierId, quantity)
      const taxAmount = this.calculateTax(subtotal, supplier.supplierId)
      
      // 額外費用計算
      const additionalFees = await this.calculateAdditionalFees(
        supplier.supplierId,
        subtotal,
        requirements.paymentMethod
      )
      
      const totalCost = subtotal + shippingCost + taxAmount + additionalFees.total
      
      comparisons.push({
        supplier,
        pricing: {
          unitPrice,
          subtotal,
          shippingCost,
          taxAmount,
          exchangeFee: additionalFees.exchangeFee,
          creditCardFee: additionalFees.creditCardFee,
          totalCost
        },
        delivery: {
          leadTimeDays: supplier.leadTimeDays,
          estimatedDeliveryDate: this.calculateDeliveryDate(supplier.leadTimeDays)
        },
        quality: {
          rating: supplier.qualityRating,
          onTimeRate: supplier.onTimeDeliveryRate
        },
        recommendation: this.generateRecommendation(supplier, totalCost, requirements)
      })
    }
    
    return {
      productId,
      quantity,
      comparisons: comparisons.sort((a, b) => b.supplier.overallScore - a.supplier.overallScore),
      bestValue: this.findBestValueSupplier(comparisons),
      fastestDelivery: this.findFastestSupplier(comparisons),
      lowestCost: this.findLowestCostSupplier(comparisons)
    }
  }

  // 計算額外費用
  private async calculateAdditionalFees(
    supplierId: string,
    amount: number,
    paymentMethod: string
  ): Promise<AdditionalFees> {
    
    const fees: AdditionalFees = {
      exchangeFee: 0,
      creditCardFee: 0,
      total: 0
    }
    
    // 匯費計算
    const supplier = await this.supplierRepository.findById(supplierId)
    if (supplier.currency !== 'TWD') {
      fees.exchangeFee = amount * 0.001 // 0.1% 匯費
    }
    
    // 信用卡手續費
    if (paymentMethod === 'credit_card') {
      fees.creditCardFee = amount * 0.025 // 2.5% 刷卡手續費
    }
    
    fees.total = fees.exchangeFee + fees.creditCardFee
    
    return fees
  }
}

interface AdditionalFees {
  exchangeFee: number      // 匯費
  creditCardFee: number    // 刷卡手續費
  total: number
}
```

### 4. 會計科目整合付款系統

#### 4.1 會計科目管理
```typescript
interface AccountingSubject {
  id: string
  code: string                    // 會計科目代碼
  name: string                    // 會計科目名稱
  category: AccountingCategory
  subcategory?: string
  paymentMethods: PaymentMethodConfig[]
  isActive: boolean
  description?: string
  createdAt: Date
  updatedAt: Date
}

enum AccountingCategory {
  CASH = 'cash',                  // 現金
  BANK_ACCOUNT = 'bank_account',  // 銀行存款
  ACCOUNTS_PAYABLE = 'accounts_payable', // 應付帳款
  CREDIT_CARD = 'credit_card',    // 信用卡
  PETTY_CASH = 'petty_cash',      // 零用金
  OTHER_PAYABLES = 'other_payables' // 其他應付款
}

interface PaymentMethodConfig {
  method: PaymentMethod
  accountingSubjectId: string
  isPreferred: boolean
  limits?: PaymentLimits
  fees?: FeeStructure
}

enum PaymentMethod {
  BANK_TRANSFER = 'bank_transfer',
  CREDIT_CARD = 'credit_card',
  CHECK = 'check',
  CASH = 'cash',
  WIRE_TRANSFER = 'wire_transfer'
}
```

#### 4.2 付款方式選擇系統
```typescript
class PurchasePaymentManager {
  // 取得可用付款方式
  async getAvailablePaymentMethods(
    supplierId: string,
    amount: number,
    currency: string
  ): Promise<PaymentOption[]> {
    
    const supplierPaymentMethods = await this.supplierService.getPaymentMethods(supplierId)
    const accountingSubjects = await this.accountingService.getActiveSubjects()
    
    const paymentOptions: PaymentOption[] = []
    
    for (const supplierMethod of supplierPaymentMethods) {
      // 找到對應的會計科目
      const matchingSubjects = accountingSubjects.filter(subject => 
        subject.paymentMethods.some(pm => pm.method === supplierMethod.paymentType)
      )
      
      for (const subject of matchingSubjects) {
        const paymentConfig = subject.paymentMethods.find(pm => pm.method === supplierMethod.paymentType)
        
        // 檢查限額
        if (this.checkPaymentLimits(paymentConfig, amount)) {
          const fees = await this.calculatePaymentFees(supplierMethod.paymentType, amount, currency)
          
          paymentOptions.push({
            paymentMethod: supplierMethod.paymentType,
            paymentMethodName: this.getPaymentMethodName(supplierMethod.paymentType),
            accountingSubject: {
              id: subject.id,
              code: subject.code,
              name: subject.name
            },
            fees: fees,
            totalCost: amount + fees.total,
            processingTime: this.getProcessingTime(supplierMethod.paymentType),
            isRecommended: paymentConfig.isPreferred,
            limitations: paymentConfig.limits
          })
        }
      }
    }
    
    return paymentOptions.sort((a, b) => {
      if (a.isRecommended && !b.isRecommended) return -1
      if (!a.isRecommended && b.isRecommended) return 1
      return a.totalCost - b.totalCost
    })
  }

  // 處理採購付款
  async processPurchasePayment(
    purchaseOrderId: string,
    paymentMethodId: string,
    accountingSubjectId: string
  ): Promise<PaymentResult> {
    
    const purchaseOrder = await this.purchaseOrderRepository.findById(purchaseOrderId)
    const paymentMethod = await this.supplierPaymentRepository.findById(paymentMethodId)
    const accountingSubject = await this.accountingSubjectRepository.findById(accountingSubjectId)
    
    try {
      // 執行付款
      const paymentResult = await this.executePayment(purchaseOrder, paymentMethod, accountingSubject)
      
      // 記錄會計分錄
      await this.recordAccountingEntry(purchaseOrder, paymentResult, accountingSubject)
      
      // 更新採購單狀態
      await this.updatePurchaseOrderPaymentStatus(purchaseOrderId, paymentResult)
      
      // 更新應付帳款
      await this.updateAccountsPayable(purchaseOrder, paymentResult)
      
      return paymentResult
      
    } catch (error) {
      await this.logPaymentError(purchaseOrderId, error)
      throw error
    }
  }

  // 記錄會計分錄
  private async recordAccountingEntry(
    purchaseOrder: PurchaseOrder,
    paymentResult: PaymentResult,
    accountingSubject: AccountingSubject
  ): Promise<void> {
    
    const entries: AccountingEntry[] = []
    
    // 借方：庫存商品/費用
    entries.push({
      account: this.getInventoryAccount(purchaseOrder.type),
      debitAmount: purchaseOrder.subtotal,
      creditAmount: 0,
      description: `採購: ${purchaseOrder.orderNumber}`,
      reference: purchaseOrder.id
    })
    
    // 借方：運費
    if (purchaseOrder.shippingCost > 0) {
      entries.push({
        account: 'SHIPPING_EXPENSE',
        debitAmount: purchaseOrder.shippingCost,
        creditAmount: 0,
        description: `採購運費: ${purchaseOrder.orderNumber}`,
        reference: purchaseOrder.id
      })
    }
    
    // 借方：稅費
    if (purchaseOrder.taxAmount > 0) {
      entries.push({
        account: 'TAX_EXPENSE',
        debitAmount: purchaseOrder.taxAmount,
        creditAmount: 0,
        description: `採購稅費: ${purchaseOrder.orderNumber}`,
        reference: purchaseOrder.id
      })
    }
    
    // 貸方：付款帳戶
    entries.push({
      account: accountingSubject.code,
      debitAmount: 0,
      creditAmount: purchaseOrder.totalAmount,
      description: `付款: ${purchaseOrder.orderNumber}`,
      reference: purchaseOrder.id
    })
    
    await this.accountingService.createJournalEntry({
      date: new Date(),
      description: `採購付款: ${purchaseOrder.orderNumber}`,
      entries: entries,
      reference: purchaseOrder.id,
      createdBy: paymentResult.processedBy
    })
  }
}

interface PaymentOption {
  paymentMethod: PaymentMethod
  paymentMethodName: string
  accountingSubject: {
    id: string
    code: string
    name: string
  }
  fees: PaymentFees
  totalCost: number
  processingTime: string
  isRecommended: boolean
  limitations?: PaymentLimits
}

interface PaymentFees {
  processingFee: number
  exchangeFee: number
  creditCardFee: number
  total: number
}
```

### 5. 智能補貨與季節性採購

#### 5.1 智能採購建議引擎
```typescript
class SmartProcurementEngine {
  // 生成採購建議
  async generatePurchaseSuggestion(productId: string): Promise<PurchaseSuggestion> {
    const product = await this.productService.findById(productId)
    const inventory = await this.inventoryService.getProductInventory(productId)
    const salesHistory = await this.salesService.getSalesHistory(productId, 90) // 90天銷售記錄
    const seasonalData = await this.getSeasonalData(productId)
    const upcomingCampaigns = await this.campaignService.getUpcomingCampaigns(productId)
    
    // 需求預測
    const demandForecast = await this.calculateDemandForecast(
      salesHistory,
      seasonalData,
      upcomingCampaigns
    )
    
    // 最佳訂購量計算
    const optimalQuantity = await this.calculateOptimalOrderQuantity(
      product,
      inventory,
      demandForecast
    )
    
    // 供應商建議
    const supplierRecommendation = await this.recommendSupplier(productId, optimalQuantity)
    
    return {
      productId,
      productName: product.name,
      currentStock: inventory.availableQuantity,
      safetyStock: inventory.safetyStockLevel,
      forecastedDemand: demandForecast,
      recommendedQuantity: optimalQuantity.quantity,
      recommendedSupplier: supplierRecommendation,
      urgencyLevel: this.calculateUrgencyLevel(inventory, demandForecast),
      seasonalFactors: seasonalData.factors,
      campaignImpact: upcomingCampaigns.map(c => ({
        campaignName: c.name,
        startDate: c.startDate,
        expectedDemandIncrease: c.expectedDemandMultiplier
      })),
      costAnalysis: {
        estimatedCost: optimalQuantity.quantity * supplierRecommendation.price,
        costPerUnit: supplierRecommendation.price,
        potentialSavings: await this.calculatePotentialSavings(optimalQuantity, supplierRecommendation)
      },
      timing: {
        recommendedOrderDate: this.calculateOptimalOrderDate(
          supplierRecommendation.leadTimeDays,
          demandForecast.stockoutDate
        ),
        expectedDeliveryDate: this.addDays(new Date(), supplierRecommendation.leadTimeDays),
        criticalDate: demandForecast.stockoutDate
      }
    }
  }

  // 季節性採購規劃
  async planSeasonalProcurement(
    season: Season,
    planningHorizon: number = 120 // 120天前開始規劃
  ): Promise<SeasonalProcurementPlan> {
    
    const seasonalProducts = await this.getSeasonalProducts(season)
    const historicalData = await this.getHistoricalSeasonalData(season)
    
    const procurementPlans: SeasonalProductPlan[] = []
    
    for (const product of seasonalProducts) {
      const historicalDemand = historicalData.find(h => h.productId === product.id)
      const currentInventory = await this.inventoryService.getProductInventory(product.id)
      
      // 預測季節需求
      const seasonalDemand = this.forecastSeasonalDemand(historicalDemand, season)
      
      // 計算需要採購的數量
      const requiredQuantity = Math.max(0, seasonalDemand.totalDemand - currentInventory.availableQuantity)
      
      if (requiredQuantity > 0) {
        const supplier = await this.supplierService.getMainSupplier(product.id)
        const leadTime = supplier.leadTimeDays
        
        procurementPlans.push({
          productId: product.id,
          productName: product.name,
          season: season,
          forecastedDemand: seasonalDemand.totalDemand,
          currentStock: currentInventory.availableQuantity,
          requiredQuantity: requiredQuantity,
          recommendedOrderDate: this.calculateSeasonalOrderDate(season.startDate, leadTime, planningHorizon),
          supplier: supplier,
          estimatedCost: requiredQuantity * supplier.price,
          riskFactors: this.assessSeasonalRisks(product, season, historicalDemand)
        })
      }
    }
    
    return {
      season: season,
      planningDate: new Date(),
      totalProducts: procurementPlans.length,
      totalEstimatedCost: procurementPlans.reduce((sum, plan) => sum + plan.estimatedCost, 0),
      plans: procurementPlans.sort((a, b) => a.recommendedOrderDate.getTime() - b.recommendedOrderDate.getTime()),
      recommendations: this.generateSeasonalRecommendations(procurementPlans)
    }
  }

  // 整合通知管理的補貨提醒
  async integrateRestockNotification(inventoryAlert: InventoryAlert): Promise<void> {
    // 生成採購建議
    const suggestion = await this.generatePurchaseSuggestion(inventoryAlert.productId)
    
    // 發送通知（整合通知管理模組）
    await this.notificationService.triggerNotification('RESTOCK_REQUIRED', {
      productId: inventoryAlert.productId,
      productName: inventoryAlert.productName,
      currentStock: inventoryAlert.currentStock,
      safetyStock: inventoryAlert.safetyStockLevel,
      recommendedQuantity: suggestion.recommendedQuantity,
      recommendedSupplier: suggestion.recommendedSupplier.supplierName,
      urgencyLevel: suggestion.urgencyLevel,
      estimatedCost: suggestion.costAnalysis.estimatedCost,
      recommendedOrderDate: suggestion.timing.recommendedOrderDate
    })
    
    // 記錄補貨建議
    await this.restockSuggestionRepository.create({
      productId: inventoryAlert.productId,
      triggeredBy: 'inventory_alert',
      suggestion: suggestion,
      status: 'pending_action',
      createdAt: new Date()
    })
  }
}

interface PurchaseSuggestion {
  productId: string
  productName: string
  currentStock: number
  safetyStock: number
  forecastedDemand: DemandForecast
  recommendedQuantity: number
  recommendedSupplier: SupplierRecommendation
  urgencyLevel: 'low' | 'medium' | 'high' | 'critical'
  seasonalFactors: SeasonalFactor[]
  campaignImpact: CampaignImpact[]
  costAnalysis: CostAnalysis
  timing: TimingRecommendation
}

interface Season {
  name: string
  startDate: Date
  endDate: Date
  type: 'spring' | 'summer' | 'autumn' | 'winter' | 'festival' | 'holiday'
}
```

### 6. 履約追蹤系統

#### 6.1 供應商履約監控
```typescript
class SupplierPerformanceTracker {
  // 交期追蹤
  async trackDeliveryPerformance(purchaseOrderId: string): Promise<DeliveryTracking> {
    const purchaseOrder = await this.purchaseOrderRepository.findById(purchaseOrderId)
    const supplier = await this.supplierRepository.findById(purchaseOrder.supplierId)
    
    const tracking: DeliveryTracking = {
      purchaseOrderId: purchaseOrder.id,
      supplierId: supplier.id,
      supplierName: supplier.companyName,
      expectedDeliveryDate: purchaseOrder.expectedDeliveryDate,
      actualDeliveryDate: purchaseOrder.actualDeliveryDate,
      deliveryStatus: this.calculateDeliveryStatus(purchaseOrder),
      daysOverdue: this.calculateDaysOverdue(purchaseOrder),
      deliveryHistory: await this.getDeliveryHistory(purchaseOrder.supplierId, 90),
      currentPerformanceMetrics: await this.calculateCurrentMetrics(purchaseOrder.supplierId)
    }
    
    // 如果延遲超過閾值，發送警報
    if (tracking.daysOverdue > 3) {
      await this.sendDelayAlert(tracking)
    }
    
    return tracking
  }

  // 品質表現記錄
  async recordQualityAssessment(
    purchaseOrderId: string,
    qualityAssessment: QualityAssessment
  ): Promise<void> {
    
    const purchaseOrder = await this.purchaseOrderRepository.findById(purchaseOrderId)
    
    // 記錄品質評估
    await this.qualityAssessmentRepository.create({
      purchaseOrderId: purchaseOrder.id,
      supplierId: purchaseOrder.supplierId,
      assessmentDate: new Date(),
      overallRating: qualityAssessment.overallRating,
      qualityMetrics: qualityAssessment.metrics,
      defectCount: qualityAssessment.defectCount,
      defectTypes: qualityAssessment.defectTypes,
      correctionRequired: qualityAssessment.correctionRequired,
      assessorId: qualityAssessment.assessorId,
      notes: qualityAssessment.notes,
      photos: qualityAssessment.photos
    })
    
    // 更新供應商績效評分
    await this.updateSupplierQualityScore(purchaseOrder.supplierId, qualityAssessment)
    
    // 如果品質不合格，觸發處理流程
    if (qualityAssessment.overallRating < 3) {
      await this.handleQualityIssue(purchaseOrder, qualityAssessment)
    }
  }

  // 綜合績效分析
  async generatePerformanceReport(
    supplierId: string,
    period: DateRange
  ): Promise<SupplierPerformanceReport> {
    
    const supplier = await this.supplierRepository.findById(supplierId)
    const purchaseOrders = await this.purchaseOrderRepository.findBySupplierAndPeriod(supplierId, period)
    const qualityAssessments = await this.qualityAssessmentRepository.findBySupplierAndPeriod(supplierId, period)
    
    // 交期績效
    const deliveryMetrics = this.calculateDeliveryMetrics(purchaseOrders)
    
    // 品質績效
    const qualityMetrics = this.calculateQualityMetrics(qualityAssessments)
    
    // 服務績效
    const serviceMetrics = await this.calculateServiceMetrics(supplierId, period)
    
    // 成本績效
    const costMetrics = this.calculateCostMetrics(purchaseOrders)
    
    // 整體評分計算
    const overallScore = this.calculateOverallScore({
      delivery: deliveryMetrics,
      quality: qualityMetrics,
      service: serviceMetrics,
      cost: costMetrics
    })
    
    return {
      supplier: {
        id: supplier.id,
        name: supplier.companyName,
        currentGrade: supplier.currentGrade
      },
      period: period,
      totalOrders: purchaseOrders.length,
      totalAmount: purchaseOrders.reduce((sum, po) => sum + po.totalAmount, 0),
      performanceMetrics: {
        delivery: deliveryMetrics,
        quality: qualityMetrics,
        service: serviceMetrics,
        cost: costMetrics,
        overall: overallScore
      },
      trends: await this.calculatePerformanceTrends(supplierId, period),
      recommendations: this.generatePerformanceRecommendations(overallScore),
      riskAssessment: await this.assessSupplierRisk(supplierId, overallScore)
    }
  }

  // 自動績效評級更新
  async updateSupplierGrade(supplierId: string): Promise<SupplierGradeUpdate> {
    const currentGrade = await this.supplierService.getCurrentGrade(supplierId)
    const performanceReport = await this.generatePerformanceReport(
      supplierId,
      { startDate: this.getDateMonthsAgo(6), endDate: new Date() }
    )
    
    const newGrade = this.calculateNewGrade(performanceReport.performanceMetrics.overall)
    
    if (newGrade !== currentGrade) {
      await this.supplierService.updateGrade(supplierId, newGrade, {
        reason: 'Performance-based automatic update',
        previousGrade: currentGrade,
        performanceScore: performanceReport.performanceMetrics.overall.score,
        updatedBy: 'system',
        updatedAt: new Date()
      })
      
      // 發送等級變更通知
      await this.notificationService.sendSupplierGradeChangeNotification(
        supplierId,
        currentGrade,
        newGrade,
        performanceReport
      )
      
      return {
        supplierId,
        previousGrade: currentGrade,
        newGrade: newGrade,
        performanceScore: performanceReport.performanceMetrics.overall.score,
        changeDate: new Date()
      }
    }
    
    return null
  }
}

interface QualityAssessment {
  overallRating: number // 1-5 星級
  metrics: {
    appearance: number
    functionality: number
    packaging: number
    documentation: number
  }
  defectCount: number
  defectTypes: string[]
  correctionRequired: boolean
  assessorId: string
  notes?: string
  photos?: string[]
}
```

### 7. 驗收入庫系統

#### 7.1 驗收流程管理
```typescript
class InspectionReceiptManager {
  // 驗收入庫流程
  async processInspectionReceipt(
    purchaseOrderId: string,
    inspectionData: InspectionData
  ): Promise<InspectionResult> {
    
    const purchaseOrder = await this.purchaseOrderRepository.findById(purchaseOrderId)
    
    // 1. 數量驗收
    const quantityInspection = await this.inspectQuantity(purchaseOrder.items, inspectionData.receivedItems)
    
    // 2. 品質檢驗
    const qualityInspection = await this.inspectQuality(purchaseOrder.items, inspectionData.qualityChecks)
    
    // 3. 包裝檢驗
    const packagingInspection = await this.inspectPackaging(inspectionData.packagingCondition)
    
    // 4. 文件核對
    const documentInspection = await this.inspectDocuments(purchaseOrder, inspectionData.documents)
    
    const inspectionResult: InspectionResult = {
      purchaseOrderId: purchaseOrder.id,
      inspectionDate: new Date(),
      inspectorId: inspectionData.inspectorId,
      results: {
        quantity: quantityInspection,
        quality: qualityInspection,
        packaging: packagingInspection,
        documentation: documentInspection
      },
      overallStatus: this.calculateOverallStatus([
        quantityInspection.status,
        qualityInspection.status,
        packagingInspection.status,
        documentInspection.status
      ]),
      acceptedItems: [],
      rejectedItems: [],
      notes: inspectionData.notes
    }
    
    // 5. 處理驗收結果
    await this.processInspectionResults(purchaseOrder, inspectionResult)
    
    // 6. 更新庫存（僅接受的商品）
    if (inspectionResult.acceptedItems.length > 0) {
      await this.updateInventory(inspectionResult.acceptedItems)
    }
    
    // 7. 處理退貨（如有）
    if (inspectionResult.rejectedItems.length > 0) {
      await this.processRejectedItems(purchaseOrder, inspectionResult.rejectedItems)
    }
    
    // 8. 記錄供應商品質表現
    await this.recordSupplierQualityPerformance(purchaseOrder.supplierId, inspectionResult)
    
    // 9. 更新採購單狀態
    await this.updatePurchaseOrderStatus(purchaseOrderId, inspectionResult.overallStatus)
    
    return inspectionResult
  }

  // 庫存更新處理
  private async updateInventory(acceptedItems: AcceptedItem[]): Promise<void> {
    for (const item of acceptedItems) {
      if (item.productId) {
        // 商品庫存更新
        await this.inventoryService.receiveStock({
          productId: item.productId,
          quantity: item.acceptedQuantity,
          unitCost: item.unitCost,
          batchNumber: item.batchNumber,
          expiryDate: item.expiryDate,
          receivedDate: new Date(),
          supplierId: item.supplierId,
          purchaseOrderId: item.purchaseOrderId
        })
      } else if (item.giftId) {
        // 贈品庫存更新
        await this.giftInventoryService.receiveGiftStock({
          giftId: item.giftId,
          quantity: item.acceptedQuantity,
          unitCost: item.unitCost,
          receivedDate: new Date(),
          supplierId: item.supplierId,
          purchaseOrderId: item.purchaseOrderId
        })
      }
    }
  }

  // 不合格品處理
  private async processRejectedItems(
    purchaseOrder: PurchaseOrder,
    rejectedItems: RejectedItem[]
  ): Promise<void> {
    
    // 建立退貨單
    const returnOrder = await this.returnOrderService.createReturnOrder({
      purchaseOrderId: purchaseOrder.id,
      supplierId: purchaseOrder.supplierId,
      items: rejectedItems.map(item => ({
        itemId: item.itemId,
        itemName: item.itemName,
        quantity: item.rejectedQuantity,
        reason: item.rejectionReason,
        condition: item.condition
      })),
      returnReason: 'Quality inspection failure',
      requestedAction: 'replacement', // 或 'refund'
      createdBy: rejectedItems[0].inspectorId
    })
    
    // 通知供應商
    await this.notificationService.notifySupplierOfRejection(
      purchaseOrder.supplierId,
      returnOrder,
      rejectedItems
    )
    
    // 記錄品質問題
    await this.qualityIssueService.recordQualityIssue({
      purchaseOrderId: purchaseOrder.id,
      supplierId: purchaseOrder.supplierId,
      items: rejectedItems,
      severity: this.calculateIssueSeverity(rejectedItems),
      reportedDate: new Date()
    })
  }
}

interface InspectionData {
  inspectorId: string
  receivedItems: ReceivedItem[]
  qualityChecks: QualityCheck[]
  packagingCondition: PackagingCondition
  documents: DocumentCheck[]
  notes?: string
  photos?: string[]
}

interface InspectionResult {
  purchaseOrderId: string
  inspectionDate: Date
  inspectorId: string
  results: {
    quantity: QuantityInspectionResult
    quality: QualityInspectionResult
    packaging: PackagingInspectionResult
    documentation: DocumentInspectionResult
  }
  overallStatus: 'passed' | 'failed' | 'partial'
  acceptedItems: AcceptedItem[]
  rejectedItems: RejectedItem[]
  notes?: string
}
```

### 8. 成本核算與預算控制

#### 8.1 採購成本計算
```typescript
class ProcurementCostCalculator {
  // 計算採購總成本
  async calculateTotalCost(purchaseOrderData: PurchaseOrderData): Promise<CostBreakdown> {
    const breakdown: CostBreakdown = {
      subtotal: 0,
      shippingCost: 0,
      taxAmount: 0,
      exchangeFee: 0,
      creditCardFee: 0,
      importDuty: 0,
      inspectionFee: 0,
      totalCost: 0,
      costPerUnit: 0
    }
    
    // 商品小計
    breakdown.subtotal = purchaseOrderData.items.reduce(
      (sum, item) => sum + (item.quantity * item.unitPrice), 0
    )
    
    // 運費計算
    breakdown.shippingCost = await this.calculateShippingCost(
      purchaseOrderData.supplierId,
      purchaseOrderData.items,
      purchaseOrderData.shippingMethod
    )
    
    // 稅費計算
    breakdown.taxAmount = await this.calculateTax(
      breakdown.subtotal,
      purchaseOrderData.supplierId,
      purchaseOrderData.items
    )
    
    // 匯費計算（如果是外幣採購）
    if (purchaseOrderData.currency !== 'TWD') {
      breakdown.exchangeFee = this.calculateExchangeFee(
        breakdown.subtotal,
        purchaseOrderData.currency,
        purchaseOrderData.exchangeRate
      )
    }
    
    // 信用卡手續費
    if (purchaseOrderData.paymentMethod === 'credit_card') {
      breakdown.creditCardFee = this.calculateCreditCardFee(
        breakdown.subtotal + breakdown.shippingCost + breakdown.taxAmount
      )
    }
    
    // 進口關稅（如果是進口商品）
    if (purchaseOrderData.isImported) {
      breakdown.importDuty = await this.calculateImportDuty(
        purchaseOrderData.items,
        purchaseOrderData.originCountry
      )
    }
    
    // 檢驗費用
    if (purchaseOrderData.requiresInspection) {
      breakdown.inspectionFee = this.calculateInspectionFee(purchaseOrderData.items)
    }
    
    // 總成本
    breakdown.totalCost = breakdown.subtotal + 
                         breakdown.shippingCost + 
                         breakdown.taxAmount + 
                         breakdown.exchangeFee + 
                         breakdown.creditCardFee + 
                         breakdown.importDuty + 
                         breakdown.inspectionFee
    
    // 單位成本
    const totalQuantity = purchaseOrderData.items.reduce((sum, item) => sum + item.quantity, 0)
    breakdown.costPerUnit = breakdown.totalCost / totalQuantity
    
    return breakdown
  }
  
  // 信用卡手續費計算
  private calculateCreditCardFee(amount: number): number {
    const feeRate = 0.025 // 2.5%
    return Math.round(amount * feeRate)
  }
  
  // 匯費計算
  private calculateExchangeFee(amount: number, currency: string, exchangeRate: number): number {
    const feeRate = 0.001 // 0.1%
    const twdAmount = amount * exchangeRate
    return Math.round(twdAmount * feeRate)
  }
}

interface CostBreakdown {
  subtotal: number         // 商品小計
  shippingCost: number     // 運費
  taxAmount: number        // 稅費
  exchangeFee: number      // 匯費
  creditCardFee: number    // 刷卡手續費
  importDuty: number       // 進口關稅
  inspectionFee: number    // 檢驗費
  totalCost: number        // 總成本
  costPerUnit: number      // 單位成本
}
```

#### 8.2 採購預算管理
```typescript
class ProcurementBudgetManager {
  // 檢查預算可用性
  async checkBudgetAvailability(
    departmentId: string,
    category: string,
    amount: number,
    period: BudgetPeriod
  ): Promise<BudgetCheckResult> {
    
    const budget = await this.budgetRepository.findByDepartmentAndCategory(
      departmentId, 
      category, 
      period
    )
    
    if (!budget) {
      return {
        isAvailable: false,
        reason: 'No budget allocated for this category',
        availableAmount: 0
      }
    }
    
    const usedAmount = await this.calculateUsedBudget(departmentId, category, period)
    const availableAmount = budget.allocatedAmount - usedAmount
    
    return {
      isAvailable: availableAmount >= amount,
      reason: availableAmount >= amount ? 'Budget available' : 'Insufficient budget',
      availableAmount: availableAmount,
      requestedAmount: amount,
      budgetUtilization: (usedAmount / budget.allocatedAmount) * 100
    }
  }
  
  // 預算預留
  async reserveBudget(
    purchaseOrderId: string,
    departmentId: string,
    category: string,
    amount: number
  ): Promise<void> {
    
    await this.budgetReservationRepository.create({
      purchaseOrderId: purchaseOrderId,
      departmentId: departmentId,
      category: category,
      reservedAmount: amount,
      reservedAt: new Date(),
      status: 'reserved'
    })
  }
  
  // 預算消耗
  async consumeBudget(
    purchaseOrderId: string,
    actualAmount: number
  ): Promise<void> {
    
    const reservation = await this.budgetReservationRepository.findByPurchaseOrderId(purchaseOrderId)
    
    if (reservation) {
      // 更新預留狀態
      await this.budgetReservationRepository.update(reservation.id, {
        consumedAmount: actualAmount,
        consumedAt: new Date(),
        status: 'consumed'
      })
      
      // 如果實際金額與預留金額不同，處理差額
      if (actualAmount !== reservation.reservedAmount) {
        const difference = actualAmount - reservation.reservedAmount
        if (difference > 0) {
          // 需要額外預算
          await this.handleAdditionalBudgetRequirement(reservation, difference)
        } else {
          // 釋放多餘預算
          await this.releaseBudget(reservation, Math.abs(difference))
        }
      }
    }
  }
}

interface BudgetCheckResult {
  isAvailable: boolean
  reason: string
  availableAmount: number
  requestedAmount?: number
  budgetUtilization?: number
}
```

### 9. 應付帳款整合

#### 9.1 應付帳款管理
```typescript
class AccountsPayableManager {
  // 建立應付帳款記錄
  async createAccountsPayable(purchaseOrder: PurchaseOrder): Promise<AccountsPayable> {
    const payable = await this.accountsPayableRepository.create({
      purchaseOrderId: purchaseOrder.id,
      supplierId: purchaseOrder.supplierId,
      supplierName: purchaseOrder.supplierName,
      invoiceNumber: null, // 待供應商提供發票
      amount: purchaseOrder.totalAmount,
      currency: purchaseOrder.currency,
      dueDate: this.calculateDueDate(purchaseOrder.paymentTerms, purchaseOrder.createdAt),
      status: 'pending',
      paymentMethod: purchaseOrder.paymentMethod,
      accountingSubject: purchaseOrder.paymentAccountingSubject,
      createdAt: new Date()
    })
    
    // 發送應付帳款通知
    await this.notificationService.notifyAccountingTeam('accounts_payable_created', {
      payableId: payable.id,
      supplierName: purchaseOrder.supplierName,
      amount: purchaseOrder.totalAmount,
      dueDate: payable.dueDate
    })
    
    return payable
  }
  
  // 處理付款
  async processPayment(
    payableId: string,
    paymentData: PaymentData
  ): Promise<PaymentResult> {
    
    const payable = await this.accountsPayableRepository.findById(payableId)
    
    // 執行付款
    const paymentResult = await this.paymentProcessor.processPayment({
      amount: paymentData.amount,
      paymentMethod: paymentData.paymentMethod,
      accountingSubject: paymentData.accountingSubject,
      reference: payable.purchaseOrderId,
      description: `Payment to ${payable.supplierName} for PO ${payable.purchaseOrderId}`
    })
    
    if (paymentResult.success) {
      // 更新應付帳款狀態
      await this.accountsPayableRepository.update(payableId, {
        status: 'paid',
        paidAmount: paymentData.amount,
        paidDate: new Date(),
        paymentReference: paymentResult.transactionId
      })
      
      // 記錄付款交易
      await this.paymentTransactionService.recordTransaction({
        payableId: payableId,
        amount: paymentData.amount,
        paymentMethod: paymentData.paymentMethod,
        transactionId: paymentResult.transactionId,
        processedBy: paymentData.processedBy
      })
      
      // 更新採購單付款狀態
      await this.purchaseOrderRepository.update(payable.purchaseOrderId, {
        paymentStatus: 'paid',
        paidAt: new Date()
      })
    }
    
    return paymentResult
  }
  
  // 應付帳款報表
  async generatePayablesReport(
    dateRange: DateRange,
    filters: PayablesReportFilters
  ): Promise<PayablesReport> {
    
    const payables = await this.accountsPayableRepository.findByFilters({
      dateRange,
      supplierId: filters.supplierId,
      status: filters.status,
      paymentMethod: filters.paymentMethod
    })
    
    return {
      period: dateRange,
      totalPayables: payables.length,
      totalAmount: payables.reduce((sum, p) => sum + p.amount, 0),
      paidAmount: payables.filter(p => p.status === 'paid').reduce((sum, p) => sum + (p.paidAmount || 0), 0),
      unpaidAmount: payables.filter(p => p.status === 'pending').reduce((sum, p) => sum + p.amount, 0),
      overdueAmount: payables.filter(p => p.status === 'pending' && p.dueDate < new Date()).reduce((sum, p) => sum + p.amount, 0),
      paymentsByMethod: this.groupByPaymentMethod(payables),
      payablesBySupplier: this.groupBySupplier(payables),
      agingAnalysis: this.generateAgingAnalysis(payables)
    }
  }
}

interface AccountsPayable {
  id: string
  purchaseOrderId: string
  supplierId: string
  supplierName: string
  invoiceNumber?: string
  amount: number
  currency: string
  dueDate: Date
  status: 'pending' | 'paid' | 'overdue' | 'cancelled'
  paymentMethod: string
  accountingSubject: string
  paidAmount?: number
  paidDate?: Date
  paymentReference?: string
  createdAt: Date
  updatedAt: Date
}
```

### 10. 後台管理介面

#### 10.1 採購管理控制台
```typescript
interface ProcurementManagementUI {
  // 採購總覽頁面
  procurementOverview: {
    components: [
      'ProcurementStatsCards',
      'ActivePurchaseOrders',
      'BudgetUtilization',
      'SupplierPerformance',
      'CostAnalysis'
    ]
  }
  
  // 採購單管理頁面
  purchaseOrderManagement: {
    components: [
      'PurchaseOrderDataTable',
      'FilterAndSearch',
      'BulkActions',
      'StatusWorkflow',
      'DocumentManager'
    ]
    features: [
      'multi_select_approval',
      'status_bulk_update', 
      'export_to_excel',
      'print_purchase_orders',
      'supplier_communication'
    ]
  }
  
  // 採購建議頁面
  procurementSuggestions: {
    components: [
      'SmartSuggestionsList',
      'DemandForecastChart',
      'SeasonalPlanningCalendar',
      'BudgetImpactAnalysis',
      'SupplierRecommendations'
    ]
  }
  
  // 驗收入庫頁面
  inspectionReceipt: {
    components: [
      'InspectionQueue',
      'QualityCheckForms',
      'PhotoUploader',
      'BatchProcessing',
      'InventoryUpdate'
    ]
  }
  
  // 供應商績效頁面
  supplierPerformance: {
    components: [
      'PerformanceDashboard',
      'DeliveryTracking',
      'QualityTrends',
      'CostAnalysis',
      'RiskAssessment'
    ]
  }
  
  // 成本分析頁面
  costAnalysis: {
    components: [
      'CostBreakdownChart',
      'BudgetVsActual',
      'CostTrends',
      'SupplierCostComparison',
      'SavingsOpportunities'
    ]
  }
}
```

### 11. API 介面規格

#### 11.1 後台API
```typescript
// 採購單管理
GET /admin/api/procurement/purchase-orders
POST /admin/api/procurement/purchase-orders
GET /admin/api/procurement/purchase-orders/:id
PUT /admin/api/procurement/purchase-orders/:id
DELETE /admin/api/procurement/purchase-orders/:id

// 採購建議
GET /admin/api/procurement/suggestions
POST /admin/api/procurement/suggestions/generate
GET /admin/api/procurement/seasonal-planning

// 供應商選擇
GET /admin/api/procurement/suppliers/compare?productId=:productId&quantity=:quantity
GET /admin/api/procurement/payment-options?supplierId=:supplierId&amount=:amount

// 驗收入庫
POST /admin/api/procurement/inspection-receipt
GET /admin/api/procurement/pending-inspection
PUT /admin/api/procurement/inspection-receipt/:id/complete

// 成本分析
GET /admin/api/procurement/cost-analysis
GET /admin/api/procurement/budget-status
POST /admin/api/procurement/budget/reserve

// 應付帳款
GET /admin/api/procurement/accounts-payable
POST /admin/api/procurement/accounts-payable/:id/pay
GET /admin/api/procurement/payables-report
```

### 12. 資料庫設計

#### 12.1 核心資料表
```sql
-- 採購單表
CREATE TABLE purchase_orders (
  id VARCHAR(36) PRIMARY KEY,
  order_number VARCHAR(100) UNIQUE NOT NULL,
  type ENUM('product_procurement', 'gift_procurement', 'emergency_procurement', 'campaign_procurement'),
  supplier_id VARCHAR(36) NOT NULL,
  supplier_name VARCHAR(255) NOT NULL,
  status ENUM('draft', 'pending_approval', 'approved', 'sent_to_supplier', 'confirmed', 'in_production', 'shipped', 'delivered', 'under_inspection', 'received', 'partially_received', 'cancelled', 'rejected'),
  priority ENUM('low', 'normal', 'high', 'urgent') DEFAULT 'normal',
  
  subtotal DECIMAL(12,2) NOT NULL,
  shipping_cost DECIMAL(10,2) DEFAULT 0,
  tax_amount DECIMAL(10,2) DEFAULT 0,
  exchange_fee DECIMAL(10,2) DEFAULT 0,
  credit_card_fee DECIMAL(10,2) DEFAULT 0,
  total_amount DECIMAL(12,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'TWD',
  
  payment_method VARCHAR(50),
  payment_accounting_subject VARCHAR(100),
  payment_terms VARCHAR(255),
  payment_due_date DATE,
  
  expected_delivery_date DATE,
  actual_delivery_date DATE,
  lead_time_days INT,
  
  notes TEXT,
  created_by VARCHAR(36),
  approved_by VARCHAR(36),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id),
  INDEX idx_purchase_orders_supplier (supplier_id),
  INDEX idx_purchase_orders_status (status),
  INDEX idx_purchase_orders_type (type),
  INDEX idx_purchase_orders_created (created_at)
);

-- 採購單商品表
CREATE TABLE purchase_order_items (
  id VARCHAR(36) PRIMARY KEY,
  purchase_order_id VARCHAR(36) NOT NULL,
  product_id VARCHAR(36),
  gift_id VARCHAR(36),
  item_name VARCHAR(255) NOT NULL,
  item_code VARCHAR(100),
  specification TEXT,
  quantity INT NOT NULL,
  unit_price DECIMAL(10,2) NOT NULL,
  subtotal DECIMAL(12,2) NOT NULL,
  delivery_date DATE,
  notes TEXT,
  
  FOREIGN KEY (purchase_order_id) REFERENCES purchase_orders(id) ON DELETE CASCADE,
  FOREIGN KEY (product_id) REFERENCES products(id),
  FOREIGN KEY (gift_id) REFERENCES gifts(id),
  INDEX idx_po_items_purchase_order (purchase_order_id),
  INDEX idx_po_items_product (product_id),
  INDEX idx_po_items_gift (gift_id)
);

-- 驗收記錄表
CREATE TABLE inspection_receipts (
  id VARCHAR(36) PRIMARY KEY,
  purchase_order_id VARCHAR(36) NOT NULL,
  inspector_id VARCHAR(36) NOT NULL,
  inspection_date TIMESTAMP NOT NULL,
  overall_status ENUM('passed', 'failed', 'partial'),
  quantity_status ENUM('correct', 'shortage', 'overage'),
  quality_status ENUM('passed', 'failed', 'conditional'),
  packaging_status ENUM('good', 'damaged', 'acceptable'),
  documentation_status ENUM('complete', 'incomplete', 'missing'),
  accepted_quantity INT,
  rejected_quantity INT,
  notes TEXT,
  photos JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (purchase_order_id) REFERENCES purchase_orders(id),
  INDEX idx_inspection_purchase_order (purchase_order_id),
  INDEX idx_inspection_date (inspection_date)
);

-- 應付帳款表
CREATE TABLE accounts_payable (
  id VARCHAR(36) PRIMARY KEY,
  purchase_order_id VARCHAR(36) NOT NULL,
  supplier_id VARCHAR(36) NOT NULL,
  supplier_name VARCHAR(255) NOT NULL,
  invoice_number VARCHAR(100),
  amount DECIMAL(12,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'TWD',
  due_date DATE NOT NULL,
  status ENUM('pending', 'paid', 'overdue', 'cancelled') DEFAULT 'pending',
  payment_method VARCHAR(50),
  accounting_subject VARCHAR(100),
  paid_amount DECIMAL(12,2),
  paid_date TIMESTAMP NULL,
  payment_reference VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (purchase_order_id) REFERENCES purchase_orders(id),
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id),
  INDEX idx_payable_supplier (supplier_id),
  INDEX idx_payable_status (status),
  INDEX idx_payable_due_date (due_date)
);
```

## 整合規格

### 與供應商管理整合
- 供應商資料的無縫使用
- 付款方式和條件的自動同步
- 履約表現的即時記錄

### 與通知管理整合
- 庫存警報觸發LINE通知
- 採購流程狀態變更通知
- 供應商溝通通知

### 與庫存管理整合
- 庫存不足觸發採購流程
- 驗收完成自動更新庫存
- 安全庫存量管理

### 與會計管理整合
- 會計科目對應付款方式
- 自動產生會計分錄
- 應付帳款管理

### 與贈品管理整合
- 贈品採購的特殊處理
- 節慶贈品的時程管理
- 客製贈品的規格確認

## 效能考量

### 快取策略
- 採購建議結果快取 (TTL: 1小時)
- 供應商比價結果快取 (TTL: 30分鐘)
- 績效報表快取 (TTL: 4小時)

### 效能目標
- 採購建議生成時間 < 3秒
- 供應商比價響應時間 < 500ms
- 批量採購單處理能力 > 100筆/分鐘
- 報表生成時間 < 10秒

### 可靠性設計
- 採購流程的事務一致性
- 付款失敗的回滾機制
- 庫存更新的原子性操作
- 系統異常的自動恢復

---

本模組確保採購管理的完整性和自動化程度，從庫存警報到商品入庫的全流程管理，整合供應商管理、通知管理、會計管理等模組，提供智能化的採購決策支持和完整的成本控制功能。