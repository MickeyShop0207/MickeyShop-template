# 模組 12: 物流管理模組 (Logistics Management Module)

## 模組概述

物流管理模組專門整合綠界ECPay物流服務，提供完整的配送管理、運費計算、物流追蹤，以及退換貨逆物流處理。支援綠界所有物流方式，包含重量、體積、跨境等多種計費模式，並提供即時物流狀態更新與前台客戶追蹤功能。

## 核心功能架構

### 1. 綠界物流服務整合

#### 1.1 支援的物流方式
```typescript
enum ECPayLogisticsType {
  // 超商取貨
  UNIMART_C2C = 'UNIMART',           // 7-ELEVEN 取貨不付款
  UNIMART_COLLECTION = 'UNIMARTC2C', // 7-ELEVEN 取貨付款
  FAMI_C2C = 'FAMI',                 // 全家 取貨不付款  
  FAMI_COLLECTION = 'FAMIC2C',       // 全家 取貨付款
  HILIFE_C2C = 'HILIFE',             // 萊爾富 取貨不付款
  HILIFE_COLLECTION = 'HILIFEC2C',   // 萊爾富 取貨付款
  OKMARTC2C = 'OKMART',              // OK超商 取貨不付款
  OKMART_COLLECTION = 'OKMARTC2C',   // OK超商 取貨付款
  
  // 宅配服務
  TCAT = 'TCAT',                     // 黑貓宅急便
  ECAN = 'ECAN',                     // 宅配通
  
  // 郵局配送  
  POST = 'POST'                      // 中華郵政
}

interface ECPayLogisticsConfig {
  logisticsType: ECPayLogisticsType
  temperature: 'ROOM' | 'FREEZE' | 'REFRIGERATED'
  distance: 'SAME' | 'OTHER' | 'ISLAND'
  specification: 'CM_60' | 'CM_90' | 'CM_120' | 'CM_150'
  paymentType: 'COD' | 'PREPAID'
}
```

#### 1.2 綠界API整合服務
```typescript
class ECPayLogisticsService {
  private merchantID: string
  private hashKey: string
  private hashIV: string
  private apiEndpoint: string
  
  // 建立物流訂單
  async createLogisticsOrder(orderData: CreateLogisticsRequest): Promise<ECPayLogisticsResponse> {
    const params = this.prepareLogisticsParams(orderData)
    const checkMacValue = this.generateCheckMacValue(params)
    
    return await this.callECPayAPI('/Express/Create', {
      ...params,
      CheckMacValue: checkMacValue
    })
  }
  
  // 查詢物流狀態
  async queryLogisticsInfo(logisticsID: string): Promise<LogisticsStatusResponse> {
    const params = {
      MerchantID: this.merchantID,
      LogisticsID: logisticsID,
      TimeStamp: Date.now()
    }
    
    return await this.callECPayAPI('/Helper/QueryLogisticsTradeInfo/V3', params)
  }
  
  // 列印託運單
  async printLogisticsOrder(logisticsID: string): Promise<PrintResponse> {
    return await this.callECPayAPI('/helper/printTradeDocument', {
      MerchantID: this.merchantID,
      LogisticsID: logisticsID
    })
  }
}

interface CreateLogisticsRequest {
  merchantTradeNo: string
  logisticsType: ECPayLogisticsType
  logisticsSubType: string
  goodsAmount: number
  senderName: string
  senderPhone: string
  senderCellPhone?: string
  receiverName: string
  receiverPhone: string
  receiverCellPhone?: string
  receiverEmail: string
  receiverAddress?: string
  receiverStoreID?: string
  temperature: string
  distance: string
  specification: string
  scheduledPickupTime?: string
  scheduledDeliveryTime?: string
  packageCount: number
  goodsName: string
  goodsWeight: number
  goodsVolume: number
}
```

### 2. 多維度運費計算系統

#### 2.1 計費方式設定
```typescript
interface ShippingRateConfig {
  id: string
  name: string
  logisticsTypes: ECPayLogisticsType[]
  calculationMethod: CalculationMethod[]
  rateRules: ShippingRate[]
  specialConditions: SpecialCondition[]
  isActive: boolean
}

enum CalculationMethod {
  WEIGHT = 'weight',           // 重量計費
  VOLUME = 'volume',           // 體積計費
  AMOUNT = 'amount',           // 金額計費
  QUANTITY = 'quantity',       // 數量計費
  CROSS_BORDER = 'cross_border', // 跨境物流
  TAX_INCLUSIVE = 'tax_inclusive' // 含稅計費
}

interface ShippingRate {
  method: CalculationMethod
  tiers: RateTier[]
  baseRate: number
  freeShippingThreshold?: number
  maxWeight?: number
  maxVolume?: number
}

interface RateTier {
  min: number
  max: number
  rate: number
  fixedFee?: number
}
```

#### 2.2 重量與體積計算
```typescript
class ShippingCalculator {
  // 重量計費計算
  calculateWeightShipping(totalWeight: number, rateConfig: ShippingRate): number {
    const tier = this.findApplicableTier(totalWeight, rateConfig.tiers)
    return tier.fixedFee || (totalWeight * tier.rate)
  }
  
  // 體積重量計算
  calculateVolumeWeight(
    length: number, 
    width: number, 
    height: number,
    volumeConversionFactor: number = 5000
  ): number {
    const volumeWeight = (length * width * height) / volumeConversionFactor
    return Math.max(volumeWeight, 0)
  }
  
  // 混合計費（取重量與體積重量較大值）
  calculateDimensionalWeight(
    actualWeight: number,
    dimensions: ProductDimensions[],
    volumeConversionFactor: number = 5000
  ): number {
    const totalVolumeWeight = dimensions.reduce((total, dim) => {
      return total + this.calculateVolumeWeight(
        dim.length, dim.width, dim.height, volumeConversionFactor
      )
    }, 0)
    
    return Math.max(actualWeight, totalVolumeWeight)
  }
  
  // 跨境物流費用計算
  calculateCrossBorderShipping(
    orderData: OrderData,
    destination: string,
    taxRate: number
  ): CrossBorderShippingCost {
    const baseShipping = this.calculateDomesticShipping(orderData)
    const internationalSurcharge = this.getInternationalSurcharge(destination)
    const customsDuty = orderData.totalAmount * taxRate
    const handlingFee = this.getCustomsHandlingFee(orderData.totalAmount)
    
    return {
      baseShipping,
      internationalSurcharge,
      customsDuty,
      handlingFee,
      totalCrossBorderFee: baseShipping + internationalSurcharge + customsDuty + handlingFee
    }
  }
}

interface CrossBorderShippingCost {
  baseShipping: number
  internationalSurcharge: number
  customsDuty: number
  handlingFee: number
  totalCrossBorderFee: number
  estimatedDeliveryDays: number
}
```

#### 2.3 智能運費優化
```typescript
class ShippingOptimizer {
  // 找出最經濟的物流方式
  findOptimalShipping(
    orderData: OrderData,
    availableOptions: ECPayLogisticsType[]
  ): OptimalShippingResult {
    const results = availableOptions.map(logisticsType => {
      const cost = this.calculateShippingCost(orderData, logisticsType)
      const deliveryTime = this.getEstimatedDeliveryTime(logisticsType, orderData.destination)
      
      return {
        logisticsType,
        cost,
        deliveryTime,
        score: this.calculateOptimizationScore(cost, deliveryTime, orderData.urgency)
      }
    })
    
    return results.sort((a, b) => b.score - a.score)[0]
  }
  
  // 包裝優化建議
  optimizePackaging(items: OrderItem[]): PackagingRecommendation {
    const totalWeight = items.reduce((sum, item) => sum + (item.weight * item.quantity), 0)
    const totalVolume = this.calculateTotalVolume(items)
    
    return {
      recommendedPackages: this.suggestOptimalPackages(items),
      estimatedWeight: totalWeight,
      estimatedVolume: totalVolume,
      packagingCost: this.calculatePackagingCost(totalWeight, totalVolume),
      consolidationSavings: this.calculateConsolidationSavings(items)
    }
  }
}
```

### 3. 即時物流追蹤系統

#### 3.1 物流狀態管理
```typescript
enum LogisticsStatus {
  CREATED = 'created',             // 物流單已建立
  PICKED_UP = 'picked_up',         // 商品已取貨
  IN_TRANSIT = 'in_transit',       // 運送中
  OUT_FOR_DELIVERY = 'out_for_delivery', // 派送中
  DELIVERED = 'delivered',         // 已送達
  READY_FOR_PICKUP = 'ready_for_pickup', // 可取貨（超商）
  PICKED_UP_BY_CUSTOMER = 'picked_up_by_customer', // 客戶已取貨
  FAILED_DELIVERY = 'failed_delivery',   // 派送失敗
  RETURNED = 'returned',           // 已退回
  CANCELLED = 'cancelled'          // 已取消
}

interface LogisticsTracking {
  orderId: string
  logisticsId: string
  merchantTradeNo: string
  logisticsType: ECPayLogisticsType
  status: LogisticsStatus
  statusHistory: StatusHistoryEntry[]
  estimatedDelivery?: Date
  actualDelivery?: Date
  trackingNumber?: string
  storeInfo?: StoreInfo
  deliveryAddress?: Address
  specialInstructions?: string
  lastUpdated: Date
}

interface StatusHistoryEntry {
  status: LogisticsStatus
  timestamp: Date
  location?: string
  description: string
  operatorId?: string
}
```

#### 3.2 綠界Webhook處理
```typescript
class ECPayWebhookHandler {
  // 處理物流狀態更新
  async handleLogisticsStatusUpdate(webhookData: ECPayWebhookData): Promise<void> {
    try {
      // 驗證 Webhook 簽名
      if (!this.verifyWebhookSignature(webhookData)) {
        throw new Error('Invalid webhook signature')
      }
      
      const logisticsUpdate = this.parseLogisticsUpdate(webhookData)
      
      // 更新內部物流追蹤記錄
      await this.updateLogisticsTracking(logisticsUpdate)
      
      // 通知相關系統
      await this.notifyStatusChange(logisticsUpdate)
      
      // 更新前台客戶追蹤資訊
      await this.syncToCustomerPortal(logisticsUpdate)
      
    } catch (error) {
      await this.logWebhookError(error, webhookData)
      throw error
    }
  }
  
  // 同步到前台客戶追蹤
  private async syncToCustomerPortal(logisticsUpdate: LogisticsUpdate): Promise<void> {
    const order = await this.orderService.findByLogisticsId(logisticsUpdate.logisticsId)
    
    // 更新訂單狀態
    await this.orderService.updateLogisticsStatus(order.id, logisticsUpdate.status)
    
    // 發送客戶通知
    if (this.shouldNotifyCustomer(logisticsUpdate.status)) {
      await this.notificationService.sendLogisticsUpdate(order.customerId, {
        orderId: order.id,
        status: logisticsUpdate.status,
        estimatedDelivery: logisticsUpdate.estimatedDelivery,
        trackingUrl: this.generateTrackingUrl(logisticsUpdate.logisticsId)
      })
    }
  }
}

interface ECPayWebhookData {
  MerchantID: string
  MerchantTradeNo: string
  LogisticsID: string
  LogisticsType: string
  LogisticsSubType: string
  GoodsAmount: number
  UpdateStatusDate: string
  ReceiverName: string
  ReceiverPhone: string
  ReceiverCellPhone: string
  ReceiverEmail: string
  ReceiverAddress: string
  CVSStoreID?: string
  CVSStoreName?: string
  CVSAddress?: string
  CVSTelephone?: string
  CheckMacValue: string
}
```

#### 3.3 前台追蹤介面整合
```typescript
interface CustomerTrackingUI {
  // 訂單追蹤頁面
  trackingPage: {
    components: [
      'LogisticsStatusTimeline',
      'DeliveryProgressBar', 
      'EstimatedDeliveryInfo',
      'ContactLogisticsProvider',
      'DeliveryInstructions'
    ]
  }
  
  // 即時通知系統
  realTimeNotifications: {
    channels: ['web_push', 'email', 'sms', 'line_notify']
    triggers: [
      'status_change',
      'ready_for_pickup', 
      'delivery_attempt',
      'delivered'
    ]
  }
}

class CustomerLogisticsService {
  // 取得客戶物流追蹤資訊
  async getCustomerTrackingInfo(customerId: string, orderId: string): Promise<CustomerTrackingInfo> {
    const order = await this.validateCustomerAccess(customerId, orderId)
    const tracking = await this.logisticsTrackingService.findByOrderId(orderId)
    
    return {
      orderId: order.id,
      orderNumber: order.orderNumber,
      logisticsProvider: this.getProviderName(tracking.logisticsType),
      currentStatus: tracking.status,
      statusDescription: this.getStatusDescription(tracking.status),
      estimatedDelivery: tracking.estimatedDelivery,
      trackingNumber: tracking.trackingNumber,
      deliveryAddress: tracking.deliveryAddress,
      storeInfo: tracking.storeInfo,
      statusTimeline: tracking.statusHistory,
      canModifyDelivery: this.canModifyDeliveryInfo(tracking.status),
      supportContact: this.getLogisticsSupport(tracking.logisticsType)
    }
  }
}
```

### 4. 贈品物流處理

#### 4.1 贈品包裝整合
```typescript
interface GiftLogisticsHandler {
  // 贈品與商品合併包裝
  consolidateGiftsWithProducts(
    orderItems: OrderItem[],
    gifts: Gift[]
  ): PackagingPlan {
    const totalWeight = this.calculateTotalWeight(orderItems, gifts)
    const totalVolume = this.calculateTotalVolume(orderItems, gifts)
    
    return {
      packages: this.optimizePackaging(orderItems, gifts),
      totalWeight,
      totalVolume,
      shippingWeight: Math.max(totalWeight, totalVolume / 5000), // 材積重量
      giftHandlingInstructions: this.generateGiftInstructions(gifts),
      fragileItems: this.identifyFragileItems([...orderItems, ...gifts])
    }
  }
  
  // 贈品包裝說明生成
  generateGiftInstructions(gifts: Gift[]): PackagingInstruction[] {
    return gifts.map(gift => ({
      giftId: gift.id,
      giftName: gift.name,
      packagingRequirement: gift.packagingRequirement,
      isFragile: gift.isFragile,
      needsSpecialHandling: gift.needsSpecialHandling,
      includeGiftCard: gift.includeGiftCard,
      giftMessage: gift.giftMessage
    }))
  }
}

// 贈品不計運費但計入重量體積
const GIFT_LOGISTICS_RULES = {
  feeCalculation: false,      // 贈品不計入運費
  weightCalculation: true,    // 計入總重量
  volumeCalculation: true,    // 計入總體積
  packagingOptimization: true, // 優化包裝配置
  separateLabeling: true      // 獨立標示贈品
}
```

### 5. 退換貨逆物流系統

#### 5.1 退貨方式設定
```typescript
interface ReturnShippingConfig {
  returnMethods: ReturnMethod[]
  feePolicy: ReturnFeePolicy
  timeLimit: number // 可退貨天數
  eligibleItems: string[] // 可退貨商品類型
  restrictedItems: string[] // 不可退貨商品
}

enum ReturnMethod {
  CONVENIENCE_STORE = 'convenience_store', // 超商退貨
  HOME_PICKUP = 'home_pickup',            // 宅配到府收件
  POST_OFFICE = 'post_office'             // 郵局寄回
}

enum ReturnFeePolicy {
  CUSTOMER_PAYS = 'customer_pays',         // 買家負擔
  MERCHANT_PAYS = 'merchant_pays',         // 賣家負擔
  CONDITIONAL = 'conditional'              // 條件式負擔
}

interface ReturnFeeCondition {
  condition: 'defective_item' | 'wrong_item' | 'customer_remorse' | 'size_issue'
  feeResponsibility: 'customer' | 'merchant'
  feeAmount?: number
}
```

#### 5.2 退貨物流處理流程
```typescript
class ReturnLogisticsService {
  // 建立退貨物流單
  async createReturnLogistics(
    returnRequest: ReturnRequest,
    returnMethod: ReturnMethod
  ): Promise<ReturnLogisticsResult> {
    
    const returnConfig = await this.getReturnShippingConfig()
    const feeCalculation = this.calculateReturnShippingFee(
      returnRequest,
      returnMethod,
      returnConfig.feePolicy
    )
    
    let logisticsResponse: ECPayLogisticsResponse
    
    switch (returnMethod) {
      case ReturnMethod.CONVENIENCE_STORE:
        logisticsResponse = await this.createConvenienceStoreReturn(returnRequest)
        break
        
      case ReturnMethod.HOME_PICKUP:
        logisticsResponse = await this.createHomePickupReturn(returnRequest)
        break
        
      case ReturnMethod.POST_OFFICE:
        logisticsResponse = await this.createPostOfficeReturn(returnRequest)
        break
    }
    
    return {
      returnLogisticsId: logisticsResponse.LogisticsID,
      returnTrackingNumber: logisticsResponse.CVSPaymentNo,
      returnMethod,
      shippingFee: feeCalculation.totalFee,
      feeResponsibility: feeCalculation.responsibility,
      instructions: this.generateReturnInstructions(returnMethod, logisticsResponse),
      expectedProcessingTime: this.getReturnProcessingTime(returnMethod)
    }
  }
  
  // 計算退貨運費
  calculateReturnShippingFee(
    returnRequest: ReturnRequest,
    returnMethod: ReturnMethod,
    feePolicy: ReturnFeePolicy
  ): ReturnFeeCalculation {
    
    const baseFee = this.getReturnBaseFee(returnMethod)
    let responsibility: 'customer' | 'merchant'
    
    if (feePolicy === ReturnFeePolicy.CONDITIONAL) {
      responsibility = this.determineConditionalResponsibility(returnRequest)
    } else {
      responsibility = feePolicy === ReturnFeePolicy.CUSTOMER_PAYS ? 'customer' : 'merchant'
    }
    
    return {
      baseFee,
      additionalFees: this.calculateAdditionalReturnFees(returnRequest),
      totalFee: baseFee,
      responsibility,
      deductFromRefund: responsibility === 'customer'
    }
  }
  
  // 處理退貨商品檢驗
  async processReturnedItems(
    returnLogisticsId: string,
    receivedItems: ReceivedReturnItem[]
  ): Promise<ReturnProcessingResult> {
    
    const inspectionResults = await this.inspectReturnedItems(receivedItems)
    const refundCalculation = this.calculateRefundAmount(inspectionResults)
    
    // 更新庫存
    await this.updateInventoryForReturns(inspectionResults.acceptedItems)
    
    // 處理退款
    if (refundCalculation.refundAmount > 0) {
      await this.processRefund(refundCalculation)
    }
    
    // 通知客戶處理結果
    await this.notifyReturnProcessingComplete(returnLogisticsId, inspectionResults)
    
    return {
      inspectionResults,
      refundAmount: refundCalculation.refundAmount,
      processingFee: refundCalculation.processingFee,
      restockingFee: refundCalculation.restockingFee
    }
  }
}
```

#### 5.3 系統設定介面
```typescript
interface ReturnShippingSettings {
  // 退貨方式啟用設定
  enabledMethods: {
    convenienceStore: boolean
    homePickup: boolean
    postOffice: boolean
  }
  
  // 運費政策設定
  feePolicy: {
    defaultPolicy: ReturnFeePolicy
    conditionalRules: ReturnFeeCondition[]
    feeAmounts: Record<ReturnMethod, number>
  }
  
  // 時間限制設定
  timeLimits: {
    standardReturn: number // 標準退貨期限（天）
    defectiveReturn: number // 瑕疵品退貨期限（天）
    fashionItems: number // 服飾類退貨期限（天）
    cosmeticItems: number // 化妝品退貨期限（天）
  }
  
  // 自動化設定
  automation: {
    autoApproveReturns: boolean
    autoRefundProcessing: boolean
    autoInventoryUpdate: boolean
    autoCustomerNotification: boolean
  }
}
```

### 6. 物流數據分析與報表

#### 6.1 物流效能分析
```typescript
interface LogisticsAnalytics {
  // 配送效能統計
  deliveryPerformance: {
    averageDeliveryTime: number
    onTimeDeliveryRate: number
    failedDeliveryRate: number
    customerSatisfactionScore: number
  }
  
  // 物流成本分析
  costAnalysis: {
    totalShippingCosts: number
    averageCostPerOrder: number
    freeShippingImpact: number
    returnShippingCosts: number
  }
  
  // 物流方式偏好
  methodPreferences: {
    convenienceStorePickup: number
    homeDelivery: number
    postOfficeDelivery: number
  }
  
  // 地區配送分析
  regionalAnalysis: {
    region: string
    orderVolume: number
    averageDeliveryTime: number
    shippingCostPerOrder: number
  }[]
}
```

#### 6.2 預測性分析
```typescript
class LogisticsPredictiveAnalytics {
  // 配送需求預測
  predictDeliveryDemand(dateRange: DateRange): DeliveryDemandForecast {
    return {
      expectedOrderVolume: this.forecastOrderVolume(dateRange),
      peakDeliveryDates: this.identifyPeakDeliveryDates(dateRange),
      resourceRequirements: this.calculateResourceNeeds(dateRange),
      costProjection: this.projectShippingCosts(dateRange)
    }
  }
  
  // 物流異常預警
  detectLogisticsAnomalies(): LogisticsAnomalyAlert[] {
    return [
      this.detectUnusualDeliveryDelays(),
      this.detectHighReturnRates(),
      this.detectCostAnomalies(),
      this.detectCapacityIssues()
    ].flat()
  }
}
```

### 7. 後台管理介面

#### 7.1 物流管理控制台
```typescript
interface LogisticsManagementUI {
  // 物流總覽頁面
  logisticsOverview: {
    components: [
      'DailyLogisticsStats',
      'ActiveShipmentMap',
      'LogisticsPerformanceChart',
      'AlertPanel'
    ]
  }
  
  // 配送管理頁面
  shipmentManagement: {
    components: [
      'PendingShipmentsList',
      'BatchShippingLabels',
      'ShipmentTrackingTable', 
      'DeliveryExceptions'
    ]
  }
  
  // 退貨管理頁面
  returnManagement: {
    components: [
      'ReturnRequestsList',
      'ReturnInspectionQueue',
      'RefundProcessingQueue',
      'ReturnAnalytics'
    ]
  }
  
  // 設定頁面
  settingsPage: {
    sections: [
      'ShippingRateConfig',
      'ReturnPolicySettings',
      'NotificationSettings',
      'ECPayIntegrationConfig'
    ]
  }
}
```

### 8. API 介面規格

#### 8.1 後台API (Admin Panel)
```typescript
// 物流管理API
GET /admin/api/logistics/shipments
GET /admin/api/logistics/shipments/:id
POST /admin/api/logistics/shipments
PUT /admin/api/logistics/shipments/:id
DELETE /admin/api/logistics/shipments/:id

// 運費設定API
GET /admin/api/logistics/shipping-rates
POST /admin/api/logistics/shipping-rates
PUT /admin/api/logistics/shipping-rates/:id

// 退貨管理API
GET /admin/api/logistics/returns
POST /admin/api/logistics/returns/:id/approve
POST /admin/api/logistics/returns/:id/reject
POST /admin/api/logistics/returns/:id/process-refund

// 綠界整合API
POST /admin/api/logistics/ecpay/create-logistics
GET /admin/api/logistics/ecpay/query/:logisticsId
POST /admin/api/logistics/ecpay/print-label/:logisticsId
```

#### 8.2 前台API (Customer Site)
```typescript
// 運費計算API
POST /api/logistics/calculate-shipping
Body: {
  items: CartItem[]
  destination: Address
  logisticsType?: ECPayLogisticsType
}

// 物流追蹤API
GET /api/logistics/tracking/:orderId
Headers: { Authorization: string }

// 退貨申請API
POST /api/logistics/returns/create
Body: ReturnRequest
Headers: { Authorization: string }

// 可用物流方式查詢API
GET /api/logistics/available-methods
Query: {
  totalWeight: number
  totalVolume: number
  destination: string
  orderAmount: number
}
```

#### 8.3 綠界Webhook API
```typescript
// 綠界物流狀態更新接收
POST /api/webhooks/ecpay/logistics-status
Body: ECPayWebhookData

// 綠界退貨狀態更新接收  
POST /api/webhooks/ecpay/return-status
Body: ECPayReturnWebhookData
```

### 9. 資料庫設計

#### 9.1 核心資料表
```sql
-- 物流配送單表
CREATE TABLE logistics_shipments (
  id VARCHAR(36) PRIMARY KEY,
  order_id VARCHAR(36) NOT NULL,
  merchant_trade_no VARCHAR(100) UNIQUE NOT NULL,
  ecpay_logistics_id VARCHAR(100) UNIQUE,
  logistics_type VARCHAR(50) NOT NULL,
  logistics_sub_type VARCHAR(50),
  status VARCHAR(50) NOT NULL DEFAULT 'created',
  sender_info JSON NOT NULL,
  receiver_info JSON NOT NULL,
  package_info JSON NOT NULL,
  goods_amount DECIMAL(12,2) NOT NULL,
  shipping_fee DECIMAL(10,2) NOT NULL,
  estimated_delivery_date DATE,
  actual_delivery_date DATE,
  tracking_number VARCHAR(100),
  store_info JSON,
  special_instructions TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,
  INDEX idx_shipments_order_id (order_id),
  INDEX idx_shipments_status (status),
  INDEX idx_shipments_logistics_id (ecpay_logistics_id),
  INDEX idx_shipments_tracking (tracking_number)
);

-- 物流狀態歷程表
CREATE TABLE logistics_status_history (
  id VARCHAR(36) PRIMARY KEY,
  shipment_id VARCHAR(36) NOT NULL,
  status VARCHAR(50) NOT NULL,
  timestamp TIMESTAMP NOT NULL,
  location VARCHAR(255),
  description TEXT,
  operator_id VARCHAR(36),
  raw_data JSON,
  
  FOREIGN KEY (shipment_id) REFERENCES logistics_shipments(id) ON DELETE CASCADE,
  INDEX idx_status_history_shipment (shipment_id),
  INDEX idx_status_history_timestamp (timestamp)
);

-- 運費計算規則表
CREATE TABLE shipping_rate_configs (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  logistics_types JSON NOT NULL,
  calculation_methods JSON NOT NULL,
  rate_rules JSON NOT NULL,
  special_conditions JSON,
  is_active BOOLEAN DEFAULT TRUE,
  priority INT DEFAULT 0,
  valid_from DATE,
  valid_until DATE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  INDEX idx_shipping_rates_active (is_active),
  INDEX idx_shipping_rates_validity (valid_from, valid_until)
);

-- 退換貨物流表
CREATE TABLE return_logistics (
  id VARCHAR(36) PRIMARY KEY,
  return_request_id VARCHAR(36) NOT NULL,
  original_shipment_id VARCHAR(36),
  return_method VARCHAR(50) NOT NULL,
  return_logistics_id VARCHAR(100),
  return_tracking_number VARCHAR(100),
  return_shipping_fee DECIMAL(10,2) NOT NULL DEFAULT 0,
  fee_responsibility VARCHAR(20) NOT NULL,
  status VARCHAR(50) NOT NULL DEFAULT 'created',
  instructions TEXT,
  expected_return_date DATE,
  actual_return_date DATE,
  processing_notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (return_request_id) REFERENCES return_requests(id) ON DELETE CASCADE,
  FOREIGN KEY (original_shipment_id) REFERENCES logistics_shipments(id),
  INDEX idx_return_logistics_request (return_request_id),
  INDEX idx_return_logistics_status (status)
);
```

## 整合規格

### 與訂單管理整合
- 訂單確認後自動建立物流單
- 物流狀態變更自動更新訂單狀態
- 支援分批出貨的物流處理

### 與庫存管理整合
- 出貨時自動扣減庫存
- 退貨驗收後自動回復庫存
- 物流異常時的庫存保護機制

### 與金流系統整合
- 貨到付款的金流物流協調
- 退款時的物流費用處理
- 跨境交易的稅額計算

### 與會員系統整合  
- 會員等級的運費優惠
- VIP會員的特殊物流服務
- 會員地址簿的物流地址管理

### 與贈品管理整合
- 贈品與商品的合併包裝
- 贈品重量體積的運費計算
- 贈品退貨的特殊處理

### 與行銷活動整合
- 滿額免運的活動設定
- 節慶期間的物流促銷
- 特殊活動的物流支援

## 效能考量

### 快取策略
- 運費計算結果快取 (TTL: 1小時)
- 物流業者門市資料快取 (TTL: 24小時) 
- 物流狀態查詢快取 (TTL: 30分鐘)

### 效能目標
- 運費計算響應時間 < 100ms
- 物流單建立時間 < 500ms
- 狀態更新處理時間 < 200ms
- 批量操作處理效率 > 1000筆/分鐘

### 可靠性設計
- 綠界API呼叫重試機制
- 物流單建立失敗的回滾處理
- Webhook接收的冪等性保證
- 物流資料的備份與恢復

## 測試策略

### 單元測試
- 運費計算邏輯測試
- 物流狀態轉換邏輯
- 退貨費用計算邏輯

### 整合測試
- 綠界API整合測試
- Webhook接收處理測試
- 訂單物流流程測試

### 效能測試
- 高併發運費計算
- 大量物流單建立
- Webhook高頻率接收處理

---

本模組確保與綠界ECPay物流服務的完整整合，提供靈活的運費計算、即時的物流追蹤，以及完善的退換貨處理機制，同時支援多種計費方式和智能優化功能。