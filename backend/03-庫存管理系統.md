# åº«å­˜ç®¡ç†ç³»çµ±

## ç³»çµ±æ¦‚è¦½

å®Œæ•´çš„åº«å­˜ç®¡ç†ç³»çµ±ï¼Œæ”¯æ´å¤šå€‰åº«ç®¡ç†ã€å¤šç¨®æˆæœ¬è¨ˆç®—æ–¹æ³•ã€éšå±¤å¼åº«å­˜å±•ç¤ºã€å®Œæ•´çš„å…¥å‡ºåº«å–®æ“šæµç¨‹ã€ç¶ ç•Œç‰©æµæ•´åˆï¼Œä»¥åŠèˆ‡18å€‹å¾Œå°æ¨¡çµ„çš„æ·±åº¦æ•´åˆã€‚

## æ ¸å¿ƒç‰¹æ€§

- **å¤šå€‰åº«æ”¯æ´**: æ”¯æ´å‹•æ…‹æ–°å¢å€‰åº«ï¼Œå¤šå€‰åº«åº«å­˜ç®¡ç†
- **å¤šæˆæœ¬è¨ˆç®—**: FIFOã€LIFOã€åŠ æ¬Šå¹³å‡æˆæœ¬è¨ˆç®—æ–¹æ³•
- **éšå±¤å¼å±•ç¤º**: å•†å“/è´ˆå“æ”¶åˆåˆ—è¡¨ï¼Œè®Šé«”åº«å­˜è‡ªå‹•åŠ ç¸½
- **å®Œæ•´å–®æ“šæµç¨‹**: å…¥åº«å–®ã€æ€è²¨å–®ã€å‡ºè²¨å–®ã€è³ªæª¢å–®
- **ç¶ ç•Œç‰©æµæ•´åˆ**: è‡ªå‹•å»ºç«‹ç‰©æµè¨‚å–®ã€ç‹€æ…‹åŒæ­¥
- **é å”®æ”¯æ´**: æ”¯æ´é è³¼åŠŸèƒ½ï¼Œå…è¨±è² åº«å­˜éŠ·å”®
- **æ¢ç¢¼æƒæ**: æ”¯æ´QR Code/æ¢ç¢¼æƒæå…¥å‡ºåº«
- **æ™ºèƒ½è­¦ç¤º**: å¯è¨­å®šçš„ä½åº«å­˜è­¦ç¤ºé‚è¼¯
- **18æ¨¡çµ„æ•´åˆ**: èˆ‡æ‰€æœ‰å¾Œå°æ¨¡çµ„æ·±åº¦æ•´åˆ

## è³‡æ–™åº«è¨­è¨ˆ

### warehouses è¡¨ (å€‰åº«è³‡è¨Š)
```sql
CREATE TABLE warehouses (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name VARCHAR(100) NOT NULL,              -- å€‰åº«åç¨±
  code VARCHAR(20) UNIQUE NOT NULL,        -- å€‰åº«ä»£ç¢¼
  address TEXT,                            -- å€‰åº«åœ°å€
  manager_name VARCHAR(50),                -- å€‰åº«ç®¡ç†å“¡
  contact_phone VARCHAR(20),               -- è¯çµ¡é›»è©±
  is_active BOOLEAN DEFAULT TRUE,          -- æ˜¯å¦å•Ÿç”¨
  is_default BOOLEAN DEFAULT FALSE,        -- æ˜¯å¦ç‚ºé è¨­å€‰åº«
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### inventory è¡¨ (åº«å­˜ä¸»è¡¨)
```sql
CREATE TABLE inventory (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,           -- å€‰åº«ID
  sku_id INTEGER NOT NULL,                 -- SKU ID (åŒ…å«å•†å“å’Œè´ˆå“)
  current_stock INTEGER DEFAULT 0,         -- ç•¶å‰åº«å­˜æ•¸é‡
  reserved_stock INTEGER DEFAULT 0,        -- é ç•™åº«å­˜ (è³¼ç‰©è»Š)
  available_stock INTEGER GENERATED ALWAYS AS (current_stock - reserved_stock) STORED, -- å¯ç”¨åº«å­˜
  safe_stock INTEGER DEFAULT 0,            -- å®‰å…¨åº«å­˜æ°´ä½
  max_stock INTEGER DEFAULT 1000,          -- æœ€å¤§åº«å­˜é™åˆ¶
  allow_negative_stock BOOLEAN DEFAULT FALSE, -- æ˜¯å¦å…è¨±è² åº«å­˜(é å”®)
  
  -- æˆæœ¬è³‡è¨Š
  total_cost DECIMAL(12,2) DEFAULT 0,      -- ç¸½æˆæœ¬
  average_cost DECIMAL(10,2) DEFAULT 0,    -- å¹³å‡æˆæœ¬
  
  -- ç‹€æ…‹
  last_in_date DATETIME,                   -- æœ€å¾Œé€²è²¨æ—¥æœŸ
  last_out_date DATETIME,                  -- æœ€å¾Œå‡ºè²¨æ—¥æœŸ
  last_count_date DATETIME,                -- æœ€å¾Œç›¤é»æ—¥æœŸ
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  UNIQUE(warehouse_id, sku_id)
);
```

### inventory_transactions è¡¨ (åº«å­˜ç•°å‹•è¨˜éŒ„)
```sql
CREATE TABLE inventory_transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  transaction_type ENUM(
    'in_purchase',      -- æ¡è³¼å…¥åº«
    'in_return',        -- é€€è²¨å…¥åº«
    'in_adjustment',    -- ç›¤é»èª¿å¢
    'in_transfer',      -- èª¿æ’¥å…¥åº«
    'out_sale',         -- éŠ·å”®å‡ºåº«
    'out_damaged',      -- æè€—å‡ºåº«
    'out_adjustment',   -- ç›¤é»èª¿æ¸›
    'out_transfer',     -- èª¿æ’¥å‡ºåº«
    'reserve',          -- é ç•™åº«å­˜
    'release'           -- é‡‹æ”¾é ç•™
  ) NOT NULL,
  
  quantity INTEGER NOT NULL,               -- ç•°å‹•æ•¸é‡ (æ­£æ•¸=å…¥åº«ï¼Œè² æ•¸=å‡ºåº«)
  unit_cost DECIMAL(10,2),                -- å–®ä½æˆæœ¬ (å…¥åº«æ™‚è¨˜éŒ„)
  total_cost DECIMAL(12,2),               -- ç¸½æˆæœ¬
  
  -- é—œè¯è³‡è¨Š
  reference_type VARCHAR(50),              -- é—œè¯é¡å‹ (order, purchase, inbound_order)
  reference_id INTEGER,                    -- é—œè¯ID
  
  -- åº«å­˜ç‹€æ…‹å¿«ç…§
  stock_before INTEGER NOT NULL,          -- ç•°å‹•å‰åº«å­˜
  stock_after INTEGER NOT NULL,           -- ç•°å‹•å¾Œåº«å­˜
  
  note TEXT,                              -- å‚™è¨»
  operator_id INTEGER NOT NULL,           -- æ“ä½œäººå“¡ID
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  FOREIGN KEY (operator_id) REFERENCES admin_users(id)
);
```

### inventory_batches è¡¨ (åº«å­˜æ‰¹æ¬¡ç®¡ç†)
```sql
CREATE TABLE inventory_batches (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  batch_number VARCHAR(50) NOT NULL,       -- æ‰¹æ¬¡è™Ÿ
  
  -- æ‰¹æ¬¡è³‡è¨Š
  original_quantity INTEGER NOT NULL,     -- åŸå§‹æ•¸é‡
  remaining_quantity INTEGER NOT NULL,    -- å‰©é¤˜æ•¸é‡
  unit_cost DECIMAL(10,2) NOT NULL,       -- æ‰¹æ¬¡å–®ä½æˆæœ¬
  
  -- æ—¥æœŸè³‡è¨Š
  received_date DATETIME NOT NULL,        -- åˆ°è²¨æ—¥æœŸ
  expiry_date DATETIME,                   -- éæœŸæ—¥æœŸ (å¦‚é©ç”¨)
  
  -- é—œè¯è³‡è¨Š
  purchase_order_id INTEGER,             -- æ¡è³¼å–®ID
  supplier_id INTEGER,                   -- ä¾›æ‡‰å•†ID
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  UNIQUE(warehouse_id, sku_id, batch_number)
);
```

### cost_calculation_methods è¡¨ (æˆæœ¬è¨ˆç®—æ–¹æ³•)
```sql
CREATE TABLE cost_calculation_methods (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER,                             -- NULL = å…¨å€‰åº«é è¨­
  method ENUM('fifo', 'lifo', 'weighted_average') NOT NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  UNIQUE(warehouse_id, sku_id)
);
```

### inbound_orders è¡¨ (å…¥åº«å–®)
```sql
CREATE TABLE inbound_orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  order_number VARCHAR(50) UNIQUE NOT NULL,    -- å…¥åº«å–®è™Ÿ (æ ¼å¼: IB20240301001)
  warehouse_id INTEGER NOT NULL,
  order_type ENUM('purchase', 'return', 'adjustment', 'transfer') NOT NULL,
  source_type VARCHAR(50),                     -- ä¾†æºé¡å‹ (purchase_order, return_request)
  source_id INTEGER,                          -- ä¾†æºID
  
  -- ç‹€æ…‹æ§åˆ¶
  status ENUM('draft', 'pending', 'approved', 'completed', 'cancelled') DEFAULT 'draft',
  total_quantity INTEGER DEFAULT 0,
  total_cost DECIMAL(12,2) DEFAULT 0,
  
  -- å¯©æ ¸è³‡è¨Š
  created_by INTEGER NOT NULL,
  approved_by INTEGER,
  completed_by INTEGER,
  
  -- æ™‚é–“æˆ³è¨˜
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  approved_at DATETIME,
  completed_at DATETIME,
  
  notes TEXT,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (created_by) REFERENCES admin_users(id),
  FOREIGN KEY (approved_by) REFERENCES admin_users(id),
  FOREIGN KEY (completed_by) REFERENCES admin_users(id)
);
```

### inbound_order_items è¡¨ (å…¥åº«å–®æ˜ç´°)
```sql
CREATE TABLE inbound_order_items (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  inbound_order_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  batch_number VARCHAR(50) NOT NULL,
  
  planned_quantity INTEGER NOT NULL,           -- è¨ˆåŠƒå…¥åº«æ•¸é‡
  actual_quantity INTEGER DEFAULT 0,          -- å¯¦éš›å…¥åº«æ•¸é‡
  unit_cost DECIMAL(10,2) NOT NULL,
  total_cost DECIMAL(12,2) GENERATED ALWAYS AS (actual_quantity * unit_cost) STORED,
  
  -- è³ªæª¢è³‡è¨Š (é€€è²¨å…¥åº«ç”¨)
  quality_check_status ENUM('pending', 'passed', 'failed', 'not_required') DEFAULT 'not_required',
  quality_check_by INTEGER,
  quality_check_at DATETIME,
  quality_notes TEXT,
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (inbound_order_id) REFERENCES inbound_orders(id) ON DELETE CASCADE,
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  FOREIGN KEY (quality_check_by) REFERENCES admin_users(id)
);
```

### picking_orders è¡¨ (æ€è²¨å–®)
```sql
CREATE TABLE picking_orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  picking_number VARCHAR(50) UNIQUE NOT NULL,  -- æ€è²¨å–®è™Ÿ (æ ¼å¼: PK20240301001)
  warehouse_id INTEGER NOT NULL,
  order_id INTEGER NOT NULL,                  -- é—œè¯è¨‚å–®ID
  
  status ENUM('pending', 'picking', 'completed', 'cancelled') DEFAULT 'pending',
  total_items INTEGER DEFAULT 0,
  picked_items INTEGER DEFAULT 0,
  
  -- æ€è²¨äººå“¡
  picker_id INTEGER,
  picking_started_at DATETIME,
  picking_completed_at DATETIME,
  
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  notes TEXT,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (picker_id) REFERENCES admin_users(id)
);
```

### picking_order_items è¡¨ (æ€è²¨å–®æ˜ç´°)
```sql
CREATE TABLE picking_order_items (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  picking_order_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  
  required_quantity INTEGER NOT NULL,         -- éœ€è¦æ€è²¨æ•¸é‡
  picked_quantity INTEGER DEFAULT 0,         -- å·²æ€è²¨æ•¸é‡
  
  -- æƒç¢¼è¨˜éŒ„
  scanned_at DATETIME,
  scanned_by INTEGER,
  batch_numbers JSON,                         -- æƒæçš„æ‰¹æ¬¡è™Ÿè¨˜éŒ„
  
  FOREIGN KEY (picking_order_id) REFERENCES picking_orders(id) ON DELETE CASCADE,
  FOREIGN KEY (sku_id) REFERENCES product_skus(id),
  FOREIGN KEY (scanned_by) REFERENCES admin_users(id)
);
```

### outbound_orders è¡¨ (å‡ºè²¨å–®)
```sql
CREATE TABLE outbound_orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  outbound_number VARCHAR(50) UNIQUE NOT NULL, -- å‡ºè²¨å–®è™Ÿ (æ ¼å¼: OB20240301001)
  warehouse_id INTEGER NOT NULL,
  order_id INTEGER NOT NULL,
  picking_order_id INTEGER,
  
  status ENUM('pending', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
  
  -- ç‰©æµè³‡è¨Š
  logistics_provider VARCHAR(50) DEFAULT 'ecpay', -- ç‰©æµå•† (ecpay)
  tracking_number VARCHAR(100),               -- è¿½è¹¤è™Ÿç¢¼
  shipping_method VARCHAR(50),                -- é…é€æ–¹å¼
  
  -- ç¶ ç•Œç‰©æµæ•´åˆ
  ecpay_logistics_id VARCHAR(100),           -- ç¶ ç•Œç‰©æµå–®è™Ÿ
  ecpay_status VARCHAR(50),                  -- ç¶ ç•Œç‹€æ…‹
  last_sync_at DATETIME,                     -- æœ€å¾ŒåŒæ­¥æ™‚é–“
  
  -- æ”¶ä»¶è³‡è¨Š
  recipient_name VARCHAR(100),
  recipient_phone VARCHAR(20),
  shipping_address TEXT,
  
  -- æ™‚é–“æˆ³è¨˜
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  shipped_at DATETIME,
  delivered_at DATETIME,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (picking_order_id) REFERENCES picking_orders(id)
);
```

### inventory_alerts è¡¨ (åº«å­˜è­¦ç¤º)
```sql
CREATE TABLE inventory_alerts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  alert_type ENUM('low_stock', 'out_of_stock', 'overstock', 'expiry_warning') NOT NULL,
  current_stock INTEGER NOT NULL,
  threshold_value INTEGER,                -- è§¸ç™¼é–¾å€¼
  alert_message TEXT NOT NULL,
  is_resolved BOOLEAN DEFAULT FALSE,
  resolved_at DATETIME,
  resolved_by INTEGER,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  FOREIGN KEY (resolved_by) REFERENCES admin_users(id)
);
```

### inventory_counts è¡¨ (ç›¤é»è¨˜éŒ„)
```sql
CREATE TABLE inventory_counts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  warehouse_id INTEGER NOT NULL,
  count_date DATE NOT NULL,
  status ENUM('planning', 'in_progress', 'completed', 'cancelled') DEFAULT 'planning',
  total_skus INTEGER DEFAULT 0,           -- ç›¤é»SKUç¸½æ•¸
  completed_skus INTEGER DEFAULT 0,       -- å·²å®ŒæˆSKUæ•¸
  discrepancy_count INTEGER DEFAULT 0,    -- å·®ç•°é …ç›®æ•¸
  
  -- ç›¤é»è¨­å®š
  is_blind_count BOOLEAN DEFAULT FALSE,   -- æ˜¯å¦ç›²ç›¤ (ç³»çµ±è¨­å®š)
  count_type ENUM('full', 'cycle', 'spot') DEFAULT 'full', -- ç›¤é»é¡å‹
  
  -- æ“ä½œäººå“¡
  created_by INTEGER NOT NULL,
  started_by INTEGER,
  completed_by INTEGER,
  
  notes TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  started_at DATETIME,
  completed_at DATETIME,
  
  FOREIGN KEY (warehouse_id) REFERENCES warehouses(id),
  FOREIGN KEY (created_by) REFERENCES admin_users(id),
  FOREIGN KEY (started_by) REFERENCES admin_users(id),
  FOREIGN KEY (completed_by) REFERENCES admin_users(id)
);
```

### inventory_count_details è¡¨ (ç›¤é»æ˜ç´°)
```sql
CREATE TABLE inventory_count_details (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  count_id INTEGER NOT NULL,
  sku_id INTEGER NOT NULL,
  
  -- ç›¤é»è³‡æ–™
  system_quantity INTEGER NOT NULL,       -- ç³»çµ±åº«å­˜æ•¸é‡
  actual_quantity INTEGER,                -- å¯¦éš›ç›¤é»æ•¸é‡
  difference_quantity INTEGER GENERATED ALWAYS AS (actual_quantity - system_quantity) STORED,
  
  -- æˆæœ¬è³‡è¨Š
  unit_cost DECIMAL(10,2) NOT NULL,
  cost_difference DECIMAL(12,2) GENERATED ALWAYS AS (difference_quantity * unit_cost) STORED,
  
  -- ç›¤é»ç‹€æ…‹
  status ENUM('pending', 'counted', 'adjusted') DEFAULT 'pending',
  note TEXT,
  counted_by INTEGER,
  counted_at DATETIME,
  
  FOREIGN KEY (count_id) REFERENCES inventory_counts(id) ON DELETE CASCADE,
  FOREIGN KEY (sku_id) REFERENCES product_skus(id) ON DELETE CASCADE,
  FOREIGN KEY (counted_by) REFERENCES admin_users(id),
  UNIQUE(count_id, sku_id)
);
```

## æ ¸å¿ƒæ¥­å‹™é‚è¼¯

### åº«å­˜ç®¡ç†å™¨ä¸»é¡
```javascript
// services/InventoryManager.js
import { FIFOCalculator } from './cost-calculators/FIFOCalculator'
import { LIFOCalculator } from './cost-calculators/LIFOCalculator'
import { WeightedAverageCalculator } from './cost-calculators/WeightedAverageCalculator'
import { EcpayLogisticsService } from './EcpayLogisticsService'

export class InventoryManager {
  constructor(db) {
    this.db = db
    this.costCalculators = {
      'fifo': new FIFOCalculator(db),
      'lifo': new LIFOCalculator(db),
      'weighted_average': new WeightedAverageCalculator(db)
    }
    this.ecpayLogistics = new EcpayLogisticsService()
  }

  /**
   * æ”¯æ´é å”®çš„åº«å­˜æª¢æŸ¥
   */
  async checkStockAvailabilityForPreorder(skuId, quantity, warehouseId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    const inventory = await this.db.prepare(`
      SELECT 
        i.available_stock, 
        i.reserved_stock, 
        i.allow_negative_stock,
        ps.sku,
        CASE 
          WHEN ps.product_id IS NOT NULL THEN 'product'
          ELSE 'gift'
        END as item_type
      FROM inventory i
      LEFT JOIN product_skus ps ON i.sku_id = ps.id
      LEFT JOIN gift_skus gs ON i.sku_id = gs.id
      WHERE i.sku_id = ? AND i.warehouse_id = ?
    `).bind(skuId, warehouse.id).first()

    if (!inventory) {
      return { available: false, reason: 'SKUä¸å­˜åœ¨æ–¼æŒ‡å®šå€‰åº«' }
    }

    // æ”¯æ´é å”®ï¼šå…è¨±è² åº«å­˜
    if (inventory.allow_negative_stock || inventory.available_stock >= quantity) {
      return { 
        available: true, 
        currentStock: inventory.available_stock,
        isPreorder: inventory.available_stock < quantity,
        itemType: inventory.item_type
      }
    }

    return {
      available: false,
      reason: 'åº«å­˜ä¸è¶³ä¸”ä¸å…è¨±é å”®',
      currentStock: inventory.available_stock
    }
  }

  /**
   * é ç•™åº«å­˜ (è³¼ç‰©è»ŠåŠ å…¥å•†å“æ™‚)
   * é ç•™æ™‚æ•ˆç”±ç³»çµ±è¨­å®šæ±ºå®š
   */
  async reserveStock(skuId, quantity, sessionId, warehouseId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    // æª¢æŸ¥åº«å­˜æ˜¯å¦å……è¶³ (æ”¯æ´é å”®)
    const stockCheck = await this.checkStockAvailabilityForPreorder(skuId, quantity, warehouse.id)
    if (!stockCheck.available) {
      throw new Error(`ç„¡æ³•é ç•™åº«å­˜: ${stockCheck.reason}`)
    }

    const transaction = this.db.transaction(async () => {
      // æ›´æ–°åº«å­˜é ç•™æ•¸é‡
      await this.db.prepare(`
        UPDATE inventory 
        SET reserved_stock = reserved_stock + ?,
            updated_at = CURRENT_TIMESTAMP
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(quantity, skuId, warehouse.id).run()

      // è¨˜éŒ„ç•°å‹•
      await this.recordTransaction({
        warehouseId: warehouse.id,
        skuId,
        type: 'reserve',
        quantity: -quantity, // è² æ•¸è¡¨ç¤ºé ç•™
        referenceType: 'cart_session',
        referenceId: sessionId,
        note: `è³¼ç‰©è»Šé ç•™åº«å­˜ (Session: ${sessionId})${stockCheck.isPreorder ? ' - é å”®' : ''}`
      })

      // æª¢æŸ¥æ˜¯å¦éœ€è¦å‰µå»ºä½åº«å­˜è­¦ç¤º
      await this.checkAndCreateAlerts(warehouse.id, skuId)
    })

    await transaction()
    
    console.log(`âœ… åº«å­˜é ç•™æˆåŠŸ: SKU ${skuId}, æ•¸é‡ ${quantity}${stockCheck.isPreorder ? ' (é å”®)' : ''}`)
    return { success: true, isPreorder: stockCheck.isPreorder }
  }

  /**
   * æ ¹æ“šè¨­å®šçš„è¨ˆç®—æ–¹æ³•è™•ç†å‡ºåº«æˆæœ¬
   */
  async processStockOutWithMethod(warehouseId, skuId, quantity) {
    // ç²å–è©²SKUçš„æˆæœ¬è¨ˆç®—æ–¹æ³• (SKUç‰¹å®šè¨­å®šå„ªå…ˆæ–¼å€‰åº«é è¨­)
    const method = await this.db.prepare(`
      SELECT method FROM cost_calculation_methods
      WHERE warehouse_id = ? AND (sku_id = ? OR sku_id IS NULL)
        AND is_active = TRUE
      ORDER BY sku_id DESC
      LIMIT 1
    `).bind(warehouseId, skuId).first()

    const calculationMethod = method?.method || 'fifo'
    const calculator = this.costCalculators[calculationMethod]
    
    console.log(`ğŸ’° ä½¿ç”¨ ${calculationMethod.toUpperCase()} æˆæœ¬è¨ˆç®—æ–¹æ³•`)
    return await calculator.calculateStockOut(warehouseId, skuId, quantity)
  }

  /**
   * å»ºç«‹å…¥åº«å–® (å¾æ¡è³¼å–®è‡ªå‹•è½‰æ›)
   */
  async createInboundOrderFromPurchase(purchaseOrderId, warehouseId, createdBy) {
    const transaction = this.db.transaction(async () => {
      // ç”Ÿæˆå…¥åº«å–®è™Ÿ
      const orderNumber = await this.generateOrderNumber('IB')
      
      // å‰µå»ºå…¥åº«å–®
      const inboundResult = await this.db.prepare(`
        INSERT INTO inbound_orders 
        (order_number, warehouse_id, order_type, source_type, source_id, status, created_by)
        VALUES (?, ?, 'purchase', 'purchase_order', ?, 'pending', ?)
      `).bind(orderNumber, warehouseId, purchaseOrderId, createdBy).run()

      const inboundOrderId = inboundResult.meta.last_row_id

      // å¾æ¡è³¼å–®è¤‡è£½å•†å“æ˜ç´° (åŒ…å«å•†å“å’Œè´ˆå“)
      const purchaseItems = await this.db.prepare(`
        SELECT sku_id, quantity, unit_cost, batch_number
        FROM purchase_order_items
        WHERE purchase_order_id = ?
      `).bind(purchaseOrderId).all()

      let totalQuantity = 0
      let totalCost = 0

      for (const item of purchaseItems) {
        await this.db.prepare(`
          INSERT INTO inbound_order_items
          (inbound_order_id, sku_id, batch_number, planned_quantity, unit_cost)
          VALUES (?, ?, ?, ?, ?)
        `).bind(
          inboundOrderId, item.sku_id, item.batch_number, 
          item.quantity, item.unit_cost
        ).run()

        totalQuantity += item.quantity
        totalCost += item.quantity * item.unit_cost
      }

      // æ›´æ–°å…¥åº«å–®ç¸½è¨ˆ
      await this.db.prepare(`
        UPDATE inbound_orders
        SET total_quantity = ?, total_cost = ?
        WHERE id = ?
      `).bind(totalQuantity, totalCost, inboundOrderId).run()

      return { inboundOrderId, orderNumber }
    })

    return await transaction()
  }

  /**
   * ä¸»ç®¡å¯©æ ¸å…¥åº«å–®
   */
  async approveInboundOrder(inboundOrderId, approvedBy) {
    const transaction = this.db.transaction(async () => {
      // æª¢æŸ¥å…¥åº«å–®ç‹€æ…‹
      const inboundOrder = await this.db.prepare(`
        SELECT * FROM inbound_orders WHERE id = ? AND status = 'pending'
      `).bind(inboundOrderId).first()

      if (!inboundOrder) {
        throw new Error('å…¥åº«å–®ä¸å­˜åœ¨æˆ–ç‹€æ…‹ä¸æ­£ç¢º')
      }

      // æ›´æ–°å…¥åº«å–®ç‹€æ…‹
      await this.db.prepare(`
        UPDATE inbound_orders
        SET status = 'approved', approved_by = ?, approved_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(approvedBy, inboundOrderId).run()

      // è‡ªå‹•åŸ·è¡Œå…¥åº«
      await this.executeInboundOrder(inboundOrderId, approvedBy)
    })

    await transaction()
    console.log(`âœ… å…¥åº«å–® ${inboundOrderId} å¯©æ ¸é€šéä¸¦å·²å…¥åº«`)
  }

  /**
   * åŸ·è¡Œå…¥åº«æ“ä½œ
   */
  async executeInboundOrder(inboundOrderId, operatorId) {
    const inboundOrder = await this.db.prepare(`
      SELECT * FROM inbound_orders WHERE id = ?
    `).bind(inboundOrderId).first()

    const items = await this.db.prepare(`
      SELECT * FROM inbound_order_items 
      WHERE inbound_order_id = ?
        AND (quality_check_status = 'not_required' OR quality_check_status = 'passed')
    `).bind(inboundOrderId).all()

    const transaction = this.db.transaction(async () => {
      for (const item of items) {
        // åŸ·è¡Œåº«å­˜å…¥åº«
        await this.stockIn(
          item.sku_id,
          item.planned_quantity,
          item.unit_cost,
          item.batch_number,
          inboundOrder.warehouse_id,
          'inbound_order',
          inboundOrderId
        )

        // æ›´æ–°å…¥åº«å–®æ˜ç´°å¯¦éš›æ•¸é‡
        await this.db.prepare(`
          UPDATE inbound_order_items
          SET actual_quantity = planned_quantity
          WHERE id = ?
        `).bind(item.id).run()
      }

      // æ›´æ–°å…¥åº«å–®ç‹€æ…‹ç‚ºå·²å®Œæˆ
      await this.db.prepare(`
        UPDATE inbound_orders
        SET status = 'completed', completed_by = ?, completed_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(operatorId, inboundOrderId).run()
    })

    await transaction()
    console.log(`ğŸ“¥ å…¥åº«å–® ${inboundOrderId} åŸ·è¡Œå®Œæˆ`)
  }

  /**
   * å¾è¨‚å–®è‡ªå‹•å»ºç«‹æ€è²¨å–®
   */
  async createPickingOrderFromOrder(orderId, warehouseId) {
    const transaction = this.db.transaction(async () => {
      const pickingNumber = await this.generateOrderNumber('PK')
      
      // å‰µå»ºæ€è²¨å–®
      const pickingResult = await this.db.prepare(`
        INSERT INTO picking_orders
        (picking_number, warehouse_id, order_id, status)
        VALUES (?, ?, ?, 'pending')
      `).bind(pickingNumber, warehouseId, orderId).run()

      const pickingOrderId = pickingResult.meta.last_row_id

      // å¾è¨‚å–®è¤‡è£½å•†å“æ˜ç´° (åŒ…å«å•†å“å’Œè´ˆå“)
      const orderItems = await this.db.prepare(`
        SELECT sku_id, quantity FROM order_items WHERE order_id = ?
      `).bind(orderId).all()

      let totalItems = 0
      for (const item of orderItems) {
        await this.db.prepare(`
          INSERT INTO picking_order_items
          (picking_order_id, sku_id, required_quantity)
          VALUES (?, ?, ?)
        `).bind(pickingOrderId, item.sku_id, item.quantity).run()
        
        totalItems++
      }

      // æ›´æ–°æ€è²¨å–®ç¸½é …ç›®æ•¸
      await this.db.prepare(`
        UPDATE picking_orders SET total_items = ? WHERE id = ?
      `).bind(totalItems, pickingOrderId).run()

      return { pickingOrderId, pickingNumber }
    })

    return await transaction()
  }

  /**
   * æƒç¢¼æ€è²¨ (æ”¯æ´QR Codeå’Œæ¢ç¢¼)
   */
  async scanPickingItem(pickingOrderId, skuId, scannedQuantity, scannedBy, batchNumbers = []) {
    const transaction = this.db.transaction(async () => {
      // æ›´æ–°æ€è²¨æ˜ç´°
      await this.db.prepare(`
        UPDATE picking_order_items
        SET picked_quantity = picked_quantity + ?,
            scanned_at = CURRENT_TIMESTAMP,
            scanned_by = ?,
            batch_numbers = ?
        WHERE picking_order_id = ? AND sku_id = ?
      `).bind(
        scannedQuantity, scannedBy, JSON.stringify(batchNumbers),
        pickingOrderId, skuId
      ).run()

      // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰å•†å“éƒ½å·²æ€è²¨å®Œæˆ
      const completionCheck = await this.db.prepare(`
        SELECT 
          COUNT(*) as total_items,
          COUNT(CASE WHEN picked_quantity >= required_quantity THEN 1 END) as completed_items
        FROM picking_order_items
        WHERE picking_order_id = ?
      `).bind(pickingOrderId).first()

      // æ›´æ–°æ€è²¨å–®é€²åº¦
      await this.db.prepare(`
        UPDATE picking_orders
        SET picked_items = ?
        WHERE id = ?
      `).bind(completionCheck.completed_items, pickingOrderId).run()

      // å¦‚æœå…¨éƒ¨æ€è²¨å®Œæˆï¼Œæ›´æ–°ç‹€æ…‹
      if (completionCheck.completed_items === completionCheck.total_items) {
        await this.db.prepare(`
          UPDATE picking_orders
          SET status = 'completed', picking_completed_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(pickingOrderId).run()

        return { completed: true }
      }

      return { completed: false, progress: `${completionCheck.completed_items}/${completionCheck.total_items}` }
    })

    return await transaction()
  }

  /**
   * å“¡å·¥ç°½æ ¸æ€è²¨å–®ï¼Œè‡ªå‹•è½‰å‡ºè²¨å–®ä¸¦æ•´åˆç¶ ç•Œç‰©æµ
   */
  async confirmPickingAndCreateOutbound(pickingOrderId, employeeId) {
    const transaction = this.db.transaction(async () => {
      const pickingOrder = await this.db.prepare(`
        SELECT po.*, o.recipient_name, o.recipient_phone, o.shipping_address
        FROM picking_orders po
        JOIN orders o ON po.order_id = o.id
        WHERE po.id = ?
      `).bind(pickingOrderId).first()

      // ç”Ÿæˆå‡ºè²¨å–®
      const outboundNumber = await this.generateOrderNumber('OB')
      
      const outboundResult = await this.db.prepare(`
        INSERT INTO outbound_orders
        (outbound_number, warehouse_id, order_id, picking_order_id, status, 
         recipient_name, recipient_phone, shipping_address)
        VALUES (?, ?, ?, ?, 'pending', ?, ?, ?)
      `).bind(
        outboundNumber, pickingOrder.warehouse_id, 
        pickingOrder.order_id, pickingOrderId,
        pickingOrder.recipient_name, pickingOrder.recipient_phone, pickingOrder.shipping_address
      ).run()

      const outboundOrderId = outboundResult.meta.last_row_id

      // å¯¦éš›æ‰£æ¸›åº«å­˜
      const pickingItems = await this.db.prepare(`
        SELECT sku_id, picked_quantity FROM picking_order_items
        WHERE picking_order_id = ?
      `).bind(pickingOrderId).all()

      for (const item of pickingItems) {
        await this.confirmStockOut(
          item.sku_id, item.picked_quantity, 
          pickingOrder.order_id, pickingOrder.warehouse_id
        )
      }

      // å‚³é€åˆ°ç¶ ç•Œç‰©æµ
      const ecpayResult = await this.ecpayLogistics.createShipment({
        outboundOrderId,
        recipientName: pickingOrder.recipient_name,
        recipientPhone: pickingOrder.recipient_phone,
        shippingAddress: pickingOrder.shipping_address,
        items: pickingItems
      })
      
      if (ecpayResult.success) {
        await this.db.prepare(`
          UPDATE outbound_orders
          SET ecpay_logistics_id = ?, 
              tracking_number = ?,
              ecpay_status = 'shipped',
              status = 'shipped',
              shipped_at = CURRENT_TIMESTAMP,
              last_sync_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(
          ecpayResult.logistics_id,
          ecpayResult.tracking_number,
          outboundOrderId
        ).run()

        // åŒæ­¥æ›´æ–°è¨‚å–®ç‹€æ…‹
        await this.db.prepare(`
          UPDATE orders SET status = 'shipped', shipped_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(pickingOrder.order_id).run()
      }

      return { 
        outboundOrderId, 
        outboundNumber, 
        ecpayResult,
        trackingNumber: ecpayResult.tracking_number
      }
    })

    return await transaction()
  }

  /**
   * ç¢ºèªå‡ºåº« (è¨‚å–®æˆåŠŸæ™‚)
   */
  async confirmStockOut(skuId, quantity, orderId, warehouseId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    const transaction = this.db.transaction(async () => {
      // å…ˆé‡‹æ”¾é ç•™ï¼Œå†åŸ·è¡Œå¯¦éš›å‡ºåº«
      await this.db.prepare(`
        UPDATE inventory 
        SET current_stock = current_stock - ?,
            reserved_stock = GREATEST(0, reserved_stock - ?),
            last_out_date = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(quantity, quantity, skuId, warehouse.id).run()

      // ä½¿ç”¨è¨­å®šçš„æ–¹æ³•è¨ˆç®—æˆæœ¬ä¸¦æ›´æ–°æ‰¹æ¬¡
      const totalCost = await this.processStockOutWithMethod(warehouse.id, skuId, quantity)

      // è¨˜éŒ„ç•°å‹•
      await this.recordTransaction({
        warehouseId: warehouse.id,
        skuId,
        type: 'out_sale',
        quantity: -quantity,
        totalCost,
        referenceType: 'order',
        referenceId: orderId,
        note: `è¨‚å–®ç¢ºèªå‡ºåº« (è¨‚å–®: ${orderId})`
      })

      // æª¢æŸ¥åº«å­˜è­¦ç¤º
      await this.checkAndCreateAlerts(warehouse.id, skuId)
    })

    await transaction()
    console.log(`ğŸ“¦ åº«å­˜å‡ºåº«ç¢ºèª: SKU ${skuId}, æ•¸é‡ ${quantity}, è¨‚å–® ${orderId}`)
  }

  /**
   * åº«å­˜å…¥åº«
   */
  async stockIn(skuId, quantity, unitCost, batchNumber, warehouseId = null, referenceType = 'manual', referenceId = null) {
    const warehouse = warehouseId || await this.getDefaultWarehouse()
    
    const transaction = this.db.transaction(async () => {
      // æ›´æ–°ä¸»åº«å­˜
      const currentInventory = await this.db.prepare(`
        SELECT current_stock, total_cost FROM inventory 
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(skuId, warehouse.id).first()

      if (currentInventory) {
        // æ›´æ–°ç¾æœ‰åº«å­˜
        const newTotalCost = currentInventory.total_cost + (quantity * unitCost)
        const newStock = currentInventory.current_stock + quantity
        const newAvgCost = newStock > 0 ? newTotalCost / newStock : 0

        await this.db.prepare(`
          UPDATE inventory 
          SET current_stock = ?,
              total_cost = ?,
              average_cost = ?,
              last_in_date = CURRENT_TIMESTAMP,
              updated_at = CURRENT_TIMESTAMP
          WHERE sku_id = ? AND warehouse_id = ?
        `).bind(newStock, newTotalCost, newAvgCost, skuId, warehouse.id).run()
      } else {
        // å‰µå»ºæ–°åº«å­˜è¨˜éŒ„
        await this.db.prepare(`
          INSERT INTO inventory (warehouse_id, sku_id, current_stock, total_cost, average_cost, last_in_date)
          VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `).bind(warehouse.id, skuId, quantity, quantity * unitCost, unitCost).run()
      }

      // å‰µå»ºæ‰¹æ¬¡è¨˜éŒ„
      await this.db.prepare(`
        INSERT OR IGNORE INTO inventory_batches 
        (warehouse_id, sku_id, batch_number, original_quantity, remaining_quantity, unit_cost, received_date)
        VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      `).bind(warehouse.id, skuId, batchNumber, quantity, quantity, unitCost).run()

      // è¨˜éŒ„ç•°å‹•
      await this.recordTransaction({
        warehouseId: warehouse.id,
        skuId,
        type: 'in_purchase',
        quantity,
        unitCost,
        totalCost: quantity * unitCost,
        referenceType,
        referenceId,
        note: `æ‰¹æ¬¡å…¥åº«: ${batchNumber}`
      })

      // æª¢æŸ¥ä¸¦è§£æ±ºåº«å­˜è­¦ç¤º
      await this.resolveStockAlerts(warehouse.id, skuId)
    })

    await transaction()
    console.log(`ğŸ“¥ åº«å­˜å…¥åº«å®Œæˆ: SKU ${skuId}, æ•¸é‡ ${quantity}, æ‰¹æ¬¡ ${batchNumber}`)
  }

  /**
   * è¨˜éŒ„åº«å­˜ç•°å‹•
   */
  async recordTransaction({ warehouseId, skuId, type, quantity, unitCost = null, totalCost = null, referenceType = null, referenceId = null, note = '', operatorId = 1 }) {
    // ç²å–ç•¶å‰åº«å­˜ä½œç‚ºç•°å‹•å‰å¿«ç…§
    const inventory = await this.db.prepare(`
      SELECT current_stock FROM inventory 
      WHERE warehouse_id = ? AND sku_id = ?
    `).bind(warehouseId, skuId).first()

    const stockBefore = inventory ? inventory.current_stock : 0
    const stockAfter = stockBefore + quantity

    await this.db.prepare(`
      INSERT INTO inventory_transactions 
      (warehouse_id, sku_id, transaction_type, quantity, unit_cost, total_cost,
       reference_type, reference_id, stock_before, stock_after, note, operator_id)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      warehouseId, skuId, type, quantity, unitCost, totalCost,
      referenceType, referenceId, stockBefore, stockAfter, note, operatorId
    ).run()
  }

  /**
   * æª¢æŸ¥ä¸¦å‰µå»ºåº«å­˜è­¦ç¤º (åŸºæ–¼ç³»çµ±è¨­å®š)
   */
  async checkAndCreateAlerts(warehouseId, skuId) {
    const inventory = await this.db.prepare(`
      SELECT i.available_stock, i.safe_stock, i.max_stock, 
             ps.sku, p.name as product_name
      FROM inventory i
      LEFT JOIN product_skus ps ON i.sku_id = ps.id
      LEFT JOIN products p ON ps.product_id = p.id
      LEFT JOIN gift_skus gs ON i.sku_id = gs.id  
      LEFT JOIN gifts g ON gs.gift_id = g.id
      WHERE i.warehouse_id = ? AND i.sku_id = ?
    `).bind(warehouseId, skuId).first()

    if (!inventory) return

    const alerts = []

    // æª¢æŸ¥åº«å­˜ä¸è¶³
    if (inventory.available_stock <= 0) {
      alerts.push({
        type: 'out_of_stock',
        message: `å•†å“ ${inventory.sku} åº«å­˜å·²ç”¨ç›¡`,
        currentStock: inventory.available_stock,
        threshold: 0
      })
    } else if (inventory.available_stock <= inventory.safe_stock) {
      alerts.push({
        type: 'low_stock',
        message: `å•†å“ ${inventory.sku} åº«å­˜åä½ (ç•¶å‰: ${inventory.available_stock}, å®‰å…¨åº«å­˜: ${inventory.safe_stock})`,
        currentStock: inventory.available_stock,
        threshold: inventory.safe_stock
      })
    }

    // æª¢æŸ¥åº«å­˜éå¤š
    if (inventory.available_stock > inventory.max_stock) {
      alerts.push({
        type: 'overstock',
        message: `å•†å“ ${inventory.sku} åº«å­˜éå¤š (ç•¶å‰: ${inventory.available_stock}, ä¸Šé™: ${inventory.max_stock})`,
        currentStock: inventory.available_stock,
        threshold: inventory.max_stock
      })
    }

    // å‰µå»ºè­¦ç¤ºè¨˜éŒ„ä¸¦ç™¼é€é€šçŸ¥
    for (const alert of alerts) {
      // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒé¡å‹çš„æœªè§£æ±ºè­¦ç¤º
      const existingAlert = await this.db.prepare(`
        SELECT id FROM inventory_alerts 
        WHERE warehouse_id = ? AND sku_id = ? AND alert_type = ? AND is_resolved = FALSE
      `).bind(warehouseId, skuId, alert.type).first()

      if (!existingAlert) {
        await this.db.prepare(`
          INSERT INTO inventory_alerts 
          (warehouse_id, sku_id, alert_type, current_stock, threshold_value, alert_message)
          VALUES (?, ?, ?, ?, ?, ?)
        `).bind(warehouseId, skuId, alert.type, alert.currentStock, alert.threshold, alert.message).run()
        
        // ç™¼é€é€šçŸ¥ (æ•´åˆé€šçŸ¥ç®¡ç†æ¨¡çµ„)
        await this.sendInventoryAlert(alert, inventory)
        
        console.log(`ğŸš¨ åº«å­˜è­¦ç¤º: ${alert.message}`)
      }
    }
  }

  /**
   * ç™¼é€åº«å­˜è­¦ç¤ºé€šçŸ¥ (æ•´åˆé€šçŸ¥ç®¡ç†)
   */
  async sendInventoryAlert(alert, inventory) {
    // é€™è£¡æ•´åˆé€šçŸ¥ç®¡ç†æ¨¡çµ„ï¼Œç™¼é€éƒµä»¶/ç°¡è¨Š
    // å¯¦ç¾å°‡åœ¨é€šçŸ¥ç®¡ç†æ¨¡çµ„ä¸­å®šç¾©
    console.log(`ğŸ“§ ç™¼é€åº«å­˜è­¦ç¤ºé€šçŸ¥: ${alert.message}`)
  }

  /**
   * ç”Ÿæˆå–®æ“šè™Ÿç¢¼
   */
  async generateOrderNumber(prefix) {
    const today = new Date().toISOString().split('T')[0].replace(/-/g, '')
    const sequence = await this.getNextSequence(prefix, today)
    return `${prefix}${today}${sequence.toString().padStart(4, '0')}`
  }

  /**
   * ç²å–åºè™Ÿ
   */
  async getNextSequence(prefix, date) {
    const result = await this.db.prepare(`
      SELECT COALESCE(MAX(CAST(SUBSTR(order_number, -4) AS INTEGER)), 0) + 1 as next_seq
      FROM (
        SELECT order_number FROM inbound_orders WHERE order_number LIKE ?
        UNION ALL
        SELECT picking_number as order_number FROM picking_orders WHERE picking_number LIKE ?
        UNION ALL  
        SELECT outbound_number as order_number FROM outbound_orders WHERE outbound_number LIKE ?
      )
    `).bind(`${prefix}${date}%`, `${prefix}${date}%`, `${prefix}${date}%`).first()
    
    return result.next_seq
  }

  /**
   * ç²å–é è¨­å€‰åº«
   */
  async getDefaultWarehouse() {
    const warehouse = await this.db.prepare(`
      SELECT * FROM warehouses WHERE is_default = TRUE AND is_active = TRUE LIMIT 1
    `).first()

    if (!warehouse) {
      throw new Error('æœªè¨­å®šé è¨­å€‰åº«')
    }

    return warehouse
  }

  /**
   * æ¸…ç†éæœŸçš„è³¼ç‰©è»Šé ç•™åº«å­˜ (æ™‚æ•ˆç”±ç³»çµ±è¨­å®šæ±ºå®š)
   */
  async cleanupExpiredReservations() {
    // ç²å–é ç•™åº«å­˜æ™‚æ•ˆè¨­å®š (é è¨­30åˆ†é˜)
    const maxAgeMinutes = await this.getSystemSetting('cart_reservation_timeout', 30)
    const cutoffTime = new Date(Date.now() - maxAgeMinutes * 60 * 1000)
    
    const expiredReservations = await this.db.prepare(`
      SELECT DISTINCT it.sku_id, it.warehouse_id, SUM(ABS(it.quantity)) as total_quantity
      FROM inventory_transactions it
      WHERE it.transaction_type = 'reserve'
        AND it.created_at < ?
        AND NOT EXISTS (
          SELECT 1 FROM inventory_transactions it2 
          WHERE it2.reference_type = it.reference_type 
            AND it2.reference_id = it.reference_id
            AND it2.transaction_type = 'release'
            AND it2.sku_id = it.sku_id
        )
      GROUP BY it.sku_id, it.warehouse_id
    `).bind(cutoffTime.toISOString()).all()

    for (const reservation of expiredReservations) {
      await this.db.prepare(`
        UPDATE inventory 
        SET reserved_stock = GREATEST(0, reserved_stock - ?),
            updated_at = CURRENT_TIMESTAMP
        WHERE sku_id = ? AND warehouse_id = ?
      `).bind(reservation.total_quantity, reservation.sku_id, reservation.warehouse_id).run()

      console.log(`ğŸ§¹ æ¸…ç†éæœŸé ç•™: SKU ${reservation.sku_id}, æ•¸é‡ ${reservation.total_quantity}`)
    }

    return expiredReservations.length
  }

  /**
   * ç²å–ç³»çµ±è¨­å®š (æ•´åˆç³»çµ±è¨­å®šæ¨¡çµ„)
   */
  async getSystemSetting(key, defaultValue) {
    // é€™è£¡æ•´åˆç³»çµ±è¨­å®šæ¨¡çµ„
    // å¯¦ç¾å°‡åœ¨ç³»çµ±è¨­å®šæ¨¡çµ„ä¸­å®šç¾©
    return defaultValue
  }
}

// å‰µå»ºå…¨åŸŸåº«å­˜ç®¡ç†å¯¦ä¾‹
export const inventoryManager = new InventoryManager(db)
```

### æˆæœ¬è¨ˆç®—å™¨å¯¦ç¾

#### FIFOæˆæœ¬è¨ˆç®—å™¨
```javascript
// services/cost-calculators/FIFOCalculator.js
export class FIFOCalculator {
  constructor(db) {
    this.db = db
  }

  async calculateStockOut(warehouseId, skuId, quantity) {
    // ç²å–è©²SKUçš„æ‰¹æ¬¡ (æŒ‰æ¥æ”¶æ—¥æœŸæ’åº - FIFO)
    const batches = await this.db.prepare(`
      SELECT id, remaining_quantity, unit_cost, batch_number, received_date
      FROM inventory_batches
      WHERE warehouse_id = ? AND sku_id = ? AND remaining_quantity > 0
      ORDER BY received_date ASC
    `).bind(warehouseId, skuId).all()

    let remainingQuantity = quantity
    let totalCost = 0

    for (const batch of batches) {
      if (remainingQuantity <= 0) break

      const useQuantity = Math.min(remainingQuantity, batch.remaining_quantity)
      const batchCost = useQuantity * batch.unit_cost

      // æ›´æ–°æ‰¹æ¬¡å‰©é¤˜æ•¸é‡
      await this.db.prepare(`
        UPDATE inventory_batches 
        SET remaining_quantity = remaining_quantity - ?,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(useQuantity, batch.id).run()

      totalCost += batchCost
      remainingQuantity -= useQuantity

      console.log(`ğŸ’° FIFOæ‰¹æ¬¡æ¶ˆè€—: ${batch.batch_number} (${batch.received_date}), æ•¸é‡: ${useQuantity}, æˆæœ¬: $${batchCost}`)
    }

    if (remainingQuantity > 0) {
      console.warn(`âš ï¸ è­¦å‘Š: åº«å­˜æ‰¹æ¬¡ä¸è¶³ï¼Œå‰©é¤˜éœ€æ±‚ ${remainingQuantity} æœªèƒ½åˆ†é…`)
    }

    return totalCost
  }
}
```

#### LIFOæˆæœ¬è¨ˆç®—å™¨
```javascript
// services/cost-calculators/LIFOCalculator.js
export class LIFOCalculator {
  constructor(db) {
    this.db = db
  }

  async calculateStockOut(warehouseId, skuId, quantity) {
    // ç²å–è©²SKUçš„æ‰¹æ¬¡ (æŒ‰æ¥æ”¶æ—¥æœŸå€’åº - LIFO)
    const batches = await this.db.prepare(`
      SELECT id, remaining_quantity, unit_cost, batch_number, received_date
      FROM inventory_batches
      WHERE warehouse_id = ? AND sku_id = ? AND remaining_quantity > 0
      ORDER BY received_date DESC
    `).bind(warehouseId, skuId).all()

    let remainingQuantity = quantity
    let totalCost = 0

    for (const batch of batches) {
      if (remainingQuantity <= 0) break

      const useQuantity = Math.min(remainingQuantity, batch.remaining_quantity)
      const batchCost = useQuantity * batch.unit_cost

      // æ›´æ–°æ‰¹æ¬¡å‰©é¤˜æ•¸é‡
      await this.db.prepare(`
        UPDATE inventory_batches 
        SET remaining_quantity = remaining_quantity - ?,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(useQuantity, batch.id).run()

      totalCost += batchCost
      remainingQuantity -= useQuantity

      console.log(`ğŸ’° LIFOæ‰¹æ¬¡æ¶ˆè€—: ${batch.batch_number} (${batch.received_date}), æ•¸é‡: ${useQuantity}, æˆæœ¬: $${batchCost}`)
    }

    return totalCost
  }
}
```

#### åŠ æ¬Šå¹³å‡æˆæœ¬è¨ˆç®—å™¨
```javascript
// services/cost-calculators/WeightedAverageCalculator.js
export class WeightedAverageCalculator {
  constructor(db) {
    this.db = db
  }

  async calculateStockOut(warehouseId, skuId, quantity) {
    // ç²å–ç•¶å‰å¹³å‡æˆæœ¬
    const inventory = await this.db.prepare(`
      SELECT average_cost, current_stock FROM inventory
      WHERE warehouse_id = ? AND sku_id = ?
    `).bind(warehouseId, skuId).first()

    if (!inventory || inventory.current_stock <= 0) {
      console.warn(`âš ï¸ åº«å­˜ä¸è¶³æˆ–å¹³å‡æˆæœ¬æœªè¨­å®š`)
      return 0
    }

    const totalCost = quantity * inventory.average_cost
    
    console.log(`ğŸ’° åŠ æ¬Šå¹³å‡æˆæœ¬è¨ˆç®—: æ•¸é‡ ${quantity} Ã— å¹³å‡æˆæœ¬ $${inventory.average_cost} = $${totalCost}`)
    
    return totalCost
  }
}
```

### ç¶ ç•Œç‰©æµæ•´åˆæœå‹™
```javascript
// services/EcpayLogisticsService.js
export class EcpayLogisticsService {
  constructor() {
    this.baseUrl = process.env.ECPAY_LOGISTICS_URL
    this.merchantId = process.env.ECPAY_MERCHANT_ID
    this.hashKey = process.env.ECPAY_HASH_KEY
    this.hashIV = process.env.ECPAY_HASH_IV
  }

  /**
   * å»ºç«‹ç¶ ç•Œç‰©æµè¨‚å–®
   */
  async createShipment({ outboundOrderId, recipientName, recipientPhone, shippingAddress, items }) {
    try {
      const shipmentData = {
        MerchantID: this.merchantId,
        MerchantTradeNo: `OB${outboundOrderId}${Date.now()}`,
        LogisticsType: 'CVS', // ä¾¿åˆ©å•†åº—å–è²¨
        LogisticsSubType: 'FAMI', // å…¨å®¶ä¾¿åˆ©å•†åº—
        GoodsAmount: this.calculateGoodsAmount(items),
        CollectionAmount: 0, // ä»£æ”¶é‡‘é¡
        IsCollection: 'N',
        GoodsName: this.formatGoodsName(items),
        SenderName: 'ç±³å¥‡ç¾å¦åº—',
        ReceiverName: recipientName,
        ReceiverCellPhone: recipientPhone,
        ReceiverStoreID: this.parseStoreId(shippingAddress),
        TradeDesc: 'å•†å“é…é€'
      }

      // ç”Ÿæˆæª¢æŸ¥ç¢¼
      shipmentData.CheckMacValue = this.generateCheckMac(shipmentData)

      const response = await fetch(`${this.baseUrl}/logistics/map`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams(shipmentData)
      })

      const result = await response.text()
      const parsedResult = this.parseEcpayResponse(result)

      if (parsedResult.RtnCode === '1') {
        return {
          success: true,
          logistics_id: parsedResult.AllPayLogisticsID,
          tracking_number: parsedResult.CVSPaymentNo,
          cvs_store_id: parsedResult.CVSStoreID
        }
      } else {
        throw new Error(parsedResult.RtnMsg)
      }

    } catch (error) {
      console.error('ç¶ ç•Œç‰©æµå»ºç«‹è¨‚å–®å¤±æ•—:', error)
      return {
        success: false,
        error: error.message
      }
    }
  }

  /**
   * åŒæ­¥ç‰©æµç‹€æ…‹
   */
  async syncShipmentStatus(ecpayLogisticsId) {
    try {
      const queryData = {
        MerchantID: this.merchantId,
        AllPayLogisticsID: ecpayLogisticsId,
        TimeStamp: Math.floor(Date.now() / 1000)
      }

      queryData.CheckMacValue = this.generateCheckMac(queryData)

      const response = await fetch(`${this.baseUrl}/logistics/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams(queryData)
      })

      const result = await response.text()
      const parsedResult = this.parseEcpayResponse(result)

      return {
        success: parsedResult.RtnCode === '1',
        status: parsedResult.LogisticsStatus,
        statusDescription: this.getStatusDescription(parsedResult.LogisticsStatus),
        updateTime: parsedResult.UpdateStatusDate
      }

    } catch (error) {
      console.error('ç¶ ç•Œç‰©æµç‹€æ…‹æŸ¥è©¢å¤±æ•—:', error)
      return { success: false, error: error.message }
    }
  }

  /**
   * ç¶ ç•Œç‰©æµç‹€æ…‹æè¿°
   */
  getStatusDescription(status) {
    const statusMap = {
      '300': 'æ–°å»ºç‰©æµè¨‚å–®/è¨‚å–®è™•ç†ä¸­',
      '301': 'å•†å“å·²é€é”ç‰©æµä¸­å¿ƒ',
      '302': 'å•†å“å·²é€é”é–€å¸‚/å·²é€é”',
      '303': 'é¡§å®¢å·²å–è²¨',
      '304': 'é¡§å®¢å–è²¨é€¾æ™‚ï¼Œé€€å›ç‰©æµä¸­å¿ƒ',
      '305': 'å•†å“å·²é€€å›ç‰©æµä¸­å¿ƒ',
      '306': 'å•†å“å·²é€å›å•†å®¶',
      '2030': 'é€†ç‰©æµè¨‚å–®æˆç«‹'
    }
    return statusMap[status] || 'æœªçŸ¥ç‹€æ…‹'
  }

  /**
   * ç”Ÿæˆæª¢æŸ¥ç¢¼
   */
  generateCheckMac(data) {
    // å¯¦ç¾ç¶ ç•Œæª¢æŸ¥ç¢¼ç”Ÿæˆé‚è¼¯
    // é€™è£¡éœ€è¦æ ¹æ“šç¶ ç•Œæ–‡ä»¶å¯¦ç¾
    const sortedData = Object.keys(data).sort().reduce((result, key) => {
      if (key !== 'CheckMacValue') {
        result[key] = data[key]
      }
      return result
    }, {})
    
    // ç”¢ç”Ÿæª¢æŸ¥ç¢¼çš„å…·é«”å¯¦ç¾
    return 'GENERATED_CHECK_MAC'
  }

  /**
   * è§£æç¶ ç•Œå›æ‡‰
   */
  parseEcpayResponse(response) {
    // è§£æç¶ ç•Œçš„å›æ‡‰æ ¼å¼
    const params = new URLSearchParams(response)
    return Object.fromEntries(params)
  }

  calculateGoodsAmount(items) {
    return items.reduce((sum, item) => sum + (item.quantity * 100), 0) // å‡è¨­å–®åƒ¹100
  }

  formatGoodsName(items) {
    return items.map(item => `å•†å“${item.sku_id}`).join('#').substring(0, 60)
  }

  parseStoreId(address) {
    // å¾åœ°å€è§£æåº—èˆ–ID
    return 'STORE001' // é è¨­åº—èˆ–
  }
}
```

## API ç«¯é»è¨­è¨ˆ

### éšå±¤å¼åº«å­˜æŸ¥è©¢
```javascript
// GET /admin/inventory/hierarchical - éšå±¤å¼åº«å­˜æŸ¥è©¢
app.get('/admin/inventory/hierarchical', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { 
    warehouse_id, 
    search, 
    expand_all = false,
    item_type, // 'product', 'gift', 'all'
    stock_status, // 'low_stock', 'out_of_stock', 'normal', 'overstock'
    page = 1,
    limit = 50
  } = request.query
  
  let productQuery = `
    SELECT 
      p.id as product_id,
      JSON_EXTRACT(p.name, '$.zh-TW') as product_name,
      p.sku_prefix,
      'product' as item_type,
      COALESCE(SUM(i.current_stock), 0) as total_current_stock,
      COALESCE(SUM(i.reserved_stock), 0) as total_reserved_stock,
      COALESCE(SUM(i.available_stock), 0) as total_available_stock,
      COUNT(ps.id) as variant_count,
      MIN(CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END) as worst_status,
      MAX(i.updated_at) as last_updated
    FROM products p
    LEFT JOIN product_skus ps ON p.id = ps.product_id AND ps.is_active = TRUE
    LEFT JOIN inventory i ON ps.id = i.sku_id AND i.warehouse_id = ?
    WHERE p.status = 'active'
  `

  let giftQuery = `
    SELECT 
      g.id as product_id,
      JSON_EXTRACT(g.name, '$.zh-TW') as product_name,
      g.sku_prefix,
      'gift' as item_type,
      COALESCE(SUM(i.current_stock), 0) as total_current_stock,
      COALESCE(SUM(i.reserved_stock), 0) as total_reserved_stock,
      COALESCE(SUM(i.available_stock), 0) as total_available_stock,
      COUNT(gs.id) as variant_count,
      MIN(CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END) as worst_status,
      MAX(i.updated_at) as last_updated
    FROM gifts g
    LEFT JOIN gift_skus gs ON g.id = gs.gift_id AND gs.is_active = TRUE
    LEFT JOIN inventory i ON gs.id = i.sku_id AND i.warehouse_id = ?
    WHERE g.status = 'active'
  `

  const params = [warehouse_id]
  
  // æœå°‹æ¢ä»¶
  if (search) {
    const searchCondition = ` AND JSON_EXTRACT(name, '$.zh-TW') LIKE ?`
    productQuery += searchCondition
    giftQuery += searchCondition
    params.push(`%${search}%`)
  }

  let finalQuery = ''
  
  // é …ç›®é¡å‹ç¯©é¸
  if (item_type === 'product') {
    finalQuery = productQuery
  } else if (item_type === 'gift') {
    finalQuery = giftQuery
    params[0] = warehouse_id // èª¿æ•´åƒæ•¸
  } else {
    finalQuery = `(${productQuery}) UNION ALL (${giftQuery})`
    params.push(warehouse_id) // gift query éœ€è¦é¡å¤–çš„ warehouse_id
    if (search) {
      params.push(`%${search}%`) // gift query çš„æœå°‹åƒæ•¸
    }
  }

  finalQuery += ` GROUP BY product_id, item_type HAVING variant_count > 0`

  // åº«å­˜ç‹€æ…‹ç¯©é¸
  if (stock_status) {
    finalQuery += ` HAVING worst_status = ?`
    params.push(stock_status)
  }

  finalQuery += ` ORDER BY last_updated DESC`

  // åˆ†é 
  finalQuery += ` LIMIT ? OFFSET ?`
  params.push(limit, (page - 1) * limit)

  const products = await db.prepare(finalQuery).bind(...params).all()

  // å¦‚æœéœ€è¦å±•é–‹å…¨éƒ¨æˆ–æœ‰æœå°‹æ¢ä»¶ï¼Œè¼‰å…¥è®Šé«”è³‡æ–™
  if (expand_all === 'true' || search) {
    for (const product of products) {
      const variantQuery = product.item_type === 'product' ? `
        SELECT 
          i.*,
          ps.sku,
          ps.variant_path,
          (SELECT GROUP_CONCAT(
            JSON_EXTRACT(pv.option_name, '$.zh-TW'), 
            '-'
           ) 
           FROM product_variants pv 
           WHERE pv.id IN (
             SELECT value FROM json_each(ps.variant_path)
           )
           ORDER BY pv.level
          ) as variant_display_name,
          CASE 
            WHEN i.available_stock <= 0 THEN 'out_of_stock'
            WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
            WHEN i.available_stock > i.max_stock THEN 'overstock'
            ELSE 'normal'
          END as stock_status
        FROM inventory i
        JOIN product_skus ps ON i.sku_id = ps.id
        WHERE ps.product_id = ? AND i.warehouse_id = ?
        ORDER BY ps.sku
      ` : `
        SELECT 
          i.*,
          gs.sku,
          gs.variant_path,
          'gift_variant' as variant_display_name,
          CASE 
            WHEN i.available_stock <= 0 THEN 'out_of_stock'
            WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
            WHEN i.available_stock > i.max_stock THEN 'overstock'
            ELSE 'normal'
          END as stock_status
        FROM inventory i
        JOIN gift_skus gs ON i.sku_id = gs.id
        WHERE gs.gift_id = ? AND i.warehouse_id = ?
        ORDER BY gs.sku
      `
      
      const variants = await db.prepare(variantQuery).bind(product.product_id, warehouse_id).all()
      product.variants = variants
    }
  }

  return {
    products,
    expandAll: expand_all === 'true' || !!search,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit),
      total: products.length
    }
  }
})

// GET /admin/inventory/:product_id/variants - ç²å–å•†å“è®Šé«”åº«å­˜
app.get('/admin/inventory/:product_id/variants', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { product_id } = request.params
  const { warehouse_id, item_type = 'product' } = request.query

  const variantQuery = item_type === 'product' ? `
    SELECT 
      i.*,
      ps.sku,
      ps.variant_path,
      (SELECT GROUP_CONCAT(
        JSON_EXTRACT(pv.option_name, '$.zh-TW'), 
        '-'
       ) 
       FROM product_variants pv 
       WHERE pv.id IN (
         SELECT value FROM json_each(ps.variant_path)
       )
       ORDER BY pv.level
      ) as variant_display_name,
      CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END as stock_status
    FROM inventory i
    JOIN product_skus ps ON i.sku_id = ps.id
    WHERE ps.product_id = ? AND i.warehouse_id = ?
    ORDER BY ps.sku
  ` : `
    SELECT 
      i.*,
      gs.sku,
      'gift_variant' as variant_display_name,
      CASE 
        WHEN i.available_stock <= 0 THEN 'out_of_stock'
        WHEN i.available_stock <= i.safe_stock THEN 'low_stock'
        WHEN i.available_stock > i.max_stock THEN 'overstock'
        ELSE 'normal'
      END as stock_status
    FROM inventory i
    JOIN gift_skus gs ON i.sku_id = gs.id
    WHERE gs.gift_id = ? AND i.warehouse_id = ?
    ORDER BY gs.sku
  `

  const variants = await db.prepare(variantQuery).bind(product_id, warehouse_id).all()

  return { variants }
})
```

### å…¥åº«ç®¡ç†API
```javascript
// POST /admin/inventory/inbound-orders - å‰µå»ºå…¥åº«å–®
app.post('/admin/inventory/inbound-orders', authenticateAdmin, requirePermission('inventory', 'create'), async (request) => {
  const data = await request.json()
  const adminId = request.auth.userId
  
  const {
    warehouse_id,
    order_type, // 'purchase', 'return', 'adjustment'
    source_type,
    source_id,
    items, // [{ sku_id, quantity, unit_cost, batch_number }]
    notes
  } = data

  try {
    const result = await inventoryManager.db.transaction(async () => {
      const orderNumber = await inventoryManager.generateOrderNumber('IB')
      
      // å‰µå»ºå…¥åº«å–®
      const inboundResult = await inventoryManager.db.prepare(`
        INSERT INTO inbound_orders 
        (order_number, warehouse_id, order_type, source_type, source_id, status, created_by, notes)
        VALUES (?, ?, ?, ?, ?, 'pending', ?, ?)
      `).bind(orderNumber, warehouse_id, order_type, source_type, source_id, adminId, notes).run()

      const inboundOrderId = inboundResult.meta.last_row_id

      // æ·»åŠ å…¥åº«å–®æ˜ç´°
      let totalQuantity = 0
      let totalCost = 0

      for (const item of items) {
        await inventoryManager.db.prepare(`
          INSERT INTO inbound_order_items
          (inbound_order_id, sku_id, batch_number, planned_quantity, unit_cost, quality_check_status)
          VALUES (?, ?, ?, ?, ?, ?)
        `).bind(
          inboundOrderId, item.sku_id, item.batch_number, 
          item.quantity, item.unit_cost,
          order_type === 'return' ? 'pending' : 'not_required'
        ).run()

        totalQuantity += item.quantity
        totalCost += item.quantity * item.unit_cost
      }

      // æ›´æ–°å…¥åº«å–®ç¸½è¨ˆ
      await inventoryManager.db.prepare(`
        UPDATE inbound_orders SET total_quantity = ?, total_cost = ? WHERE id = ?
      `).bind(totalQuantity, totalCost, inboundOrderId).run()

      return { inboundOrderId, orderNumber }
    })

    return {
      success: true,
      message: 'å…¥åº«å–®å‰µå»ºæˆåŠŸ',
      inbound_order_id: result.inboundOrderId,
      order_number: result.orderNumber
    }

  } catch (error) {
    console.error('å‰µå»ºå…¥åº«å–®å¤±æ•—:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// PUT /admin/inventory/inbound-orders/:id/approve - ä¸»ç®¡å¯©æ ¸å…¥åº«å–®
app.put('/admin/inventory/inbound-orders/:id/approve', authenticateAdmin, requirePermission('inventory', 'approve'), async (request) => {
  const { id } = request.params
  const adminId = request.auth.userId

  try {
    await inventoryManager.approveInboundOrder(id, adminId)
    return { success: true, message: 'å…¥åº«å–®å¯©æ ¸é€šéä¸¦å·²åŸ·è¡Œå…¥åº«' }
  } catch (error) {
    console.error('å¯©æ ¸å…¥åº«å–®å¤±æ•—:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// PUT /admin/inventory/inbound-orders/:id/items/:item_id/quality-check - è³ªæª¢
app.put('/admin/inventory/inbound-orders/:id/items/:item_id/quality-check', authenticateAdmin, requirePermission('inventory', 'quality_check'), async (request) => {
  const { id, item_id } = request.params
  const { status, notes } = await request.json() // 'passed', 'failed'
  const adminId = request.auth.userId

  try {
    await inventoryManager.db.prepare(`
      UPDATE inbound_order_items
      SET quality_check_status = ?,
          quality_check_by = ?,
          quality_check_at = CURRENT_TIMESTAMP,
          quality_notes = ?
      WHERE id = ? AND inbound_order_id = ?
    `).bind(status, adminId, notes, item_id, id).run()

    return { success: true, message: 'è³ªæª¢è¨˜éŒ„æ›´æ–°æˆåŠŸ' }
  } catch (error) {
    console.error('è³ªæª¢è¨˜éŒ„å¤±æ•—:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})
```

### å‡ºåº«ç®¡ç†API
```javascript
// GET /admin/inventory/picking-orders - æ€è²¨å–®åˆ—è¡¨
app.get('/admin/inventory/picking-orders', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { 
    warehouse_id, 
    status,
    picker_id,
    page = 1, 
    limit = 20 
  } = request.query

  let query = `
    SELECT 
      po.*,
      o.order_number as related_order_number,
      au.name as picker_name,
      w.name as warehouse_name
    FROM picking_orders po
    LEFT JOIN orders o ON po.order_id = o.id
    LEFT JOIN admin_users au ON po.picker_id = au.id
    LEFT JOIN warehouses w ON po.warehouse_id = w.id
    WHERE 1=1
  `

  const params = []

  if (warehouse_id) {
    query += ` AND po.warehouse_id = ?`
    params.push(warehouse_id)
  }

  if (status) {
    query += ` AND po.status = ?`
    params.push(status)
  }

  if (picker_id) {
    query += ` AND po.picker_id = ?`
    params.push(picker_id)
  }

  query += ` ORDER BY po.created_at DESC LIMIT ? OFFSET ?`
  params.push(limit, (page - 1) * limit)

  const pickingOrders = await db.prepare(query).bind(...params).all()

  return {
    picking_orders: pickingOrders,
    pagination: {
      page: parseInt(page),
      limit: parseInt(limit)
    }
  }
})

// POST /admin/inventory/picking-orders/:id/scan - æƒç¢¼æ€è²¨
app.post('/admin/inventory/picking-orders/:id/scan', authenticateAdmin, requirePermission('inventory', 'picking'), async (request) => {
  const { id } = request.params
  const { sku_id, quantity, batch_numbers } = await request.json()
  const adminId = request.auth.userId

  try {
    const result = await inventoryManager.scanPickingItem(
      id, sku_id, quantity, adminId, batch_numbers
    )

    return {
      success: true,
      message: 'æƒç¢¼æ€è²¨è¨˜éŒ„æˆåŠŸ',
      completed: result.completed,
      progress: result.progress
    }
  } catch (error) {
    console.error('æƒç¢¼æ€è²¨å¤±æ•—:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// POST /admin/inventory/picking-orders/:id/confirm - å“¡å·¥ç°½æ ¸æ€è²¨å–®
app.post('/admin/inventory/picking-orders/:id/confirm', authenticateAdmin, requirePermission('inventory', 'picking'), async (request) => {
  const { id } = request.params
  const adminId = request.auth.userId

  try {
    const result = await inventoryManager.confirmPickingAndCreateOutbound(id, adminId)

    return {
      success: true,
      message: 'æ€è²¨å–®ç°½æ ¸æˆåŠŸï¼Œå·²å»ºç«‹å‡ºè²¨å–®ä¸¦é€è‡³ç¶ ç•Œç‰©æµ',
      outbound_order_id: result.outboundOrderId,
      outbound_number: result.outboundNumber,
      tracking_number: result.trackingNumber,
      ecpay_success: result.ecpayResult.success
    }
  } catch (error) {
    console.error('æ€è²¨å–®ç°½æ ¸å¤±æ•—:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})
```

### ç¶ ç•Œç‰©æµåŒæ­¥API
```javascript
// POST /admin/inventory/outbound-orders/:id/sync-logistics - åŒæ­¥ç¶ ç•Œç‰©æµç‹€æ…‹
app.post('/admin/inventory/outbound-orders/:id/sync-logistics', authenticateAdmin, requirePermission('inventory', 'read'), async (request) => {
  const { id } = request.params

  try {
    const outboundOrder = await db.prepare(`
      SELECT * FROM outbound_orders WHERE id = ?
    `).bind(id).first()

    if (!outboundOrder || !outboundOrder.ecpay_logistics_id) {
      return new Response(JSON.stringify({ 
        error: 'å‡ºè²¨å–®ä¸å­˜åœ¨æˆ–æœªå»ºç«‹ç¶ ç•Œç‰©æµè¨‚å–®' 
      }), { status: 400 })
    }

    const ecpayService = new EcpayLogisticsService()
    const syncResult = await ecpayService.syncShipmentStatus(outboundOrder.ecpay_logistics_id)

    if (syncResult.success) {
      // æ›´æ–°å‡ºè²¨å–®ç‹€æ…‹
      let newStatus = outboundOrder.status
      if (syncResult.status === '303') { // é¡§å®¢å·²å–è²¨
        newStatus = 'delivered'
      } else if (syncResult.status === '302') { // å·²é€é”é–€å¸‚
        newStatus = 'shipped'
      }

      await db.prepare(`
        UPDATE outbound_orders
        SET ecpay_status = ?,
            status = ?,
            last_sync_at = CURRENT_TIMESTAMP
            ${newStatus === 'delivered' ? ', delivered_at = CURRENT_TIMESTAMP' : ''}
        WHERE id = ?
      `).bind(syncResult.status, newStatus, id).run()

      // åŒæ­¥æ›´æ–°è¨‚å–®ç‹€æ…‹
      if (newStatus === 'delivered') {
        await db.prepare(`
          UPDATE orders SET status = 'completed', completed_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).bind(outboundOrder.order_id).run()
      }

      return {
        success: true,
        message: 'ç‰©æµç‹€æ…‹åŒæ­¥æˆåŠŸ',
        status: syncResult.status,
        description: syncResult.statusDescription,
        order_status: newStatus
      }
    } else {
      return new Response(JSON.stringify({ 
        error: syncResult.error 
      }), { status: 500 })
    }

  } catch (error) {
    console.error('åŒæ­¥ç¶ ç•Œç‰©æµç‹€æ…‹å¤±æ•—:', error)
    return new Response(JSON.stringify({ 
      error: error.message 
    }), { status: 500 })
  }
})

// å®šæ™‚ä»»å‹™ï¼šæ‰¹é‡åŒæ­¥æ‰€æœ‰æœªå®Œæˆçš„ç‰©æµè¨‚å–®
export const syncAllPendingLogistics = async () => {
  console.log('ğŸšš é–‹å§‹æ‰¹é‡åŒæ­¥ç‰©æµç‹€æ…‹...')

  const pendingOrders = await db.prepare(`
    SELECT * FROM outbound_orders 
    WHERE ecpay_logistics_id IS NOT NULL 
      AND status IN ('shipped') 
      AND (last_sync_at IS NULL OR last_sync_at < datetime('now', '-1 hour'))
    ORDER BY shipped_at DESC
    LIMIT 50
  `).all()

  const ecpayService = new EcpayLogisticsService()
  let synced = 0
  let errors = 0

  for (const order of pendingOrders) {
    try {
      const syncResult = await ecpayService.syncShipmentStatus(order.ecpay_logistics_id)
      
      if (syncResult.success) {
        let newStatus = order.status
        if (syncResult.status === '303') { // é¡§å®¢å·²å–è²¨
          newStatus = 'delivered'
        }

        await db.prepare(`
          UPDATE outbound_orders
          SET ecpay_status = ?,
              status = ?,
              last_sync_at = CURRENT_TIMESTAMP
              ${newStatus === 'delivered' ? ', delivered_at = CURRENT_TIMESTAMP' : ''}
          WHERE id = ?
        `).bind(syncResult.status, newStatus, order.id).run()

        // åŒæ­¥æ›´æ–°è¨‚å–®ç‹€æ…‹
        if (newStatus === 'delivered') {
          await db.prepare(`
            UPDATE orders SET status = 'completed', completed_at = CURRENT_TIMESTAMP
            WHERE id = ?
          `).bind(order.order_id).run()
        }

        synced++
      } else {
        errors++
      }

      // é˜²æ­¢éæ–¼é »ç¹çš„APIè«‹æ±‚
      await new Promise(resolve => setTimeout(resolve, 200))

    } catch (error) {
      console.error(`åŒæ­¥ç‰©æµè¨‚å–® ${order.id} å¤±æ•—:`, error)
      errors++
    }
  }

  console.log(`âœ… ç‰©æµç‹€æ…‹æ‰¹é‡åŒæ­¥å®Œæˆ: ${synced} æˆåŠŸ, ${errors} å¤±æ•—`)
}
```

## éšå±¤å¼å‰ç«¯çµ„ä»¶

### éšå±¤å¼åº«å­˜è¡¨æ ¼
```jsx
// admin/src/components/HierarchicalInventoryTable.jsx
import React, { useState, useEffect } from 'react'
import { 
  Table, Button, Space, Tag, Input, Select, Switch, 
  InputNumber, Modal, Form, message, Tooltip 
} from 'antd'
import { 
  DownOutlined, RightOutlined, PlusOutlined, 
  MinusOutlined, SettingOutlined, EyeOutlined,
  ScanOutlined, ExportOutlined
} from '@ant-design/icons'

const { Search } = Input
const { Option } = Select

const HierarchicalInventoryTable = () => {
  const [expandedRows, setExpandedRows] = useState(new Set())
  const [inventoryData, setInventoryData] = useState([])
  const [loading, setLoading] = useState(false)
  const [filters, setFilters] = useState({
    warehouse_id: null,
    item_type: 'all',
    stock_status: null,
    search: ''
  })
  const [warehouses, setWarehouses] = useState([])
  const [selectedWarehouse, setSelectedWarehouse] = useState(null)

  useEffect(() => {
    loadWarehouses()
  }, [])

  useEffect(() => {
    if (selectedWarehouse) {
      loadInventoryData()
    }
  }, [selectedWarehouse, filters])

  const loadWarehouses = async () => {
    try {
      const response = await fetch('/admin/warehouses')
      const result = await response.json()
      setWarehouses(result.warehouses)
      
      // è¨­å®šé è¨­å€‰åº«
      const defaultWarehouse = result.warehouses.find(w => w.is_default)
      if (defaultWarehouse) {
        setSelectedWarehouse(defaultWarehouse.id)
        setFilters(prev => ({ ...prev, warehouse_id: defaultWarehouse.id }))
      }
    } catch (error) {
      message.error('è¼‰å…¥å€‰åº«åˆ—è¡¨å¤±æ•—')
    }
  }

  const loadInventoryData = async () => {
    if (!selectedWarehouse) return

    setLoading(true)
    try {
      const queryParams = new URLSearchParams({
        warehouse_id: selectedWarehouse,
        expand_all: filters.search ? 'true' : 'false',
        ...filters
      })

      const response = await fetch(`/admin/inventory/hierarchical?${queryParams}`)
      const result = await response.json()
      
      setInventoryData(result.products)
      
      // å¦‚æœæœ‰æœå°‹ï¼Œè‡ªå‹•å±•é–‹æ‰€æœ‰é …ç›®
      if (result.expandAll) {
        const allProductIds = result.products.map(p => p.product_id)
        setExpandedRows(new Set(allProductIds))
      }

    } catch (error) {
      message.error('è¼‰å…¥åº«å­˜è³‡æ–™å¤±æ•—')
    } finally {
      setLoading(false)
    }
  }

  const toggleRow = async (productId, itemType) => {
    const newExpanded = new Set(expandedRows)
    
    if (newExpanded.has(productId)) {
      newExpanded.delete(productId)
    } else {
      newExpanded.add(productId)
      
      // å¦‚æœè©²å•†å“é‚„æ²’è¼‰å…¥è®Šé«”ï¼Œå‰‡è¼‰å…¥
      const product = inventoryData.find(p => p.product_id === productId)
      if (!product.variants) {
        try {
          const response = await fetch(
            `/admin/inventory/${productId}/variants?warehouse_id=${selectedWarehouse}&item_type=${itemType}`
          )
          const result = await response.json()
          
          // æ›´æ–°è©²å•†å“çš„è®Šé«”è³‡æ–™
          setInventoryData(prev => prev.map(p => 
            p.product_id === productId 
              ? { ...p, variants: result.variants }
              : p
          ))
        } catch (error) {
          message.error('è¼‰å…¥è®Šé«”è³‡æ–™å¤±æ•—')
        }
      }
    }
    
    setExpandedRows(newExpanded)
  }

  const getStockStatusColor = (status) => {
    const statusConfig = {
      'out_of_stock': 'red',
      'low_stock': 'orange', 
      'normal': 'green',
      'overstock': 'purple'
    }
    return statusConfig[status] || 'default'
  }

  const getStockStatusText = (status, variantCount = 0) => {
    const statusText = {
      'out_of_stock': 'ç¼ºè²¨',
      'low_stock': 'ä½åº«å­˜',
      'normal': 'æ­£å¸¸',
      'overstock': 'åº«å­˜éå¤š'
    }
    
    const text = statusText[status] || 'æœªçŸ¥'
    return variantCount > 0 ? `${text} (${variantCount}ç¨®è®Šé«”)` : text
  }

  const handleQuickStock = async (skuId, action, quantity = 1) => {
    try {
      const endpoint = action === 'in' ? '/admin/inventory/stock-in' : '/admin/inventory/stock-out'
      
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sku_id: skuId,
          warehouse_id: selectedWarehouse,
          quantity,
          unit_cost: action === 'in' ? 100 : undefined, // é è¨­æˆæœ¬
          batch_number: action === 'in' ? `BATCH${Date.now()}` : undefined,
          reason: action === 'out' ? 'manual' : undefined
        })
      })

      const result = await response.json()
      
      if (result.success) {
        message.success(`${action === 'in' ? 'å…¥åº«' : 'å‡ºåº«'}æˆåŠŸ`)
        loadInventoryData() // é‡æ–°è¼‰å…¥è³‡æ–™
      } else {
        message.error(result.error)
      }
    } catch (error) {
      message.error(`${action === 'in' ? 'å…¥åº«' : 'å‡ºåº«'}å¤±æ•—`)
    }
  }

  const columns = [
    {
      title: 'å•†å“/è´ˆå“',
      dataIndex: 'product_name',
      width: 300,
      render: (name, record) => (
        <div style={{ 
          paddingLeft: record.isVariant ? 24 : 0,
          display: 'flex',
          alignItems: 'center'
        }}>
          {!record.isVariant && (
            <Button 
              type="text" 
              size="small"
              icon={expandedRows.has(record.product_id) ? 
                <DownOutlined /> : <RightOutlined />
              }
              onClick={() => toggleRow(record.product_id, record.item_type)}
              style={{ marginRight: 8 }}
            />
          )}
          
          <span style={{ marginRight: 8 }}>
            {record.item_type === 'gift' || record.isGift ? 'ğŸ' : 'ğŸ“¦'}
          </span>
          
          <span style={{ 
            fontWeight: record.isVariant ? 'normal' : 'bold',
            fontSize: record.isVariant ? '14px' : '16px'
          }}>
            {name}
          </span>
          
          {record.isVariant && (
            <Tag color="blue" style={{ marginLeft: 8 }}>
              {record.sku}
            </Tag>
          )}
          
          {!record.isVariant && record.sku_prefix && (
            <Tag color="geekblue" style={{ marginLeft: 8 }}>
              {record.sku_prefix}*
            </Tag>
          )}
        </div>
      )
    },
    {
      title: 'ç•¶å‰åº«å­˜',
      dataIndex: 'current_stock',
      width: 100,
      render: (stock, record) => (
        <span style={{ 
          fontWeight: record.isVariant ? 'normal' : 'bold',
          fontSize: record.isVariant ? '14px' : '16px',
          color: record.isVariant && stock <= 0 ? '#f50' : 'inherit'
        }}>
          {stock || 0}
        </span>
      )
    },
    {
      title: 'é ç•™åº«å­˜', 
      dataIndex: 'reserved_stock',
      width: 100,
      render: (stock, record) => (
        <span style={{ 
          color: stock > 0 ? '#f50' : '#999',
          fontSize: record.isVariant ? '14px' : '16px'
        }}>
          {stock > 0 ? `-${stock}` : '0'}
        </span>
      )
    },
    {
      title: 'å¯ç”¨åº«å­˜',
      dataIndex: 'available_stock',
      width: 100,
      render: (stock, record) => {
        let color = '#52c41a' // æ­£å¸¸ç¶ è‰²
        if (stock <= 0) color = '#f50' // ç¼ºè²¨ç´…è‰²
        else if (stock <= record.safe_stock) color = '#fa8c16' // ä½åº«å­˜æ©™è‰²
        
        return (
          <span style={{ 
            fontWeight: record.isVariant ? 'normal' : 'bold',
            fontSize: record.isVariant ? '14px' : '16px',
            color
          }}>
            {stock || 0}
          </span>
        )
      }
    },
    {
      title: 'åº«å­˜ç‹€æ…‹',
      dataIndex: 'stock_status',
      width: 150,
      render: (status, record) => (
        <Tag color={getStockStatusColor(status)}>
          {getStockStatusText(
            status, 
            record.isVariant ? 0 : record.variant_count
          )}
        </Tag>
      )
    },
    {
      title: 'æˆæœ¬/å‡åƒ¹',
      width: 100,
      render: (_, record) => {
        if (!record.isVariant) return '-'
        
        return (
          <div>
            <div style={{ fontSize: '12px', color: '#999' }}>
              å‡åƒ¹: ${record.average_cost?.toFixed(2) || '0.00'}
            </div>
          </div>
        )
      }
    },
    {
      title: 'æ“ä½œ',
      width: 200,
      render: (_, record) => (
        <Space size="small">
          {record.isVariant ? (
            <>
              <Tooltip title="å¿«é€Ÿå…¥åº«">
                <Button 
                  size="small" 
                  icon={<PlusOutlined />}
                  onClick={() => handleQuickStock(record.sku_id, 'in')}
                />
              </Tooltip>
              
              <Tooltip title="å¿«é€Ÿå‡ºåº«">
                <Button 
                  size="small" 
                  icon={<MinusOutlined />}
                  onClick={() => handleQuickStock(record.sku_id, 'out')}
                  disabled={record.available_stock <= 0}
                />
              </Tooltip>
              
              <Tooltip title="æƒç¢¼æ“ä½œ">
                <Button 
                  size="small" 
                  icon={<ScanOutlined />}
                  onClick={() => openScanModal(record)}
                />
              </Tooltip>
              
              <Tooltip title="åº«å­˜è¨­å®š">
                <Button 
                  size="small" 
                  icon={<SettingOutlined />}
                  onClick={() => openSettingsModal(record)}
                />
              </Tooltip>
            </>
          ) : (
            <>
              <Button 
                size="small" 
                icon={<EyeOutlined />}
                onClick={() => viewProductDetails(record)}
              >
                æŸ¥çœ‹è©³æƒ…
              </Button>
              
              <Button 
                size="small" 
                icon={<ExportOutlined />}
                onClick={() => exportProductInventory(record)}
              >
                åŒ¯å‡º
              </Button>
            </>
          )}
        </Space>
      )
    }
  ]

  // è™•ç†å±•é–‹çš„è³‡æ–™çµæ§‹
  const getTableData = () => {
    const result = []
    
    inventoryData.forEach(product => {
      // æ·»åŠ å•†å“/è´ˆå“ä¸»é …ç›®
      result.push({
        key: `product-${product.product_id}`,
        ...product,
        current_stock: product.total_current_stock,
        reserved_stock: product.total_reserved_stock,
        available_stock: product.total_available_stock,
        stock_status: product.worst_status,
        isVariant: false
      })
      
      // å¦‚æœè©²å•†å“å·²å±•é–‹ï¼Œæ·»åŠ è®Šé«”å­é …ç›®
      if (expandedRows.has(product.product_id) && product.variants) {
        product.variants.forEach(variant => {
          result.push({
            key: `variant-${variant.sku_id}`,
            ...variant,
            product_id: product.product_id,
            product_name: variant.variant_display_name || variant.sku,
            isVariant: true,
            isGift: product.item_type === 'gift'
          })
        })
      }
    })
    
    return result
  }

  const openScanModal = (record) => {
    // å¯¦ç¾æƒç¢¼æ¨¡æ…‹æ¡†
    console.log('é–‹å•Ÿæƒç¢¼æ“ä½œ:', record)
  }

  const openSettingsModal = (record) => {
    // å¯¦ç¾åº«å­˜è¨­å®šæ¨¡æ…‹æ¡†
    console.log('é–‹å•Ÿåº«å­˜è¨­å®š:', record)
  }

  const viewProductDetails = (record) => {
    // è·³è½‰åˆ°å•†å“è©³æƒ…é 
    window.open(`/admin/inventory/products/${record.product_id}/details`)
  }

  const exportProductInventory = (record) => {
    // å¯¦ç¾åº«å­˜åŒ¯å‡ºåŠŸèƒ½
    console.log('åŒ¯å‡ºå•†å“åº«å­˜:', record)
  }

  return (
    <div className="hierarchical-inventory-table">
      {/* ç¯©é¸å™¨ */}
      <div className="inventory-filters" style={{ 
        marginBottom: 16, 
        padding: 16, 
        background: '#fafafa', 
        borderRadius: 6 
      }}>
        <Space wrap>
          <Select
            placeholder="é¸æ“‡å€‰åº«"
            style={{ width: 180 }}
            value={selectedWarehouse}
            onChange={(value) => {
              setSelectedWarehouse(value)
              setFilters(prev => ({ ...prev, warehouse_id: value }))
            }}
          >
            {warehouses.map(warehouse => (
              <Option key={warehouse.id} value={warehouse.id}>
                {warehouse.name} {warehouse.is_default && <Tag size="small">é è¨­</Tag>}
              </Option>
            ))}
          </Select>

          <Select
            placeholder="é …ç›®é¡å‹"
            style={{ width: 120 }}
            value={filters.item_type}
            onChange={(value) => setFilters(prev => ({ ...prev, item_type: value }))}
          >
            <Option value="all">å…¨éƒ¨</Option>
            <Option value="product">ğŸ“¦ å•†å“</Option>
            <Option value="gift">ğŸ è´ˆå“</Option>
          </Select>

          <Select
            placeholder="åº«å­˜ç‹€æ…‹"
            style={{ width: 120 }}
            value={filters.stock_status}
            onChange={(value) => setFilters(prev => ({ ...prev, stock_status: value }))}
            allowClear
          >
            <Option value="out_of_stock">ç¼ºè²¨</Option>
            <Option value="low_stock">ä½åº«å­˜</Option>
            <Option value="normal">æ­£å¸¸</Option>
            <Option value="overstock">åº«å­˜éå¤š</Option>
          </Select>

          <Search
            placeholder="æœå°‹å•†å“åç¨±æˆ–SKU"
            style={{ width: 250 }}
            value={filters.search}
            onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
            onSearch={() => loadInventoryData()}
            enterButton
          />

          <Button 
            onClick={loadInventoryData}
            loading={loading}
          >
            é‡æ–°è¼‰å…¥
          </Button>

          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => window.open('/admin/inventory/inbound-orders/create')}
          >
            å»ºç«‹å…¥åº«å–®
          </Button>
        </Space>
      </div>

      {/* åº«å­˜è¡¨æ ¼ */}
      <Table
        columns={columns}
        dataSource={getTableData()}
        loading={loading}
        pagination={{
          showSizeChanger: true,
          showQuickJumper: true,
          showTotal: (total, range) => 
            `é¡¯ç¤º ${range[0]}-${range[1]} é …ï¼Œå…± ${total} é …`,
          pageSize: 50,
          pageSizeOptions: ['20', '50', '100', '200']
        }}
        size="middle"
        scroll={{ x: 1200 }}
        expandable={false} // ä½¿ç”¨è‡ªå®šç¾©å±•é–‹é‚è¼¯
      />
    </div>
  )
}

export default HierarchicalInventoryTable
```

## èˆ‡18å€‹æ¨¡çµ„çš„æ•´åˆè¨­è¨ˆ

### 1. æ¡è³¼ç®¡ç†æ•´åˆ
- **è‡ªå‹•è½‰å…¥åº«å–®**: æ¡è³¼é©—æ”¶å¾Œè‡ªå‹•å»ºç«‹å…¥åº«å–®
- **æ‰¹æ¬¡ç®¡ç†**: æ¡è³¼æ‰¹æ¬¡è‡ªå‹•è½‰ç‚ºåº«å­˜æ‰¹æ¬¡
- **æˆæœ¬åŒæ­¥**: æ¡è³¼æˆæœ¬è‡ªå‹•æ›´æ–°ç‚ºåº«å­˜æˆæœ¬

### 2. è¨‚å–®ç®¡ç†æ•´åˆ  
- **è‡ªå‹•å»ºç«‹æ€è²¨å–®**: è¨‚å–®ç¢ºèªå¾Œè‡ªå‹•å»ºç«‹æ€è²¨å–®
- **åº«å­˜é ç•™**: ä¸‹å–®æ™‚è‡ªå‹•é ç•™åº«å­˜
- **é å”®æ”¯æ´**: æ”¯æ´åº«å­˜ä¸è¶³æ™‚çš„é å”®åŠŸèƒ½

### 3. ç‰©æµç®¡ç†æ•´åˆ
- **ç¶ ç•Œç‰©æµAPI**: å‡ºè²¨å–®è‡ªå‹•å‚³é€ç¶ ç•Œ
- **ç‹€æ…‹åŒæ­¥**: æŒçºŒåŒæ­¥ç‰©æµç‹€æ…‹æ›´æ–°è¨‚å–®
- **è¿½è¹¤è™Ÿç¢¼**: è‡ªå‹•ç²å–ä¸¦è¨˜éŒ„è¿½è¹¤è™Ÿç¢¼

### 4. ç³»çµ±è¨­å®šæ•´åˆ
- **åƒæ•¸è¨­å®š**: é ç•™æ™‚æ•ˆã€è­¦ç¤ºé‚è¼¯ã€ç›¤é»è¨­å®š
- **æˆæœ¬æ–¹æ³•è¨­å®š**: FIFO/LIFO/åŠ æ¬Šå¹³å‡é¸æ“‡  
- **å‘†æ»¯åº«å­˜æ¨™æº–**: å¯è¨­å®šçš„å‘†æ»¯åº«å­˜åˆ¤å®šæ¢ä»¶

### 5. æœƒè¨ˆè™•ç†æ•´åˆ
- **æˆæœ¬çµè½‰**: éŠ·å”®æˆæœ¬è‡ªå‹•è¨ˆç®—èˆ‡çµè½‰
- **åº«å­˜è©•åƒ¹**: æœŸæœ«åº«å­˜åƒ¹å€¼è‡ªå‹•è¨ˆç®—
- **é€±è½‰ç‡è¨­å®š**: æœƒè¨ˆæœŸé–“è¨­å®šå½±éŸ¿é€±è½‰ç‡è¨ˆç®—

### 6. æ•¸æ“šåˆ†ææ•´åˆ
- **åº«å­˜å ±è¡¨**: 5å¤§é¡åº«å­˜å ±è¡¨åœ¨æ•¸æ“šåˆ†æä¸­å±•ç¤º
  - åº«å­˜æ˜ç´°è¡¨
  - åº«å­˜ç•°å‹•è¡¨  
  - åº«å­˜é€±è½‰åˆ†æè¡¨
  - å‘†æ»¯åº«å­˜å ±è¡¨
  - åº«å­˜æˆæœ¬åˆ†æè¡¨

### 7. é€šçŸ¥ç®¡ç†æ•´åˆ
- **åº«å­˜è­¦ç¤ºé€šçŸ¥**: ä½åº«å­˜/ç¼ºè²¨éƒµä»¶ç°¡è¨Šé€šçŸ¥
- **å¯©æ ¸é€šçŸ¥**: å…¥åº«å–®ã€ç›¤é»å¯©æ ¸é€šçŸ¥
- **ç‰©æµé€šçŸ¥**: å‡ºè²¨ã€åˆ°è²¨ç‹€æ…‹é€šçŸ¥

### 8. ç®¡ç†å“¡ç®¡ç†æ•´åˆ
- **æ¬Šé™æ§åˆ¶**: ç´°åˆ†çš„åº«å­˜æ“ä½œæ¬Šé™
- **å¯©æ ¸æµç¨‹**: ä¸åŒè§’è‰²çš„å¯©æ ¸æ¬Šé™è¨­å®š
- **æ“ä½œè¨˜éŒ„**: å®Œæ•´çš„æ“ä½œäººå“¡è¨˜éŒ„

### 9. å•†å“ç®¡ç†æ•´åˆ
- **SKUåŒæ­¥**: æ–°å•†å“è‡ªå‹•å‰µå»ºåº«å­˜è¨˜éŒ„
- **è®Šé«”æ”¯æ´**: å®Œæ•´æ”¯æ´å•†å“è®Šé«”åº«å­˜ç®¡ç†
- **ç‹€æ…‹åŒæ­¥**: é›¶åº«å­˜å•†å“å¯è¨­å®šè‡ªå‹•ä¸‹æ¶

### 10. è´ˆå“ç®¡ç†æ•´åˆ
- **è´ˆå“åº«å­˜**: è´ˆå“èˆ‡å•†å“çµ±ä¸€åº«å­˜ç®¡ç†
- **ä¿ƒéŠ·æ‰£æ¸›**: è´ˆå“ç™¼æ”¾è‡ªå‹•æ‰£æ¸›åº«å­˜
- **éšå±¤å±•ç¤º**: è´ˆå“åœ¨åº«å­˜åˆ—è¡¨ä¸­ç¨ç«‹å±•ç¤º

## å®šæ™‚ä»»å‹™è¨­è¨ˆ

### åº«å­˜ç›¸é—œå®šæ™‚ä»»å‹™
```javascript
// schedules/inventory-tasks.js
import { inventoryManager } from '../services/InventoryManager'
import { syncAllPendingLogistics } from '../api/inventory-api'

// æ¯30åˆ†é˜æ¸…ç†éæœŸçš„è³¼ç‰©è»Šé ç•™åº«å­˜
export const cleanupExpiredReservations = {
  schedule: '0 */30 * * * *', // æ¯30åˆ†é˜
  task: async () => {
    try {
      const cleaned = await inventoryManager.cleanupExpiredReservations()
      console.log(`âœ… æ¸…ç†éæœŸé ç•™åº«å­˜: ${cleaned} ç­†è¨˜éŒ„`)
    } catch (error) {
      console.error('âŒ æ¸…ç†éæœŸé ç•™åº«å­˜å¤±æ•—:', error)
    }
  }
}

// æ¯å°æ™‚åŒæ­¥ç¶ ç•Œç‰©æµç‹€æ…‹
export const syncLogisticsStatus = {
  schedule: '0 0 * * * *', // æ¯å°æ™‚
  task: async () => {
    try {
      await syncAllPendingLogistics()
    } catch (error) {
      console.error('âŒ æ‰¹é‡åŒæ­¥ç‰©æµç‹€æ…‹å¤±æ•—:', error)
    }
  }
}

// æ¯æ—¥æª¢æŸ¥ä½åº«å­˜ä¸¦ç™¼é€è­¦ç¤º
export const dailyLowStockCheck = {
  schedule: '0 0 9 * * *', // æ¯å¤©ä¸Šåˆ9é»
  task: async () => {
    try {
      const warehouses = await inventoryManager.db.prepare(`
        SELECT id FROM warehouses WHERE is_active = TRUE
      `).all()

      for (const warehouse of warehouses) {
        const lowStockItems = await inventoryManager.db.prepare(`
          SELECT i.*, ps.sku FROM inventory i
          JOIN product_skus ps ON i.sku_id = ps.id
          WHERE i.warehouse_id = ? AND i.available_stock <= i.safe_stock
        `).bind(warehouse.id).all()

        for (const item of lowStockItems) {
          await inventoryManager.checkAndCreateAlerts(warehouse.id, item.sku_id)
        }
      }

      console.log('âœ… æ¯æ—¥ä½åº«å­˜æª¢æŸ¥å®Œæˆ')
    } catch (error) {
      console.error('âŒ æ¯æ—¥ä½åº«å­˜æª¢æŸ¥å¤±æ•—:', error)
    }
  }
}

// æ¯é€±ç”Ÿæˆåº«å­˜é€±è½‰å ±å‘Š
export const weeklyTurnoverReport = {
  schedule: '0 0 6 * * 1', // æ¯é€±ä¸€ä¸Šåˆ6é»
  task: async () => {
    try {
      // ç”Ÿæˆåº«å­˜é€±è½‰ç‡å ±å‘Š
      // å¯¦ç¾å°‡èˆ‡æ•¸æ“šåˆ†ææ¨¡çµ„æ•´åˆ
      console.log('âœ… æ¯é€±åº«å­˜é€±è½‰å ±å‘Šç”Ÿæˆå®Œæˆ')
    } catch (error) {
      console.error('âŒ æ¯é€±åº«å­˜é€±è½‰å ±å‘Šç”Ÿæˆå¤±æ•—:', error)
    }
  }
}
```

## ç³»çµ±é…ç½®

### ç’°å¢ƒè®Šæ•¸è¨­å®š
```bash
# .env - åº«å­˜ç®¡ç†ç›¸é—œç’°å¢ƒè®Šæ•¸

# ç¶ ç•Œç‰©æµAPIè¨­å®š
ECPAY_LOGISTICS_URL=https://logistics-stage.ecpay.com.tw
ECPAY_MERCHANT_ID=your_merchant_id
ECPAY_HASH_KEY=your_hash_key
ECPAY_HASH_IV=your_hash_iv

# åº«å­˜ç®¡ç†è¨­å®š
INVENTORY_RESERVATION_TIMEOUT=30  # è³¼ç‰©è»Šé ç•™æ™‚æ•ˆï¼ˆåˆ†é˜ï¼‰
INVENTORY_LOW_STOCK_THRESHOLD=10  # é è¨­ä½åº«å­˜é–¾å€¼
INVENTORY_BATCH_SYNC_LIMIT=50     # æ‰¹é‡åŒæ­¥é™åˆ¶

# é€šçŸ¥è¨­å®š
INVENTORY_ALERT_EMAIL=admin@example.com
INVENTORY_ALERT_SMS=+886912345678
```

### æ¬Šé™è¨­å®š
```javascript
// åº«å­˜ç®¡ç†æ¬Šé™å®šç¾©
const inventoryPermissions = {
  'inventory.read': 'æŸ¥çœ‹åº«å­˜è³‡è¨Š',
  'inventory.create': 'å»ºç«‹å…¥åº«å–®ã€èª¿æ•´åº«å­˜',
  'inventory.update': 'ä¿®æ”¹åº«å­˜è¨­å®š',
  'inventory.delete': 'åˆªé™¤åº«å­˜è¨˜éŒ„',
  'inventory.approve': 'å¯©æ ¸å…¥åº«å–®',
  'inventory.picking': 'åŸ·è¡Œæ€è²¨æ“ä½œ',
  'inventory.quality_check': 'åŸ·è¡Œè³ªæª¢æ“ä½œ',
  'inventory.count': 'åŸ·è¡Œåº«å­˜ç›¤é»',
  'inventory.export': 'åŒ¯å‡ºåº«å­˜è³‡æ–™'
}
```

## ç¸½çµ

é€™å€‹åº«å­˜ç®¡ç†ç³»çµ±æä¾›äº†ï¼š

1. **å®Œæ•´çš„å–®æ“šæµç¨‹** - å…¥åº«å–®ã€æ€è²¨å–®ã€å‡ºè²¨å–®ã€è³ªæª¢å–®
2. **å¤šå€‰åº«æ”¯æ´** - å‹•æ…‹æ–°å¢å€‰åº«ï¼Œå¤šå€‰åº«çµ±ä¸€ç®¡ç†
3. **éšå±¤å¼å±•ç¤º** - å•†å“/è´ˆå“æ”¶åˆåˆ—è¡¨ï¼Œè®Šé«”åº«å­˜è‡ªå‹•åŠ ç¸½
4. **å¤šç¨®æˆæœ¬æ–¹æ³•** - FIFOã€LIFOã€åŠ æ¬Šå¹³å‡æˆæœ¬è¨ˆç®—
5. **ç¶ ç•Œç‰©æµæ•´åˆ** - è‡ªå‹•å»ºç«‹ç‰©æµè¨‚å–®ï¼ŒæŒçºŒç‹€æ…‹åŒæ­¥
6. **é å”®æ”¯æ´** - æ”¯æ´è² åº«å­˜éŠ·å”®ï¼Œé è³¼åŠŸèƒ½å®Œæ•´
7. **æ™ºèƒ½è­¦ç¤º** - å¯è¨­å®šçš„åº«å­˜è­¦ç¤ºé‚è¼¯
8. **18æ¨¡çµ„æ•´åˆ** - èˆ‡æ‰€æœ‰å¾Œå°æ¨¡çµ„æ·±åº¦æ•´åˆ
9. **æ¢ç¢¼æƒæ** - å®Œæ•´çš„QR Code/æ¢ç¢¼æƒææ”¯æ´
10. **æ¬Šé™æ§åˆ¶** - ç´°åˆ†çš„æ“ä½œæ¬Šé™å’Œå¯©æ ¸æ©Ÿåˆ¶

æ‰€æœ‰åŠŸèƒ½éƒ½å·²è©³ç´°è¨­è¨ˆï¼Œå¯ç›´æ¥æ ¹æ“šæ­¤æ–‡æª”é–‹ç™¼å®Œæ•´çš„åº«å­˜ç®¡ç†ç³»çµ±ã€‚