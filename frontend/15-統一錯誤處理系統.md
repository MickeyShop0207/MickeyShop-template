# 統一錯誤處理系統

## 現有問題分析

### 各系統錯誤處理不一致
- **國際化系統**: 使用 `console.warn` + 回退到空對象
- **狀態管理**: 多種錯誤處理方式，部分有恢復機制
- **PWA系統**: 簡單的 `throw new Error`，缺少分類
- **動畫系統**: 基本 `console.error`，無統一處理
- **快取系統**: 各自的錯誤處理策略

### 缺少的統一機制
- 錯誤分類和嚴重性判定
- 統一的錯誤恢復策略  
- 用戶友好的錯誤提示
- 錯誤上報和監控
- 跨系統錯誤協調

## 統一錯誤處理架構

### 錯誤分類系統
```js
// utils/error-types.js
export const ERROR_TYPES = {
  // 網路相關錯誤
  NETWORK: 'NETWORK',
  TIMEOUT: 'TIMEOUT', 
  CONNECTION: 'CONNECTION',
  
  // API相關錯誤
  API_ERROR: 'API_ERROR',
  VALIDATION: 'VALIDATION',
  PERMISSION: 'PERMISSION',
  
  // 系統錯誤
  CHUNK_LOAD: 'CHUNK_LOAD',
  MEMORY: 'MEMORY',
  STORAGE: 'STORAGE',
  
  // 用戶操作錯誤
  INPUT_ERROR: 'INPUT_ERROR',
  ACTION_FAILED: 'ACTION_FAILED',
  
  // 第三方錯誤
  PAYMENT: 'PAYMENT',
  AUTH_PROVIDER: 'AUTH_PROVIDER',
  CDN: 'CDN'
}

export const ERROR_SEVERITY = {
  LOW: 'low',       // 不影響核心功能
  MEDIUM: 'medium', // 影響部分功能
  HIGH: 'high',     // 影響主要功能
  CRITICAL: 'critical' // 影響整個應用
}
```

### 錯誤分類器
```js
// utils/error-classifier.js
export class ErrorClassifier {
  static classify(error, context = {}) {
    const errorInfo = {
      type: this.getErrorType(error, context),
      severity: this.getSeverity(error, context),
      message: this.getReadableMessage(error),
      stack: error.stack,
      context,
      timestamp: Date.now(),
      id: crypto.randomUUID(),
      recoverable: this.isRecoverable(error, context)
    }
    
    return errorInfo
  }
  
  static getErrorType(error, context) {
    // 網路錯誤
    if (error.name === 'NetworkError' || 
        error.message.includes('fetch') ||
        error.message.includes('network')) {
      return ERROR_TYPES.NETWORK
    }
    
    // API錯誤
    if (context.apiEndpoint || error.status) {
      return ERROR_TYPES.API_ERROR
    }
    
    // 載入錯誤
    if (error.name === 'ChunkLoadError' || 
        error.message.includes('Loading chunk')) {
      return ERROR_TYPES.CHUNK_LOAD
    }
    
    // 驗證錯誤
    if (error.name === 'ValidationError' || context.validation) {
      return ERROR_TYPES.VALIDATION
    }
    
    // 存儲錯誤
    if (error.name === 'QuotaExceededError' ||
        error.message.includes('storage')) {
      return ERROR_TYPES.STORAGE
    }
    
    // 權限錯誤
    if (error.status === 403 || error.status === 401) {
      return ERROR_TYPES.PERMISSION
    }
    
    // 超時錯誤
    if (error.name === 'TimeoutError' || 
        error.message.includes('timeout')) {
      return ERROR_TYPES.TIMEOUT
    }
    
    // 預設為一般錯誤
    return 'UNKNOWN'
  }
  
  static getSeverity(error, context) {
    const errorType = this.getErrorType(error, context)
    
    // 關鍵錯誤
    if (errorType === ERROR_TYPES.CHUNK_LOAD ||
        errorType === ERROR_TYPES.MEMORY ||
        (errorType === ERROR_TYPES.API_ERROR && context.critical)) {
      return ERROR_SEVERITY.CRITICAL
    }
    
    // 高嚴重性
    if (errorType === ERROR_TYPES.NETWORK ||
        errorType === ERROR_TYPES.STORAGE ||
        errorType === ERROR_TYPES.PAYMENT) {
      return ERROR_SEVERITY.HIGH
    }
    
    // 中等嚴重性
    if (errorType === ERROR_TYPES.API_ERROR ||
        errorType === ERROR_TYPES.TIMEOUT ||
        errorType === ERROR_TYPES.AUTH_PROVIDER) {
      return ERROR_SEVERITY.MEDIUM
    }
    
    // 低嚴重性
    return ERROR_SEVERITY.LOW
  }
  
  static getReadableMessage(error) {
    const messageMap = {
      'ChunkLoadError': '載入資源失敗，請重新整理頁面',
      'NetworkError': '網路連接異常，請檢查網路設定',
      'ValidationError': '輸入資料格式不正確',
      'QuotaExceededError': '儲存空間不足，請清理瀏覽器資料',
      'TimeoutError': '請求超時，請稍後再試'
    }
    
    return messageMap[error.name] || 
           messageMap[error.constructor.name] || 
           error.message || 
           '發生未知錯誤'
  }
  
  static isRecoverable(error, context) {
    const errorType = this.getErrorType(error, context)
    
    const recoverableTypes = [
      ERROR_TYPES.NETWORK,
      ERROR_TYPES.TIMEOUT,
      ERROR_TYPES.API_ERROR,
      ERROR_TYPES.CHUNK_LOAD
    ]
    
    return recoverableTypes.includes(errorType)
  }
}
```

### 統一錯誤處理中心
```js
// stores/error-handler.js
import { create } from 'zustand'
import { ErrorClassifier } from '@/utils/error-classifier'
import { ErrorRecovery } from '@/utils/error-recovery'
import { ErrorReporter } from '@/utils/error-reporter'

export const useErrorHandler = create((set, get) => ({
  // 錯誤狀態
  errors: [],
  globalError: null,
  isRecovering: false,
  recoveryAttempts: {},
  
  // 錯誤處理
  handleError: async (error, context = {}) => {
    const errorInfo = ErrorClassifier.classify(error, context)
    const state = get()
    
    // 記錄錯誤
    set({ 
      errors: [...state.errors, errorInfo].slice(-50) // 只保留最近50個錯誤
    })
    
    // 上報錯誤
    ErrorReporter.report(errorInfo)
    
    // 嚴重錯誤處理
    if (errorInfo.severity === ERROR_SEVERITY.CRITICAL) {
      set({ globalError: errorInfo })
      await get().handleCriticalError(errorInfo)
      return
    }
    
    // 嘗試恢復
    if (errorInfo.recoverable) {
      await get().attemptRecovery(errorInfo)
    }
    
    // 用戶提示
    get().showUserNotification(errorInfo)
  },
  
  // 關鍵錯誤處理
  handleCriticalError: async (errorInfo) => {
    set({ isRecovering: true })
    
    try {
      console.error('🚨 關鍵錯誤:', errorInfo)
      
      // 暫停非必要功能
      window.dispatchEvent(new CustomEvent('critical-error', { 
        detail: errorInfo 
      }))
      
      // 嘗試恢復
      const recovered = await ErrorRecovery.handleCritical(errorInfo)
      
      if (recovered) {
        set({ 
          globalError: null, 
          isRecovering: false 
        })
        
        window.dispatchEvent(new CustomEvent('error-recovered', { 
          detail: errorInfo 
        }))
      } else {
        // 恢復失敗，進入安全模式
        get().enterSafeMode()
      }
      
    } catch (recoveryError) {
      console.error('❌ 錯誤恢復失敗:', recoveryError)
      get().enterSafeMode()
    }
  },
  
  // 嘗試錯誤恢復
  attemptRecovery: async (errorInfo) => {
    const { recoveryAttempts } = get()
    const attempts = recoveryAttempts[errorInfo.id] || 0
    
    if (attempts >= 3) {
      console.warn('⚠️ 超過最大重試次數:', errorInfo)
      return false
    }
    
    set({
      recoveryAttempts: {
        ...recoveryAttempts,
        [errorInfo.id]: attempts + 1
      }
    })
    
    const recovered = await ErrorRecovery.attempt(errorInfo)
    
    if (recovered) {
      console.log('✅ 錯誤恢復成功:', errorInfo.type)
      // 清理成功恢復的錯誤
      const { recoveryAttempts } = get()
      delete recoveryAttempts[errorInfo.id]
      set({ recoveryAttempts })
    }
    
    return recovered
  },
  
  // 用戶通知
  showUserNotification: (errorInfo) => {
    const severity = errorInfo.severity
    const message = errorInfo.message
    
    // 根據嚴重性選擇通知類型
    if (severity === ERROR_SEVERITY.HIGH) {
      // 使用 Ant Design 的 notification
      window.dispatchEvent(new CustomEvent('show-error-notification', {
        detail: {
          type: 'error',
          title: '操作失敗',
          message,
          duration: 8
        }
      }))
    } else if (severity === ERROR_SEVERITY.MEDIUM) {
      window.dispatchEvent(new CustomEvent('show-error-notification', {
        detail: {
          type: 'warning',
          title: '請注意',
          message,
          duration: 5
        }
      }))
    }
    // 低嚴重性錯誤不顯示用戶通知
  },
  
  // 進入安全模式
  enterSafeMode: () => {
    console.log('🛡️ 進入安全模式')
    
    // 清除可能有問題的狀態
    localStorage.clear()
    sessionStorage.clear()
    
    // 通知所有系統進入安全模式
    window.dispatchEvent(new CustomEvent('enter-safe-mode'))
    
    // 最後手段：重新載入
    setTimeout(() => {
      window.location.reload()
    }, 3000)
  },
  
  // 清理錯誤
  clearErrors: () => {
    set({ 
      errors: [], 
      globalError: null,
      recoveryAttempts: {}
    })
  },
  
  // 手動重試
  retryOperation: (errorInfo) => {
    if (errorInfo.context.retryCallback) {
      errorInfo.context.retryCallback()
    }
  }
}))
```

### 錯誤恢復系統
```js
// utils/error-recovery.js
export class ErrorRecovery {
  static async attempt(errorInfo) {
    const { type, context } = errorInfo
    
    switch (type) {
      case ERROR_TYPES.NETWORK:
        return await this.recoverNetwork(context)
        
      case ERROR_TYPES.CHUNK_LOAD:
        return await this.recoverChunkLoad(context)
        
      case ERROR_TYPES.STORAGE:
        return await this.recoverStorage(context)
        
      case ERROR_TYPES.API_ERROR:
        return await this.recoverAPI(context)
        
      case ERROR_TYPES.TIMEOUT:
        return await this.recoverTimeout(context)
        
      default:
        return false
    }
  }
  
  static async handleCritical(errorInfo) {
    console.log('🔧 處理關鍵錯誤:', errorInfo.type)
    
    // 清理可能損壞的狀態
    try {
      // 清除 IndexedDB
      if ('indexedDB' in window) {
        const databases = await indexedDB.databases?.() || []
        for (const db of databases) {
          indexedDB.deleteDatabase(db.name)
        }
      }
      
      // 清除快取
      if ('caches' in window) {
        const cacheNames = await caches.keys()
        await Promise.all(
          cacheNames.map(name => caches.delete(name))
        )
      }
      
      // 重置狀態管理器
      if (window.stateCoordinator) {
        window.stateCoordinator.reset()
      }
      
      return true
      
    } catch (error) {
      console.error('❌ 關鍵錯誤恢復失敗:', error)
      return false
    }
  }
  
  static async recoverNetwork(context) {
    // 等待網路恢復
    if (!navigator.onLine) {
      return new Promise((resolve) => {
        const handleOnline = () => {
          window.removeEventListener('online', handleOnline)
          resolve(true)
        }
        window.addEventListener('online', handleOnline)
        
        // 3秒超時
        setTimeout(() => {
          window.removeEventListener('online', handleOnline)
          resolve(false)
        }, 3000)
      })
    }
    
    // 嘗試重新發送請求
    if (context.retryCallback) {
      try {
        await context.retryCallback()
        return true
      } catch {
        return false
      }
    }
    
    return false
  }
  
  static async recoverChunkLoad(context) {
    try {
      // 清除模組快取
      if (window.webpackChunkName) {
        delete window[window.webpackChunkName]
      }
      
      // 重新載入失敗的區塊
      if (context.chunkName && window.__webpack_require__) {
        await window.__webpack_require__(context.chunkName)
        return true
      }
      
      // 回退到頁面重新載入
      window.location.reload()
      return true
      
    } catch {
      return false
    }
  }
  
  static async recoverStorage(context) {
    try {
      // 清理 localStorage
      const usage = await navigator.storage?.estimate?.() || {}
      if (usage.quota && usage.usage) {
        const usageRatio = usage.usage / usage.quota
        if (usageRatio > 0.9) {
          // 清理舊數據
          this.cleanupStorage()
        }
      }
      
      return true
      
    } catch {
      return false
    }
  }
  
  static async recoverAPI(context) {
    const { status, endpoint, retryCallback } = context
    
    // 根據狀態碼決定恢復策略
    if (status === 401) {
      // 嘗試刷新 token
      try {
        await window.authStore?.getState?.()?.refreshToken?.()
        if (retryCallback) {
          await retryCallback()
          return true
        }
      } catch {
        // 重導向到登入頁
        window.location.href = '/login'
      }
    }
    
    if (status >= 500 && status < 600) {
      // 伺服器錯誤，等待後重試
      await this.delay(1000)
      if (retryCallback) {
        try {
          await retryCallback()
          return true
        } catch {
          return false
        }
      }
    }
    
    return false
  }
  
  static async recoverTimeout(context) {
    // 超時恢復：增加timeout時間後重試
    if (context.retryCallback) {
      try {
        await context.retryCallback()
        return true
      } catch {
        return false
      }
    }
    
    return false
  }
  
  static cleanupStorage() {
    try {
      // 清理過期的 localStorage 項目
      const now = Date.now()
      const keysToRemove = []
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i)
        if (key?.includes('cache-') || key?.includes('temp-')) {
          try {
            const item = JSON.parse(localStorage.getItem(key))
            if (item.expiry && item.expiry < now) {
              keysToRemove.push(key)
            }
          } catch {
            keysToRemove.push(key)
          }
        }
      }
      
      keysToRemove.forEach(key => localStorage.removeItem(key))
      
    } catch (error) {
      console.warn('⚠️ 儲存清理失敗:', error)
    }
  }
  
  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}
```

### 錯誤上報系統
```js
// utils/error-reporter.js
export class ErrorReporter {
  static async report(errorInfo) {
    // 開發環境只記錄到console
    if (process.env.NODE_ENV === 'development') {
      console.group(`🐛 [${errorInfo.severity}] ${errorInfo.type}`)
      console.error('錯誤訊息:', errorInfo.message)
      console.error('錯誤上下文:', errorInfo.context)
      console.error('錯誤堆疊:', errorInfo.stack)
      console.groupEnd()
      return
    }
    
    // 生產環境上報到錯誤監控服務
    try {
      // 採樣率控制（避免過多錯誤上報）
      const shouldReport = this.shouldReport(errorInfo)
      if (!shouldReport) return
      
      const reportData = {
        ...errorInfo,
        userAgent: navigator.userAgent,
        url: window.location.href,
        userId: this.getUserId(),
        sessionId: this.getSessionId(),
        buildVersion: process.env.REACT_APP_VERSION
      }
      
      // 使用 navigator.sendBeacon 確保錯誤能夠上報
      if (navigator.sendBeacon) {
        navigator.sendBeacon(
          '/api/errors',
          JSON.stringify(reportData)
        )
      } else {
        // 備用方案
        fetch('/api/errors', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(reportData),
          keepalive: true
        }).catch(() => {
          // 忽略上報失敗
        })
      }
      
    } catch (error) {
      console.warn('⚠️ 錯誤上報失敗:', error)
    }
  }
  
  static shouldReport(errorInfo) {
    // 關鍵和高嚴重性錯誤一定上報
    if (errorInfo.severity === ERROR_SEVERITY.CRITICAL ||
        errorInfo.severity === ERROR_SEVERITY.HIGH) {
      return true
    }
    
    // 中等嚴重性錯誤50%機率上報
    if (errorInfo.severity === ERROR_SEVERITY.MEDIUM) {
      return Math.random() < 0.5
    }
    
    // 低嚴重性錯誤10%機率上報
    return Math.random() < 0.1
  }
  
  static getUserId() {
    // 從認證狀態獲取用戶ID
    return window.authStore?.getState?.()?.user?.id || 'anonymous'
  }
  
  static getSessionId() {
    let sessionId = sessionStorage.getItem('session-id')
    if (!sessionId) {
      sessionId = crypto.randomUUID()
      sessionStorage.setItem('session-id', sessionId)
    }
    return sessionId
  }
}
```

## 各系統錯誤處理整合

### 國際化系統整合
```js
// 更新 utils/translation-loader.js
async _fetchTranslation(namespace, language) {
  try {
    const response = await fetch(`/locales/${language}/${namespace}.json`)
    if (!response.ok) {
      throw new Error(`Failed to load ${namespace} for ${language}`)
    }
    return await response.json()
  } catch (error) {
    // 使用統一錯誤處理
    useErrorHandler.getState().handleError(error, {
      type: 'translation-load',
      namespace,
      language,
      retryCallback: () => this._fetchTranslation(namespace, language)
    })
    
    // 返回空對象作為備用
    return {}
  }
}
```

### 狀態管理系統整合
```js
// 更新各個 store，統一錯誤處理
const useProductStore = create((set, get) => ({
  // ... 其他狀態
  
  loadProducts: async () => {
    try {
      set({ isLoading: true })
      const products = await api.getProducts()
      set({ products, isLoading: false })
    } catch (error) {
      set({ isLoading: false })
      
      // 使用統一錯誤處理
      useErrorHandler.getState().handleError(error, {
        apiEndpoint: '/api/products',
        critical: true, // 商品載入失敗是關鍵錯誤
        retryCallback: () => get().loadProducts()
      })
    }
  }
}))
```

### PWA系統整合
```js
// 更新 PWA 相關錯誤處理
async requestPermission() {
  try {
    if (!('Notification' in window)) {
      throw new Error('瀏覽器不支援通知功能')
    }
    
    const permission = await Notification.requestPermission()
    if (permission !== 'granted') {
      throw new Error('用戶拒絕通知權限')
    }
    
    return permission
  } catch (error) {
    useErrorHandler.getState().handleError(error, {
      type: 'pwa-permission',
      feature: 'notification'
    })
    throw error
  }
}
```

## React 錯誤邊界整合

### 全域錯誤邊界組件
```jsx
// components/ErrorBoundary.jsx
import React from 'react'
import { Result, Button } from 'antd'
import { useErrorHandler } from '@/stores/error-handler'

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false, errorInfo: null }
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true }
  }
  
  componentDidCatch(error, errorInfo) {
    // 使用統一錯誤處理系統
    useErrorHandler.getState().handleError(error, {
      type: 'react-boundary',
      componentStack: errorInfo.componentStack,
      critical: true
    })
    
    this.setState({ errorInfo })
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <Result
          status="500"
          title="頁面載入失敗"
          subTitle="抱歉，頁面遇到了問題"
          extra={
            <Button type="primary" onClick={() => window.location.reload()}>
              重新載入
            </Button>
          }
        />
      )
    }
    
    return this.props.children
  }
}

export default ErrorBoundary
```

### Hook錯誤處理
```js
// hooks/useErrorHandler.js
import { useCallback } from 'react'
import { useErrorHandler as useErrorStore } from '@/stores/error-handler'

export const useErrorHandler = () => {
  const { handleError } = useErrorStore()
  
  const handleAsyncError = useCallback(async (asyncFn, context = {}) => {
    try {
      return await asyncFn()
    } catch (error) {
      handleError(error, context)
      throw error // 重新拋出，讓調用者決定是否繼續處理
    }
  }, [handleError])
  
  const createErrorHandler = useCallback((context = {}) => {
    return (error) => handleError(error, context)
  }, [handleError])
  
  return {
    handleError,
    handleAsyncError,
    createErrorHandler
  }
}
```

## 全域錯誤監聽器設置

### 應用初始化錯誤監聽
```js
// main.jsx 或 App.jsx 中設置
import { useErrorHandler } from '@/stores/error-handler'

// 全域錯誤捕獲
window.addEventListener('error', (event) => {
  useErrorHandler.getState().handleError(event.error, {
    type: 'global-error',
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  })
})

// 未處理的 Promise 拒絕
window.addEventListener('unhandledrejection', (event) => {
  useErrorHandler.getState().handleError(event.reason, {
    type: 'unhandled-promise'
  })
})

// 資源載入錯誤
window.addEventListener('error', (event) => {
  if (event.target !== window) {
    useErrorHandler.getState().handleError(
      new Error(`資源載入失敗: ${event.target.src || event.target.href}`),
      {
        type: 'resource-load',
        element: event.target.tagName,
        src: event.target.src || event.target.href
      }
    )
  }
}, true)
```

## 錯誤處理最佳實踐

### 各系統統一規範
1. **所有系統必須使用 `useErrorHandler.getState().handleError()`**
2. **提供有意義的 context 信息**
3. **為可重試操作提供 retryCallback**
4. **標記關鍵性操作 critical: true**
5. **使用適當的錯誤類型分類**

### 錯誤恢復策略
1. **自動恢復**: 網路錯誤、超時錯誤
2. **用戶確認恢復**: 權限錯誤、驗證錯誤
3. **系統恢復**: 資源載入錯誤、儲存錯誤
4. **安全模式**: 關鍵系統錯誤

### 用戶體驗考慮
1. **錯誤訊息要用戶友好**
2. **提供明確的恢復操作**
3. **避免重複錯誤提示**
4. **保持應用可用性**

## 各系統引用指南

### 如何在各系統中使用統一錯誤處理

#### 1. 基本引用方式
```js
// 動態引用（推薦）
const { useErrorHandler } = await import('@/stores/error-handler')
useErrorHandler.getState().handleError(error, context)

// 靜態引用
import { useErrorHandler } from '@/stores/error-handler'
useErrorHandler.getState().handleError(error, context)
```

#### 2. 各系統具體整合

**國際化系統** (02-國際化實現策略.md):
```js
// 翻譯載入錯誤
useErrorHandler.getState().handleError(error, {
  type: 'translation-load',
  namespace,
  language,
  retryCallback: () => this._fetchTranslation(namespace, language)
})
```

**狀態管理系統** (04-狀態管理架構.md):
```js
// 註冊錯誤處理系統
stateCoordinator.register('error', useErrorHandler)
```

**動畫系統** (09-GSAP動畫系統設計.md):
```js
// 動畫載入錯誤
useErrorHandler.getState().handleError(error, {
  type: 'animation-load',
  animationName: name,
  retryCallback: () => this.loadAnimation(name)
})
```

**篩選系統** (12-前台篩選條件系統.md):
```js
// 篩選應用錯誤
useErrorHandler.getState().handleError(error, {
  type: 'filter-application',
  filters: filters,
  retryCallback: () => get().applyFilters(filters)
})
```

**PWA系統** (08-快取策略設計.md):
```js
// PWA功能錯誤（保持原有throw Error用於功能檢測）
// 僅在需要統一處理時使用
useErrorHandler.getState().handleError(error, {
  type: 'pwa-feature',
  feature: 'notification'
})
```

#### 3. Context參數建議

**必要參數**：
- `type`: 錯誤類型（見ERROR_TYPES）
- `retryCallback`: 重試函數（可選但推薦）

**可選參數**：
- `critical`: 是否關鍵錯誤
- `apiEndpoint`: API端點（API錯誤時）
- `componentName`: 組件名稱
- `userId`: 用戶ID
- `feature`: 功能名稱

#### 4. 最佳實踐

1. **保持獨立性**: 錯誤處理系統保持獨立，各系統按需引用
2. **動態引用**: 使用`import()`避免循環依賴
3. **有意義的context**: 提供足夠的錯誤上下文信息
4. **重試機制**: 為可恢復錯誤提供retryCallback
5. **功能性錯誤**: 功能檢測錯誤可保持原有處理方式

這個統一錯誤處理系統解決了各系統錯誤處理不一致的問題，提供了完整的錯誤分類、恢復、上報機制。